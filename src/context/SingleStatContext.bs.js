// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as AuthHooks from "../hooks/AuthHooks.bs.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "../utils/LogicUtils.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as Core__Promise from "@rescript/core/src/Core__Promise.bs.js";
import * as FilterContext from "./FilterContext.bs.js";
import * as LineChartUtils from "../components/CustomCharts/LineChartUtils.bs.js";
import * as DictionaryUtils from "../utils/DictionaryUtils.bs.js";
import * as AuthWrapperUtils from "../components/AuthWrapperUtils.bs.js";
import * as AnalyticsNewUtils from "../utils/AnalyticsNewUtils.bs.js";
import * as AnalyticsLogUtilsHook from "../screens/Hooks/AnalyticsLogUtilsHook.bs.js";
import * as BetaEndPointConfigProvider from "./BetaEndPointConfigProvider.bs.js";

var singleStatComponentDefVal_singleStatLoader = {};

function singleStatComponentDefVal_singleStatIsVisible(param) {}

var singleStatComponentDefVal = {
  singleStatData: undefined,
  singleStatTimeSeries: undefined,
  singleStatDelta: undefined,
  singleStatLoader: singleStatComponentDefVal_singleStatLoader,
  singleStatIsVisible: singleStatComponentDefVal_singleStatIsVisible,
};

var singleStatContext = React.createContext(singleStatComponentDefVal);

var make = singleStatContext.Provider;

var Provider = {
  make: make,
};

function SingleStatContext(props) {
  var __setIndividualSingleStatTime = props.setIndividualSingleStatTime;
  var __setSingleStatTime = props.setSingleStatTime;
  var singleStatEntity = props.singleStatEntity;
  var setSingleStatTime =
    __setSingleStatTime !== undefined
      ? __setSingleStatTime
      : function (param) {};
  var setIndividualSingleStatTime =
    __setIndividualSingleStatTime !== undefined
      ? __setIndividualSingleStatTime
      : function (param) {};
  var metrixMapper = singleStatEntity.metrixMapper;
  var customFilterKey = singleStatEntity.customFilterKey;
  var moduleName = singleStatEntity.moduleName;
  var endTimeFilterKey = singleStatEntity.endTimeFilterKey;
  var startTimeFilterKey = singleStatEntity.startTimeFilterKey;
  var filterKeys = singleStatEntity.filterKeys;
  var modeKey = singleStatEntity.modeKey;
  var source = singleStatEntity.source;
  var dataFetcherObj = singleStatEntity.dataFetcherObj;
  var jsonTransformer = singleStatEntity.jsonTransformer;
  var jsonTransFormer =
    jsonTransformer !== undefined
      ? jsonTransformer
      : function (_val, arr) {
          return arr;
        };
  var match = React.useContext(FilterContext.filterContext);
  var filterValueJson = match.filterValueJson;
  var match$1 = React.useState(function () {
    return false;
  });
  var setSingleStatIsVisible = match$1[1];
  var isSingleStatVisible = match$1[0];
  var parentToken = AuthWrapperUtils.useTokenParent("Original");
  var addLogsAroundFetch = AnalyticsLogUtilsHook.useAddLogsAroundFetchNew();
  var betaEndPointConfig = React.useContext(
    BetaEndPointConfigProvider.betaEndPointConfig,
  );
  var fetchApi = AuthHooks.useApiFetcher();
  var getTopLevelSingleStatFilter = React.useMemo(
    function () {
      return Object.fromEntries(
        Belt_Array.keepMap(Object.entries(filterValueJson), function (item) {
          var keyArr = item[0].split(".");
          var prefix = Core__Option.getOr(keyArr[0], "");
          if (prefix === moduleName && LogicUtils.isNonEmptyString(prefix)) {
            return;
          } else {
            return [prefix, item[1]];
          }
        }),
      );
    },
    [filterValueJson],
  );
  var match$2 = React.useMemo(
    function () {
      var modeValue = LogicUtils.getString(
        getTopLevelSingleStatFilter,
        modeKey,
        "",
      );
      var allFilterKeys = [
        startTimeFilterKey,
        endTimeFilterKey,
        Core__Option.getOr(modeValue, ""),
      ].concat(filterKeys);
      var filterSearchParam = Belt_Array.keepMap(
        Object.entries(getTopLevelSingleStatFilter),
        function (entry) {
          var key = entry[0];
          if (!allFilterKeys.includes(key)) {
            return;
          }
          var str = Core__JSON.Classify.classify(entry[1]);
          if (typeof str !== "object") {
            return;
          }
          switch (str.TAG) {
            case "String":
              return key + "=" + str._0;
            case "Number":
              return key + "=" + String(str._0);
            case "Array":
              return key + "=[" + String(str._0) + "]";
            default:
              return;
          }
        },
      ).join("&");
      return [
        filterSearchParam,
        LogicUtils.getString(getTopLevelSingleStatFilter, customFilterKey, ""),
        modeValue,
      ];
    },
    [getTopLevelSingleStatFilter],
  );
  var modeValue = match$2[2];
  var customFilter = match$2[1];
  var topFiltersToSearchParam = match$2[0];
  var filterValueFromUrl = React.useMemo(
    function () {
      return LogicUtils.getJsonFromArrayOfJson(
        Belt_Array.keepMap(
          Object.entries(getTopLevelSingleStatFilter),
          function (entries) {
            var key = entries[0];
            if (filterKeys.includes(key)) {
              return [key, entries[1]];
            }
          },
        ),
      );
    },
    [topFiltersToSearchParam],
  );
  var startTimeFromUrl = React.useMemo(
    function () {
      return LogicUtils.getString(
        getTopLevelSingleStatFilter,
        startTimeFilterKey,
        "",
      );
    },
    [topFiltersToSearchParam],
  );
  var endTimeFromUrl = React.useMemo(
    function () {
      return LogicUtils.getString(
        getTopLevelSingleStatFilter,
        endTimeFilterKey,
        "",
      );
    },
    [topFiltersToSearchParam],
  );
  var initialValue = Object.fromEntries(
    dataFetcherObj.map(function (item) {
      var updatedMetrics = metrixMapper(item.metrics);
      return [updatedMetrics, "Loading"];
    }),
  );
  var initialValueLoader = Object.fromEntries(
    dataFetcherObj.map(function (item) {
      var updatedMetrics = metrixMapper(item.metrics);
      return [updatedMetrics, "Shimmer"];
    }),
  );
  var match$3 = React.useState(function () {
    return initialValue;
  });
  var setSingleStatStateData = match$3[1];
  var singleStatStateData = match$3[0];
  var match$4 = React.useState(function () {
    return initialValue;
  });
  var setSingleStatTimeSeries = match$4[1];
  var singleStatTimeSeries = match$4[0];
  var match$5 = React.useState(function () {
    return initialValue;
  });
  var setSingleStatStateDataHistoric = match$5[1];
  var singleStatStateDataHistoric = match$5[0];
  var match$6 = React.useState(function () {
    return initialValueLoader;
  });
  var setSingleStatLoader = match$6[1];
  var singleStatLoader = match$6[0];
  var match$7 = React.useState(function () {
    return false;
  });
  var setIsSingleStatFetchedWithCurrentDependency = match$7[1];
  var singleStatFetchedWithCurrentDependency = match$7[0];
  React.useEffect(
    function () {
      if (
        LogicUtils.isNonEmptyString(startTimeFromUrl) &&
        LogicUtils.isNonEmptyString(endTimeFromUrl) &&
        Core__Option.isSome(parentToken)
      ) {
        setIsSingleStatFetchedWithCurrentDependency(function (param) {
          return false;
        });
      }
    },
    [
      endTimeFromUrl,
      startTimeFromUrl,
      filterValueFromUrl,
      parentToken,
      customFilter,
      modeValue,
    ],
  );
  React.useEffect(
    function () {
      if (!singleStatFetchedWithCurrentDependency && isSingleStatVisible) {
        setIsSingleStatFetchedWithCurrentDependency(function (param) {
          return true;
        });
        var granularity = LineChartUtils.getGranularityNew(
          startTimeFromUrl,
          endTimeFromUrl,
        );
        var filterConfigCurrent_modeValue = Core__Option.getOr(modeValue, "");
        var filterConfigCurrent_granularity = granularity[0];
        var filterConfigCurrent = {
          source: source,
          modeValue: filterConfigCurrent_modeValue,
          filterValues: filterValueFromUrl,
          startTime: startTimeFromUrl,
          endTime: endTimeFromUrl,
          customFilterValue: customFilter,
          granularity: filterConfigCurrent_granularity,
        };
        var match = AnalyticsNewUtils.calculateHistoricTime(
          startTimeFromUrl,
          endTimeFromUrl,
          undefined,
          undefined,
          undefined,
        );
        var newrecord = Caml_obj.obj_dup(filterConfigCurrent);
        newrecord.endTime = match[1];
        newrecord.startTime = match[0];
        setSingleStatTime(function (param) {
          return {
            apiStartTime: Date.now(),
            apiEndTime: 0,
          };
        });
        dataFetcherObj.map(function (urlConfig, index) {
          var url = urlConfig.url;
          var metrics = urlConfig.metrics;
          var updatedMetrics = metrixMapper(metrics);
          setIndividualSingleStatTime(function (prev) {
            var individualTime = Object.fromEntries(Object.entries(prev));
            individualTime[index.toString()] = Date.now();
            return individualTime;
          });
          setSingleStatStateData(function (prev) {
            var prevDict = DictionaryUtils.copyOfDict(prev);
            prevDict[updatedMetrics] = "Loading";
            return prevDict;
          });
          setSingleStatTimeSeries(function (prev) {
            var prevDict = DictionaryUtils.copyOfDict(prev);
            prevDict[updatedMetrics] = "Loading";
            return prevDict;
          });
          setSingleStatStateDataHistoric(function (prev) {
            var prevDict = DictionaryUtils.copyOfDict(prev);
            prevDict[updatedMetrics] = "Loading";
            return prevDict;
          });
          var timeObj = Object.fromEntries([
            ["start", startTimeFromUrl],
            ["end", endTimeFromUrl],
          ]);
          var historicTimeObj = Object.fromEntries([
            ["start", newrecord.startTime],
            ["end", newrecord.endTime],
          ]);
          var granularity = filterConfigCurrent_granularity;
          var granularityConfig =
            granularity !== undefined ? granularity : [1, "hour"];
          var singleStatHistoricDataFetch = Core__Promise.$$catch(
            addLogsAroundFetch(
              undefined,
              "SingleStat histotic data for metrics " + metrixMapper(metrics),
              fetchApi(
                url +
                  "?api-type=singlestat&time=historic&metrics=" +
                  updatedMetrics,
                JSON.stringify(
                  AnalyticsNewUtils.apiBodyMaker(
                    historicTimeObj,
                    updatedMetrics,
                    undefined,
                    undefined,
                    undefined,
                    newrecord.filterValues,
                    newrecord.customFilterValue,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    urlConfig.domain,
                    undefined,
                    undefined,
                  ),
                ),
                undefined,
                Object.fromEntries([["QueryType", "SingleStatHistoric"]]),
                "Post",
                betaEndPointConfig,
                undefined,
                undefined,
              ),
            ).then(function (text) {
              var jsonObj =
                LogicUtils.convertNewLineSaperatedDataToArrayOfJson(text);
              var jsonObj$1 = jsonTransFormer(updatedMetrics, jsonObj);
              return Promise.resolve(
                (setSingleStatStateDataHistoric(function (prev) {
                  var prevDict = DictionaryUtils.copyOfDict(prev);
                  prevDict[updatedMetrics] = {
                    TAG: "Loaded",
                    _0: Core__Option.getOr(jsonObj$1[0], {}),
                  };
                  return prevDict;
                }),
                {
                  TAG: "Loaded",
                  _0: {},
                }),
              );
            }),
            function (_err) {
              setSingleStatStateDataHistoric(function (prev) {
                var prevDict = DictionaryUtils.copyOfDict(prev);
                prevDict[updatedMetrics] = "LoadedError";
                return prevDict;
              });
              return Promise.resolve("LoadedError");
            },
          );
          var singleStatDataFetch = Core__Promise.$$catch(
            addLogsAroundFetch(
              undefined,
              "SingleStat data for metrics " + metrixMapper(metrics),
              fetchApi(
                url + "?api-type=singlestat&metrics=" + updatedMetrics,
                JSON.stringify(
                  AnalyticsNewUtils.apiBodyMaker(
                    timeObj,
                    updatedMetrics,
                    undefined,
                    undefined,
                    undefined,
                    filterValueFromUrl,
                    customFilter,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    urlConfig.domain,
                    undefined,
                    undefined,
                  ),
                ),
                undefined,
                Object.fromEntries([["QueryType", "SingleStat"]]),
                "Post",
                betaEndPointConfig,
                undefined,
                undefined,
              ),
            ).then(function (text) {
              var jsonObj =
                LogicUtils.convertNewLineSaperatedDataToArrayOfJson(text);
              var jsonObj$1 = jsonTransFormer(updatedMetrics, jsonObj);
              setSingleStatStateData(function (prev) {
                var prevDict = DictionaryUtils.copyOfDict(prev);
                prevDict[updatedMetrics] = {
                  TAG: "Loaded",
                  _0: Core__Option.getOr(jsonObj$1[0], {}),
                };
                return prevDict;
              });
              return Promise.resolve({
                TAG: "Loaded",
                _0: {},
              });
            }),
            function (_err) {
              setSingleStatStateData(function (prev) {
                var prevDict = DictionaryUtils.copyOfDict(prev);
                prevDict[updatedMetrics] = "LoadedError";
                return prevDict;
              });
              return Promise.resolve("LoadedError");
            },
          );
          var singleStatDataFetchTimeSeries = Core__Promise.$$catch(
            addLogsAroundFetch(
              undefined,
              "SingleStat Time Series data for metrics " +
                metrixMapper(metrics),
              fetchApi(
                url +
                  "?api-type=singlestat-timeseries&metrics=" +
                  updatedMetrics,
                JSON.stringify(
                  AnalyticsNewUtils.apiBodyMaker(
                    timeObj,
                    updatedMetrics,
                    undefined,
                    granularityConfig,
                    undefined,
                    filterValueFromUrl,
                    customFilter,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    urlConfig.timeColumn,
                    urlConfig.domain,
                    undefined,
                    undefined,
                  ),
                ),
                undefined,
                Object.fromEntries([["QueryType", "SingleStat Time Series"]]),
                "Post",
                betaEndPointConfig,
                undefined,
                undefined,
              ),
            ).then(function (text) {
              var jsonObj = LogicUtils.convertNewLineSaperatedDataToArrayOfJson(
                text,
              ).map(function (item) {
                return Object.fromEntries(
                  Object.entries(LogicUtils.getDictFromJsonObject(item)).map(
                    function (dictEn) {
                      var key = dictEn[0];
                      return [
                        key === urlConfig.timeColumn + "_time" ? "time" : key,
                        dictEn[1],
                      ];
                    },
                  ),
                );
              });
              var jsonObj$1 = jsonTransFormer(updatedMetrics, jsonObj);
              setSingleStatTimeSeries(function (prev) {
                var prevDict = DictionaryUtils.copyOfDict(prev);
                prevDict[updatedMetrics] = {
                  TAG: "Loaded",
                  _0: jsonObj$1,
                };
                return prevDict;
              });
              return Promise.resolve({
                TAG: "Loaded",
                _0: {},
              });
            }),
            function (_err) {
              setSingleStatTimeSeries(function (prev) {
                var prevDict = DictionaryUtils.copyOfDict(prev);
                prevDict[updatedMetrics] = "LoadedError";
                return prevDict;
              });
              return Promise.resolve("LoadedError");
            },
          );
          Promise.all([
            singleStatDataFetchTimeSeries,
            singleStatHistoricDataFetch,
            singleStatDataFetch,
          ]).then(function (value) {
            var ssH = Core__Option.getOr(value[0], "LoadedError");
            var ssT = Core__Option.getOr(value[1], "LoadedError");
            var ssD = Core__Option.getOr(value[2], "LoadedError");
            var isLoaded = function (val) {
              if (typeof val !== "object") {
                return false;
              } else {
                return true;
              }
            };
            setSingleStatLoader(function (prev) {
              var prevDict = DictionaryUtils.copyOfDict(prev);
              if (isLoaded(ssH) && isLoaded(ssT) && isLoaded(ssD)) {
                prevDict[updatedMetrics] = "SideLoader";
              }
              return prevDict;
            });
            setIndividualSingleStatTime(function (prev) {
              var individualTime = Object.fromEntries(Object.entries(prev));
              individualTime[index.toString()] =
                Date.now() -
                Core__Option.getOr(
                  individualTime[index.toString()],
                  Date.now(),
                );
              return individualTime;
            });
            if (index === ((dataFetcherObj.length - 1) | 0)) {
              return setSingleStatTime(function (prev) {
                return {
                  apiStartTime: prev.apiStartTime,
                  apiEndTime: Date.now(),
                };
              });
            }
          });
        });
      }
    },
    [singleStatFetchedWithCurrentDependency, isSingleStatVisible],
  );
  var value = React.useMemo(
    function () {
      return {
        singleStatData: singleStatStateData,
        singleStatTimeSeries: singleStatTimeSeries,
        singleStatDelta: singleStatStateDataHistoric,
        singleStatLoader: singleStatLoader,
        singleStatIsVisible: setSingleStatIsVisible,
      };
    },
    [
      singleStatStateData,
      singleStatTimeSeries,
      singleStatLoader,
      setSingleStatIsVisible,
    ],
  );
  return React.createElement(make, {
    value: value,
    children: props.children,
  });
}

var make$1 = SingleStatContext;

export {
  singleStatComponentDefVal,
  singleStatContext,
  Provider,
  make$1 as make,
};
/* singleStatContext Not a pure module */
