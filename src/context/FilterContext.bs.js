// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "../utils/LogicUtils.bs.js";
import * as FilterUtils from "../components/FilterUtils.bs.js";
import * as UrlFetchUtils from "../utils/UrlFetchUtils.bs.js";
import * as DictionaryUtils from "../utils/DictionaryUtils.bs.js";

var filterUpdater_filterValue = {};

function filterUpdater_updateExistingKeys(_dict) {}

function filterUpdater_removeKeys(_arr) {}

var filterUpdater_filterKeys = [];

function filterUpdater_setfilterKeys(param) {}

var filterUpdater_filterValueJson = {};

function filterUpdater_reset() {}

var filterUpdater = {
  query: "",
  filterValue: filterUpdater_filterValue,
  updateExistingKeys: filterUpdater_updateExistingKeys,
  removeKeys: filterUpdater_removeKeys,
  filterKeys: filterUpdater_filterKeys,
  setfilterKeys: filterUpdater_setfilterKeys,
  filterValueJson: filterUpdater_filterValueJson,
  reset: filterUpdater_reset,
};

var filterContext = React.createContext(filterUpdater);

var make = filterContext.Provider;

var Provider = {
  make: make,
};

function FilterContext(props) {
  var index = props.index;
  var query = React.useMemo(function () {
    return {
      contents: "",
    };
  }, []);
  var match = React.useState(function () {
    return [];
  });
  var setfilterKeys = match[1];
  var filterKeys = match[0];
  var searcParamsToDict = FilterUtils.parseFilterString(query.contents);
  var match$1 = React.useState(function () {
    return searcParamsToDict;
  });
  var setfilterDict = match$1[1];
  var filterDict = match$1[0];
  var clearSessionStorage = function () {
    sessionStorage.removeItem(index);
    sessionStorage.removeItem(index + "-list");
    setfilterKeys(function (param) {
      return [];
    });
  };
  var updateFilter = React.useMemo(
    function () {
      var updateFilter = function (dict) {
        setfilterDict(function (prev) {
          var prevDictArr = Belt_Array.keepMap(
            Object.entries(prev),
            function (item) {
              var match = dict[item[0]];
              if (match !== undefined || LogicUtils.isEmptyString(item[1])) {
                return;
              } else {
                return item;
              }
            },
          );
          var currentDictArr = Object.entries(dict).filter(function (item) {
            return !LogicUtils.isEmptyString(item[1]);
          });
          var updatedDict = Object.fromEntries(
            prevDictArr.concat(currentDictArr),
          );
          var dict$1 = DictionaryUtils.equalDicts(updatedDict, prev)
            ? prev
            : updatedDict;
          query.contents = FilterUtils.parseFilterDict(dict$1);
          return dict$1;
        });
      };
      var reset = function () {
        var dict = {};
        setfilterDict(function (param) {
          return dict;
        });
        query.contents = FilterUtils.parseFilterDict(dict);
        clearSessionStorage();
      };
      var removeKeys = function (arr) {
        setfilterDict(function (prev) {
          var updatedDict = DictionaryUtils.deleteKeys(
            Object.fromEntries(Object.entries(prev).slice()),
            arr,
          );
          var dict = DictionaryUtils.equalDicts(updatedDict, prev)
            ? prev
            : updatedDict;
          query.contents = FilterUtils.parseFilterDict(dict);
          return dict;
        });
        clearSessionStorage();
      };
      return {
        query: query.contents,
        filterValue: filterDict,
        updateExistingKeys: updateFilter,
        removeKeys: removeKeys,
        filterKeys: filterKeys,
        setfilterKeys: setfilterKeys,
        filterValueJson: Object.fromEntries(
          Object.entries(filterDict).map(function (item) {
            return [item[0], UrlFetchUtils.getFilterValue(item[1])];
          }),
        ),
        reset: reset,
      };
    },
    [filterDict, setfilterDict, filterKeys],
  );
  React.useEffect(function () {
    var value = sessionStorage.getItem(index);
    if (!(value == null)) {
      updateFilter.updateExistingKeys(FilterUtils.parseFilterString(value));
    }
    var keys = [];
    var value$1 = sessionStorage.getItem(index + "-list");
    if (!(value$1 == null)) {
      var arr = Core__JSON.Decode.array(JSON.parse(value$1));
      if (arr !== undefined) {
        arr.forEach(function (item) {
          var str = Core__JSON.Decode.string(item);
          if (str !== undefined) {
            keys.push(str);
            return;
          }
        });
        setfilterKeys(function (param) {
          return keys;
        });
      }
    }
    return function () {
      clearSessionStorage();
    };
  }, []);
  React.useEffect(
    function () {
      if (query.contents.length >= 1) {
        sessionStorage.setItem(index, query.contents);
      }
      sessionStorage.setItem(
        index + "-list",
        JSON.stringify(
          filterKeys.map(function (item) {
            return item;
          }),
        ),
      );
    },
    [query.contents, filterKeys],
  );
  return React.createElement(make, {
    value: updateFilter,
    children: props.children,
  });
}

var make$1 = FilterContext;

export { filterUpdater, filterContext, Provider, make$1 as make };
/* filterContext Not a pure module */
