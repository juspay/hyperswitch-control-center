// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as AuthHooks from "../hooks/AuthHooks.bs.js";
import * as Core__Int from "@rescript/core/src/Core__Int.bs.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "../utils/LogicUtils.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as DynamicChart from "../components/DynamicChart.bs.js";
import * as Core__Promise from "@rescript/core/src/Core__Promise.bs.js";
import * as FilterContext from "./FilterContext.bs.js";
import * as UrlFetchUtils from "../utils/UrlFetchUtils.bs.js";
import * as LineChartUtils from "../components/CustomCharts/LineChartUtils.bs.js";
import * as AuthWrapperUtils from "../components/AuthWrapperUtils.bs.js";
import * as AnalyticsNewUtils from "../utils/AnalyticsNewUtils.bs.js";
import * as AnalyticsLogUtilsHook from "../screens/Hooks/AnalyticsLogUtilsHook.bs.js";
import * as BetaEndPointConfigProvider from "./BetaEndPointConfigProvider.bs.js";

function chartComponentDefVal_setTopChartVisible(param) {}

function chartComponentDefVal_setBottomChartVisible(param) {}

function chartComponentDefVal_setGranularity(param) {}

var chartComponentDefVal = {
  topChartData: undefined,
  bottomChartData: undefined,
  topChartLegendData: undefined,
  bottomChartLegendData: undefined,
  setTopChartVisible: chartComponentDefVal_setTopChartVisible,
  setBottomChartVisible: chartComponentDefVal_setBottomChartVisible,
  setGranularity: chartComponentDefVal_setGranularity,
  granularity: undefined,
};

function cardinalityMapperToNumber(cardinality) {
  if (cardinality === undefined) {
    return 5;
  }
  switch (cardinality) {
    case "TOP_10":
      return 10;
    default:
      return 5;
  }
}

function getGranularityMapper(granularity) {
  var granularityArr = granularity.split(" ").map(function (item) {
    return item.trim();
  });
  if (granularity === "Daily") {
    return [1, "day"];
  } else if (granularity === "Weekly") {
    return [1, "week"];
  } else if (granularity === "Hourly") {
    return [1, "hour"];
  } else {
    return [
      Core__Option.getOr(
        Core__Int.fromString(
          undefined,
          Core__Option.getOr(granularityArr[0], "1"),
        ),
        1,
      ),
      Core__Option.getOr(granularityArr[1], "week"),
    ];
  }
}

var chartContext = React.createContext(chartComponentDefVal);

var make = chartContext.Provider;

var Provider = {
  make: make,
};

function ChartContext(props) {
  var defaultFilter = props.defaultFilter;
  var __chartId = props.chartId;
  var chartEntity = props.chartEntity;
  var chartId = __chartId !== undefined ? __chartId : "";
  var match = React.useContext(FilterContext.filterContext);
  var filterValueJson = match.filterValueJson;
  var match$1 = React.useMemo(
    function () {
      var activeTabOptionalArr = LogicUtils.getOptionStrArrayFromDict(
        filterValueJson,
        chartEntity.moduleName + ".tabName",
      );
      return [
        activeTabOptionalArr,
        Core__Option.getOr(activeTabOptionalArr, []).join(","),
      ];
    },
    [filterValueJson],
  );
  var activeTabStr = match$1[1];
  var activeTab = match$1[0];
  var parentToken = AuthWrapperUtils.useTokenParent("Original");
  var addLogsAroundFetch = AnalyticsLogUtilsHook.useAddLogsAroundFetchNew();
  var betaEndPointConfig = React.useContext(
    BetaEndPointConfigProvider.betaEndPointConfig,
  );
  var fetchApi = AuthHooks.useApiFetcher();
  var jsonTransformer = chartEntity.jsonTransformer;
  var jsonTransFormer =
    jsonTransformer !== undefined
      ? jsonTransformer
      : function (_val, arr) {
          return arr;
        };
  var match$2 = React.useState(function () {
    return "Loading";
  });
  var setTopChartData = match$2[1];
  var topChartData = match$2[0];
  var match$3 = React.useState(function () {
    return false;
  });
  var setTopChartVisible = match$3[1];
  var topChartVisible = match$3[0];
  var match$4 = React.useState(function () {
    return "Loading";
  });
  var setBottomChartData = match$4[1];
  var bottomChartData = match$4[0];
  var match$5 = React.useState(function () {
    return false;
  });
  var setBottomChartVisible = match$5[1];
  var bottomChartVisible = match$5[0];
  var match$6 = React.useState(function () {
    return "Loading";
  });
  var setTopChartDataLegendData = match$6[1];
  var topChartDataLegendData = match$6[0];
  var match$7 = React.useState(function () {
    return "Loading";
  });
  var setBottomChartDataLegendData = match$7[1];
  var bottomChartDataLegendData = match$7[0];
  var match$8 = React.useContext(FilterContext.filterContext);
  var match$9 = chartEntity.currentMetrics;
  var match$10 = chartEntity.dateFilterKeys;
  var endTimeFilterKey = match$10[1];
  var startTimeFilterKey = match$10[0];
  var defaultFilters = [startTimeFilterKey, endTimeFilterKey];
  var sortingParams = React.useMemo(
    function () {
      var sortingColumnLegend = chartEntity.sortingColumnLegend;
      if (sortingColumnLegend !== undefined) {
        return {
          sortDimension: sortingColumnLegend,
          ordering: "Desc",
        };
      }
    },
    [chartEntity.sortingColumnLegend],
  );
  var allFilterKeys = defaultFilters.concat(chartEntity.allFilterDimension);
  var customFilterKey = chartEntity.customFilterKey;
  var customFilterKey$1 = customFilterKey !== undefined ? customFilterKey : "";
  var getAllFilter = Object.fromEntries(
    Object.entries(match$8.filterValue).map(function (item) {
      return [item[0], UrlFetchUtils.getFilterValue(item[1])];
    }),
  );
  var getTopLevelChartFilter = React.useMemo(
    function () {
      return Object.fromEntries(
        Belt_Array.keepMap(Object.entries(getAllFilter), function (item) {
          var keyArr = item[0].split(".");
          var prefix = Core__Option.getOr(keyArr[0], "");
          if (prefix === chartId && LogicUtils.isNonEmptyString(prefix)) {
            return;
          } else {
            return [prefix, item[1]];
          }
        }),
      );
    },
    [getAllFilter],
  );
  var match$11 = React.useMemo(
    function () {
      var filterSearchParam = Belt_Array.keepMap(
        Object.entries(getTopLevelChartFilter),
        function (entry) {
          var key = entry[0];
          if (!allFilterKeys.includes(key)) {
            return;
          }
          var str = Core__JSON.Classify.classify(entry[1]);
          if (typeof str !== "object") {
            return;
          }
          switch (str.TAG) {
            case "String":
              return key + "=" + str._0;
            case "Number":
              return key + "=" + String(str._0);
            case "Array":
              return key + "=[" + String(str._0) + "]";
            default:
              return;
          }
        },
      ).join("&");
      return [
        filterSearchParam,
        LogicUtils.getString(getTopLevelChartFilter, customFilterKey$1, ""),
      ];
    },
    [getTopLevelChartFilter],
  );
  var customFilter = match$11[1];
  var customFilter$1 =
    defaultFilter !== undefined
      ? LogicUtils.isEmptyString(customFilter)
        ? defaultFilter
        : defaultFilter + " and " + customFilter
      : customFilter;
  var getChartCompFilters = React.useMemo(
    function () {
      return Object.fromEntries(
        Belt_Array.keepMap(Object.entries(getAllFilter), function (item) {
          var value = item[1];
          var keyArr = item[0].split(".");
          var prefix = Core__Option.getOr(keyArr[0], "");
          var fitlerName = Core__Option.getOr(keyArr[1], "");
          if (LogicUtils.isEmptyString(chartId)) {
            return [prefix, value];
          } else if (
            prefix === chartId &&
            LogicUtils.isNonEmptyString(fitlerName)
          ) {
            return [fitlerName, value];
          } else {
            return;
          }
        }),
      );
    },
    [getAllFilter],
  );
  var match$12 = React.useMemo(
    function () {
      var startTimeFromUrl = LogicUtils.getString(
        getTopLevelChartFilter,
        startTimeFilterKey,
        "",
      );
      var endTimeFromUrl = LogicUtils.getString(
        getTopLevelChartFilter,
        endTimeFilterKey,
        "",
      );
      var filterValueFromUrl = Object.fromEntries(
        Belt_Array.keepMap(
          Object.entries(getTopLevelChartFilter),
          function (entries) {
            var key = entries[0];
            if (chartEntity.allFilterDimension.includes(key)) {
              return [key, entries[1]];
            }
          },
        ),
      );
      return [startTimeFromUrl, endTimeFromUrl, filterValueFromUrl];
    },
    [match$11[0]],
  );
  var filterValueFromUrl = match$12[2];
  var endTimeFromUrl = match$12[1];
  var startTimeFromUrl = match$12[0];
  var cardinalityFromUrl = LogicUtils.getString(
    getChartCompFilters,
    "cardinality",
    "TOP_5",
  );
  var chartTopMetricFromUrl = LogicUtils.getString(
    getChartCompFilters,
    "chartTopMetric",
    match$9[0],
  );
  var chartBottomMetricFromUrl = LogicUtils.getString(
    getChartCompFilters,
    "chartBottomMetric",
    match$9[1],
  );
  var match$13 = React.useState(function () {});
  var setGranularity = match$13[1];
  var granularity = match$13[0];
  var current_granularity =
    LogicUtils.isNonEmptyString(startTimeFromUrl) &&
    LogicUtils.isNonEmptyString(endTimeFromUrl)
      ? LineChartUtils.getGranularityNewStr(startTimeFromUrl, endTimeFromUrl)
      : [];
  React.useEffect(
    function () {
      setGranularity(function (prev) {
        if (current_granularity.includes(Core__Option.getOr(prev, ""))) {
          return prev;
        } else {
          return current_granularity[0];
        }
      });
    },
    [startTimeFromUrl, endTimeFromUrl],
  );
  var match$14 = React.useState(function () {
    return false;
  });
  var setTopChartFetchWithCurrentDependecyChange = match$14[1];
  var topChartFetchWithCurrentDependecyChange = match$14[0];
  var match$15 = React.useState(function () {
    return false;
  });
  var setBottomChartFetchWithCurrentDependecyChange = match$15[1];
  var bottomChartFetchWithCurrentDependecyChange = match$15[0];
  React.useEffect(
    function () {
      var chartType = LogicUtils.getString(
        getChartCompFilters,
        "chartType",
        DynamicChart.chartMapper(
          Core__Option.getOr(chartEntity.chartTypes[0], "Line"),
        ),
      );
      if (
        LogicUtils.isNonEmptyString(startTimeFromUrl) &&
        LogicUtils.isNonEmptyString(endTimeFromUrl) &&
        Core__Option.isSome(parentToken) &&
        (Core__Option.isSome(granularity) || chartType !== "Line Chart") &&
        current_granularity.includes(Core__Option.getOr(granularity, ""))
      ) {
        setTopChartFetchWithCurrentDependecyChange(function (param) {
          return false;
        });
      }
    },
    [
      parentToken,
      current_granularity.join("-") +
        Core__Option.getOr(granularity, "") +
        cardinalityFromUrl +
        chartTopMetricFromUrl +
        customFilter$1 +
        startTimeFromUrl +
        endTimeFromUrl,
      activeTabStr,
      filterValueFromUrl,
      sortingParams,
    ],
  );
  React.useEffect(
    function () {
      var chartType = LogicUtils.getString(
        getChartCompFilters,
        "chartType",
        DynamicChart.chartMapper(
          Core__Option.getOr(chartEntity.chartTypes[0], "Line"),
        ),
      );
      if (
        LogicUtils.isNonEmptyString(startTimeFromUrl) &&
        LogicUtils.isNonEmptyString(endTimeFromUrl) &&
        Core__Option.isSome(parentToken) &&
        (Core__Option.isSome(granularity) || chartType !== "Line Chart") &&
        current_granularity.includes(Core__Option.getOr(granularity, ""))
      ) {
        setBottomChartFetchWithCurrentDependecyChange(function (param) {
          return false;
        });
      }
    },
    [
      parentToken,
      current_granularity.join("-") +
        Core__Option.getOr(granularity, "") +
        chartBottomMetricFromUrl +
        startTimeFromUrl +
        cardinalityFromUrl +
        customFilter$1 +
        endTimeFromUrl,
      activeTabStr,
      filterValueFromUrl,
      sortingParams,
    ],
  );
  React.useEffect(
    function () {
      if (!topChartFetchWithCurrentDependecyChange && topChartVisible) {
        setTopChartFetchWithCurrentDependecyChange(function (param) {
          return true;
        });
        var value = chartEntity.uriConfig.find(function (item) {
          var metrics = item.metrics[0];
          var metrics$1 = metrics !== undefined ? metrics.metric_label : "";
          return metrics$1 === chartTopMetricFromUrl;
        });
        if (value !== undefined) {
          setTopChartDataLegendData(function (param) {
            return "Loading";
          });
          setTopChartData(function (param) {
            return "Loading";
          });
          var cardinality = cardinalityMapperToNumber(cardinalityFromUrl);
          var timeObj = Object.fromEntries([
            ["start", startTimeFromUrl],
            ["end", endTimeFromUrl],
          ]);
          var metrics = value.metrics[0];
          var match =
            metrics !== undefined
              ? [metrics.metric_name_db, metrics.secondryMetrics]
              : ["", undefined];
          var secondaryMetrics = match[1];
          var metric = match[0];
          var timeCol = value.timeCol;
          var metricsArr =
            secondaryMetrics !== undefined
              ? [secondaryMetrics.metric_name_db, metric]
              : [metric];
          var granularityConfig = getGranularityMapper(
            Core__Option.getOr(granularity, ""),
          );
          Promise.all(
            metricsArr.map(function (metric) {
              return Core__Promise.$$catch(
                addLogsAroundFetch(
                  undefined,
                  "Chart fetch",
                  fetchApi(
                    value.uri + "?api-type=Chart-timeseries&metrics=" + metric,
                    JSON.stringify(
                      AnalyticsNewUtils.apiBodyMaker(
                        timeObj,
                        metric,
                        activeTab,
                        granularityConfig,
                        cardinality,
                        filterValueFromUrl,
                        customFilter$1,
                        sortingParams,
                        undefined,
                        undefined,
                        undefined,
                        timeCol,
                        Core__Option.getOr(value.domain, ""),
                        undefined,
                        undefined,
                      ),
                    ),
                    undefined,
                    Object.fromEntries([["QueryType", "Chart Time Series"]]),
                    "Post",
                    betaEndPointConfig,
                    undefined,
                    undefined,
                  ),
                ).then(function (text) {
                  var jsonObj =
                    LogicUtils.convertNewLineSaperatedDataToArrayOfJson(
                      text,
                    ).map(function (item) {
                      return Object.fromEntries(
                        Object.entries(
                          LogicUtils.getDictFromJsonObject(item),
                        ).map(function (dictEn) {
                          var key = dictEn[0];
                          return [
                            key === timeCol + "_time" ? "time" : key,
                            dictEn[1],
                          ];
                        }),
                      );
                    });
                  return Promise.resolve(jsonTransFormer(metric, jsonObj));
                }),
                function (_err) {
                  return Promise.resolve(null);
                },
              );
            }),
          ).then(function (metricsArr) {
            return Promise.resolve(
              setTopChartData(function (param) {
                return {
                  TAG: "Loaded",
                  _0: LogicUtils.dataMerge(
                    metricsArr.map(function (item) {
                      return LogicUtils.getArrayFromJson(item, []);
                    }),
                    Core__Option.getOr(activeTab, []).concat(["time"]),
                  ),
                };
              }),
            );
          });
          Core__Promise.$$catch(
            addLogsAroundFetch(
              undefined,
              "Chart legend Data",
              fetchApi(
                value.uri + "?api-type=Chart-legend&metrics=" + metric,
                JSON.stringify(
                  AnalyticsNewUtils.apiBodyMaker(
                    timeObj,
                    metric,
                    activeTab,
                    undefined,
                    cardinality,
                    filterValueFromUrl,
                    customFilter$1,
                    sortingParams,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    Core__Option.getOr(value.domain, ""),
                    undefined,
                    undefined,
                  ),
                ),
                undefined,
                Object.fromEntries([["QueryType", "Chart Legend"]]),
                "Post",
                betaEndPointConfig,
                undefined,
                undefined,
              ),
            ).then(function (text) {
              var jsonObj =
                LogicUtils.convertNewLineSaperatedDataToArrayOfJson(text);
              return Promise.resolve(
                setTopChartDataLegendData(function (param) {
                  return {
                    TAG: "Loaded",
                    _0: jsonObj,
                  };
                }),
              );
            }),
            function (_err) {
              return Promise.resolve(
                setTopChartDataLegendData(function (param) {
                  return "LoadedError";
                }),
              );
            },
          );
        }
      }
    },
    [topChartFetchWithCurrentDependecyChange, topChartVisible],
  );
  React.useEffect(
    function () {
      if (!bottomChartFetchWithCurrentDependecyChange && bottomChartVisible) {
        setBottomChartFetchWithCurrentDependecyChange(function (param) {
          return true;
        });
        var value = chartEntity.uriConfig.find(function (item) {
          var metrics = item.metrics[0];
          var metrics$1 = metrics !== undefined ? metrics.metric_label : "";
          return metrics$1 === chartBottomMetricFromUrl;
        });
        if (value !== undefined) {
          setBottomChartDataLegendData(function (param) {
            return "Loading";
          });
          setBottomChartData(function (param) {
            return "Loading";
          });
          var cardinality = cardinalityMapperToNumber(cardinalityFromUrl);
          var timeObj = Object.fromEntries([
            ["start", startTimeFromUrl],
            ["end", endTimeFromUrl],
          ]);
          var metrics = value.metrics[0];
          var match =
            metrics !== undefined
              ? [metrics.metric_name_db, metrics.secondryMetrics]
              : ["", undefined];
          var secondaryMetrics = match[1];
          var metric = match[0];
          var metricsArr =
            secondaryMetrics !== undefined
              ? [secondaryMetrics.metric_name_db, metric]
              : [metric];
          var timeCol = value.timeCol;
          var granularityConfig = getGranularityMapper(
            Core__Option.getOr(granularity, ""),
          );
          Promise.all(
            metricsArr.map(function (metric) {
              return Core__Promise.$$catch(
                addLogsAroundFetch(
                  undefined,
                  "Chart fetch bottomChart",
                  fetchApi(
                    value.uri + "?api-type=Chart-timeseries&metrics=" + metric,
                    JSON.stringify(
                      AnalyticsNewUtils.apiBodyMaker(
                        timeObj,
                        metric,
                        activeTab,
                        granularityConfig,
                        cardinality,
                        filterValueFromUrl,
                        customFilter$1,
                        sortingParams,
                        undefined,
                        undefined,
                        undefined,
                        value.timeCol,
                        Core__Option.getOr(value.domain, ""),
                        undefined,
                        undefined,
                      ),
                    ),
                    undefined,
                    Object.fromEntries([["QueryType", "Chart Time Series"]]),
                    "Post",
                    betaEndPointConfig,
                    undefined,
                    undefined,
                  ),
                ).then(function (text) {
                  var jsonObj =
                    LogicUtils.convertNewLineSaperatedDataToArrayOfJson(
                      text,
                    ).map(function (item) {
                      return Object.fromEntries(
                        Object.entries(
                          LogicUtils.getDictFromJsonObject(item),
                        ).map(function (dictEn) {
                          var key = dictEn[0];
                          return [
                            key === timeCol + "_time" ? "time" : key,
                            dictEn[1],
                          ];
                        }),
                      );
                    });
                  return Promise.resolve(jsonTransFormer(metric, jsonObj));
                }),
                function (_err) {
                  return Promise.resolve(null);
                },
              );
            }),
          ).then(function (metricsArr) {
            var data = LogicUtils.dataMerge(
              metricsArr.map(function (item) {
                return LogicUtils.getArrayFromJson(item, []);
              }),
              Core__Option.getOr(activeTab, []).concat(["time"]),
            );
            return Promise.resolve(
              setBottomChartData(function (param) {
                return {
                  TAG: "Loaded",
                  _0: data,
                };
              }),
            );
          });
          Core__Promise.$$catch(
            addLogsAroundFetch(
              undefined,
              "Chart legend Data",
              fetchApi(
                value.uri + "?api-type=Chart-legend&metrics=" + metric,
                JSON.stringify(
                  AnalyticsNewUtils.apiBodyMaker(
                    timeObj,
                    metric,
                    activeTab,
                    undefined,
                    cardinality,
                    filterValueFromUrl,
                    customFilter$1,
                    sortingParams,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    Core__Option.getOr(value.domain, ""),
                    undefined,
                    undefined,
                  ),
                ),
                undefined,
                Object.fromEntries([["QueryType", "Chart Legend"]]),
                "Post",
                betaEndPointConfig,
                undefined,
                undefined,
              ),
            ).then(function (text) {
              var jsonObj =
                LogicUtils.convertNewLineSaperatedDataToArrayOfJson(text);
              return Promise.resolve(
                setBottomChartDataLegendData(function (param) {
                  return {
                    TAG: "Loaded",
                    _0: jsonObj,
                  };
                }),
              );
            }),
            function (_err) {
              return Promise.resolve(
                setBottomChartDataLegendData(function (param) {
                  return "LoadedError";
                }),
              );
            },
          );
        }
      }
    },
    [bottomChartFetchWithCurrentDependecyChange, bottomChartVisible],
  );
  var chartData = React.useMemo(
    function () {
      return [
        topChartData,
        topChartDataLegendData,
        bottomChartData,
        bottomChartDataLegendData,
      ];
    },
    [
      topChartData,
      topChartDataLegendData,
      bottomChartData,
      bottomChartDataLegendData,
    ],
  );
  var value = React.useMemo(
    function () {
      return {
        topChartData: chartData[0],
        bottomChartData: chartData[2],
        topChartLegendData: chartData[1],
        bottomChartLegendData: chartData[3],
        setTopChartVisible: setTopChartVisible,
        setBottomChartVisible: setBottomChartVisible,
        setGranularity: setGranularity,
        granularity: granularity,
      };
    },
    [
      chartData,
      setTopChartVisible,
      setBottomChartVisible,
      setGranularity,
      granularity,
    ],
  );
  return React.createElement(make, {
    value: value,
    children: props.children,
  });
}

function ChartContext$SDKAnalyticsChartContext(props) {
  var segmentValue = props.segmentValue;
  var dataMergerAndTransformer = props.dataMergerAndTransformer;
  var defaultFilter = props.defaultFilter;
  var __chartId = props.chartId;
  var filterMapper = props.filterMapper;
  var selectedTrends = props.selectedTrends;
  var chartEntity = props.chartEntity;
  var chartId = __chartId !== undefined ? __chartId : "";
  var parentToken = AuthWrapperUtils.useTokenParent("Original");
  var addLogsAroundFetch = AnalyticsLogUtilsHook.useAddLogsAroundFetchNew();
  var betaEndPointConfig = React.useContext(
    BetaEndPointConfigProvider.betaEndPointConfig,
  );
  var fetchApi = AuthHooks.useApiFetcher();
  var jsonTransformer = chartEntity.jsonTransformer;
  var jsonTransFormer =
    jsonTransformer !== undefined
      ? jsonTransformer
      : function (_val, arr) {
          return arr;
        };
  var match = React.useState(function () {
    return "Loading";
  });
  var setTopChartData = match[1];
  var topChartData = match[0];
  var match$1 = React.useState(function () {
    return false;
  });
  var setTopChartVisible = match$1[1];
  var topChartVisible = match$1[0];
  var match$2 = React.useState(function () {
    return false;
  });
  var setBottomChartVisible = match$2[1];
  var match$3 = React.useState(function () {
    return "Loading";
  });
  var setTopChartDataLegendData = match$3[1];
  var topChartDataLegendData = match$3[0];
  var match$4 = React.useContext(FilterContext.filterContext);
  var match$5 = chartEntity.currentMetrics;
  var match$6 = chartEntity.dateFilterKeys;
  var endTimeFilterKey = match$6[1];
  var startTimeFilterKey = match$6[0];
  var defaultFilters = [startTimeFilterKey, endTimeFilterKey];
  var allFilterKeys = defaultFilters.concat(chartEntity.allFilterDimension);
  var customFilterKey = chartEntity.customFilterKey;
  var customFilterKey$1 = customFilterKey !== undefined ? customFilterKey : "";
  var getAllFilter = Object.fromEntries(
    Object.entries(match$4.filterValue).map(function (item) {
      return [item[0], UrlFetchUtils.getFilterValue(item[1])];
    }),
  );
  var getTopLevelChartFilter = React.useMemo(
    function () {
      return Object.fromEntries(
        Belt_Array.keepMap(Object.entries(getAllFilter), function (item) {
          var keyArr = item[0].split(".");
          var prefix = Core__Option.getOr(keyArr[0], "");
          if (prefix === chartId && LogicUtils.isNonEmptyString(prefix)) {
            return;
          } else {
            return [prefix, item[1]];
          }
        }),
      );
    },
    [getAllFilter],
  );
  var match$7 = React.useMemo(
    function () {
      var filterSearchParam = Belt_Array.keepMap(
        Object.entries(getTopLevelChartFilter),
        function (entry) {
          var key = entry[0];
          if (!allFilterKeys.includes(key)) {
            return;
          }
          var str = Core__JSON.Classify.classify(entry[1]);
          if (typeof str !== "object") {
            return;
          }
          switch (str.TAG) {
            case "String":
              return key + "=" + str._0;
            case "Number":
              return key + "=" + String(str._0);
            case "Array":
              return key + "=[" + String(str._0) + "]";
            default:
              return;
          }
        },
      ).join("&");
      return [
        filterSearchParam,
        LogicUtils.getString(getTopLevelChartFilter, customFilterKey$1, ""),
      ];
    },
    [getTopLevelChartFilter],
  );
  var customFilter = match$7[1];
  var customFilter$1 =
    defaultFilter !== undefined
      ? LogicUtils.isEmptyString(customFilter)
        ? defaultFilter
        : defaultFilter + " and " + customFilter
      : customFilter;
  var getChartCompFilters = React.useMemo(
    function () {
      return Object.fromEntries(
        Belt_Array.keepMap(Object.entries(getAllFilter), function (item) {
          var value = item[1];
          var keyArr = item[0].split(".");
          var prefix = Core__Option.getOr(keyArr[0], "");
          var fitlerName = Core__Option.getOr(keyArr[1], "");
          if (LogicUtils.isEmptyString(chartId)) {
            return [prefix, value];
          } else if (
            prefix === chartId &&
            LogicUtils.isNonEmptyString(fitlerName)
          ) {
            return [fitlerName, value];
          } else {
            return;
          }
        }),
      );
    },
    [getAllFilter],
  );
  var match$8 = React.useMemo(
    function () {
      var startTimeFromUrl = LogicUtils.getString(
        getTopLevelChartFilter,
        startTimeFilterKey,
        "",
      );
      var endTimeFromUrl = LogicUtils.getString(
        getTopLevelChartFilter,
        endTimeFilterKey,
        "",
      );
      var filterValueFromUrl = LogicUtils.getJsonFromArrayOfJson(
        Belt_Array.keepMap(
          Object.entries(getTopLevelChartFilter),
          function (entries) {
            var key = entries[0];
            if (chartEntity.allFilterDimension.includes(key)) {
              return [key, entries[1]];
            }
          },
        ),
      );
      return [startTimeFromUrl, endTimeFromUrl, filterValueFromUrl];
    },
    [match$7[0]],
  );
  var filterValueFromUrl = match$8[2];
  var endTimeFromUrl = match$8[1];
  var startTimeFromUrl = match$8[0];
  var currentTimeRanges = {
    fromTime: startTimeFromUrl,
    toTime: endTimeFromUrl,
  };
  var differentTimeValues = [currentTimeRanges].concat(
    Core__Option.getOr(props.differentTimeValues, []),
  );
  var cardinalityFromUrl = LogicUtils.getString(
    getChartCompFilters,
    "cardinality",
    "TOP_5",
  );
  LogicUtils.getString(getChartCompFilters, "chartTopMetric", match$5[0]);
  LogicUtils.getString(getChartCompFilters, "chartBottomMetric", match$5[1]);
  var match$9 = React.useState(function () {});
  var setGranularity = match$9[1];
  var granularity = match$9[0];
  var current_granularity =
    LogicUtils.isNonEmptyString(startTimeFromUrl) &&
    LogicUtils.isNonEmptyString(endTimeFromUrl)
      ? LineChartUtils.getGranularityNewStr(startTimeFromUrl, endTimeFromUrl)
      : [];
  React.useEffect(
    function () {
      setGranularity(function (prev) {
        if (current_granularity.includes(Core__Option.getOr(prev, ""))) {
          return prev;
        } else {
          return current_granularity[0];
        }
      });
    },
    [startTimeFromUrl, endTimeFromUrl],
  );
  var match$10 = React.useState(function () {
    return false;
  });
  var setTopChartFetchWithCurrentDependecyChange = match$10[1];
  var topChartFetchWithCurrentDependecyChange = match$10[0];
  React.useEffect(
    function () {
      var chartType = LogicUtils.getString(
        getChartCompFilters,
        "chartType",
        DynamicChart.chartMapper(
          Core__Option.getOr(chartEntity.chartTypes[0], "Line"),
        ),
      );
      if (
        LogicUtils.isNonEmptyString(startTimeFromUrl) &&
        LogicUtils.isNonEmptyString(endTimeFromUrl) &&
        Core__Option.isSome(parentToken) &&
        (Core__Option.isSome(granularity) || chartType !== "Line Chart") &&
        current_granularity.includes(Core__Option.getOr(granularity, ""))
      ) {
        setTopChartFetchWithCurrentDependecyChange(function (param) {
          return false;
        });
      }
    },
    [
      parentToken,
      current_granularity.join("-") +
        Core__Option.getOr(granularity, "") +
        cardinalityFromUrl +
        selectedTrends.join(",") +
        customFilter$1 +
        startTimeFromUrl +
        Core__Option.getOr(segmentValue, []).join(",") +
        endTimeFromUrl,
      filterValueFromUrl,
      differentTimeValues
        .map(function (item) {
          return item.fromTime + item.toTime;
        })
        .join(","),
    ],
  );
  React.useEffect(
    function () {
      if (!topChartFetchWithCurrentDependecyChange && topChartVisible) {
        setTopChartFetchWithCurrentDependecyChange(function (param) {
          return true;
        });
        var value = chartEntity.uriConfig.find(function (item) {
          var metrics = item.metrics[0];
          var metrics$1 = metrics !== undefined ? metrics.metric_name_db : "";
          return metrics$1 === "total_volume";
        });
        if (value !== undefined) {
          var timeCol = value.timeCol;
          setTopChartDataLegendData(function (param) {
            return "Loading";
          });
          setTopChartData(function (param) {
            return "Loading";
          });
          var cardinality = cardinalityMapperToNumber(cardinalityFromUrl);
          var metrics = value.metrics[0];
          var metric = metrics !== undefined ? metrics.metric_name_db : "";
          var granularityConfig = getGranularityMapper(
            Core__Option.getOr(granularity, ""),
          );
          var timeObjOrig = differentTimeValues[0];
          if (timeObjOrig !== undefined) {
            var timeObj = Object.fromEntries([
              ["start", timeObjOrig.fromTime],
              ["end", timeObjOrig.toTime],
            ]);
            Core__Promise.$$catch(
              addLogsAroundFetch(
                undefined,
                "Chart fetch",
                fetchApi(
                  value.uri +
                    "?api-type=Chart-timeseries&metrics=" +
                    metric +
                    "&top5",
                  JSON.stringify(
                    AnalyticsNewUtils.apiBodyMaker(
                      timeObj,
                      metric,
                      segmentValue,
                      undefined,
                      cardinality,
                      filterValueFromUrl,
                      customFilter$1,
                      undefined,
                      undefined,
                      undefined,
                      undefined,
                      timeCol,
                      Core__Option.getOr(value.domain, ""),
                      undefined,
                      undefined,
                    ),
                  ),
                  undefined,
                  Object.fromEntries([["QueryType", "Chart Time Series"]]),
                  "Post",
                  betaEndPointConfig,
                  undefined,
                  undefined,
                ),
              ).then(function (text) {
                var groupedArr =
                  LogicUtils.convertNewLineSaperatedDataToArrayOfJson(text).map(
                    function (item) {
                      return Belt_Array.keepMap(
                        Object.entries(LogicUtils.getDictFromJsonObject(item)),
                        function (dictOrigItem) {
                          if (
                            Core__Option.getOr(segmentValue, []).includes(
                              dictOrigItem[0],
                            )
                          ) {
                            return Core__Option.getOr(
                              Core__JSON.Decode.string(dictOrigItem[1]),
                              "",
                            );
                          }
                        },
                      ).join("-dimension-");
                    },
                  );
                Promise.all(
                  selectedTrends.map(function (item) {
                    return Core__Promise.$$catch(
                      addLogsAroundFetch(
                        undefined,
                        "Chart fetch",
                        fetchApi(
                          value.uri +
                            "?api-type=Chart-timeseries&metrics=" +
                            metric +
                            "&trend=" +
                            item,
                          JSON.stringify(
                            AnalyticsNewUtils.apiBodyMaker(
                              timeObj,
                              metric,
                              segmentValue,
                              granularityConfig,
                              undefined,
                              filterValueFromUrl,
                              customFilter$1,
                              undefined,
                              filterMapper(item),
                              undefined,
                              undefined,
                              timeCol,
                              Core__Option.getOr(value.domain, ""),
                              undefined,
                              undefined,
                            ),
                          ),
                          undefined,
                          Object.fromEntries([
                            ["QueryType", "Chart Time Series"],
                          ]),
                          "Post",
                          betaEndPointConfig,
                          undefined,
                          undefined,
                        ),
                      ).then(function (text) {
                        return Promise.resolve([
                          item,
                          timeObjOrig.fromTime + " to " + timeObjOrig.toTime,
                          jsonTransFormer(
                            metric,
                            Belt_Array.keepMap(
                              LogicUtils.convertNewLineSaperatedDataToArrayOfJson(
                                text,
                              ),
                              function (item) {
                                var origDictArr = Belt_Array.keepMap(
                                  Object.entries(
                                    LogicUtils.getDictFromJsonObject(item),
                                  ),
                                  function (origDictArrItem) {
                                    if (
                                      Core__Option.getOr(
                                        segmentValue,
                                        [],
                                      ).includes(origDictArrItem[0])
                                    ) {
                                      return Core__Option.getOr(
                                        Core__JSON.Decode.string(
                                          origDictArrItem[1],
                                        ),
                                        "",
                                      );
                                    }
                                  },
                                ).join("-dimension-");
                                if (groupedArr.includes(origDictArr)) {
                                  return Object.fromEntries(
                                    Object.entries(
                                      LogicUtils.getDictFromJsonObject(item),
                                    ).map(function (dictEn) {
                                      var key = dictEn[0];
                                      return [
                                        key === timeCol + "_time"
                                          ? "time"
                                          : key,
                                        dictEn[1],
                                      ];
                                    }),
                                  );
                                }
                              },
                            ),
                          ),
                        ]);
                      }),
                      function (_err) {
                        return Promise.resolve([item, "", []]);
                      },
                    );
                  }),
                ).then(function (dataArr) {
                  setTopChartData(function (param) {
                    return {
                      TAG: "Loaded",
                      _0: dataMergerAndTransformer(
                        selectedTrends,
                        dataArr,
                        segmentValue,
                        startTimeFromUrl,
                        endTimeFromUrl,
                        granularityConfig,
                        undefined,
                      ),
                    };
                  });
                });
                return Promise.resolve();
              }),
              function (_err) {
                return Promise.resolve();
              },
            );
          }
        }
      }
    },
    [topChartFetchWithCurrentDependecyChange, topChartVisible],
  );
  var chartData = React.useMemo(
    function () {
      return [topChartData, topChartDataLegendData, "Loading", "Loading"];
    },
    [topChartData, topChartDataLegendData, "Loading", "Loading"],
  );
  var value = React.useMemo(
    function () {
      return {
        topChartData: chartData[0],
        bottomChartData: chartData[2],
        topChartLegendData: chartData[1],
        bottomChartLegendData: chartData[3],
        setTopChartVisible: setTopChartVisible,
        setBottomChartVisible: setBottomChartVisible,
        setGranularity: setGranularity,
        granularity: granularity,
      };
    },
    [
      chartData,
      setTopChartVisible,
      setBottomChartVisible,
      setGranularity,
      granularity,
    ],
  );
  return React.createElement(make, {
    value: value,
    children: props.children,
  });
}

var SDKAnalyticsChartContext = {
  make: ChartContext$SDKAnalyticsChartContext,
};

var make$1 = ChartContext;

export {
  chartComponentDefVal,
  cardinalityMapperToNumber,
  getGranularityMapper,
  chartContext,
  Provider,
  make$1 as make,
  SDKAnalyticsChartContext,
};
/* chartContext Not a pure module */
