// Generated by ReScript, PLEASE EDIT WITH CARE

import Dayjs from "dayjs";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Core__Int from "@rescript/core/src/Core__Int.bs.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as Core__List from "@rescript/core/src/Core__List.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.js";
import * as Core__Float from "@rescript/core/src/Core__Float.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";

function isEmptyString(str) {
  return str.length === 0;
}

function isNonEmptyString(str) {
  return str.length > 0;
}

function methodStr(method) {
  if (typeof method === "object") {
    return "";
  }
  switch (method) {
    case "Get":
      return "GET";
    case "Head":
      return "HEAD";
    case "Post":
      return "POST";
    case "Put":
      return "PUT";
    case "Delete":
      return "DELETE";
    case "Connect":
      return "CONNECT";
    case "Options":
      return "OPTIONS";
    case "Trace":
      return "TRACE";
    case "Patch":
      return "PATCH";
  }
}

function useUrlPrefix() {
  return "";
}

function stripV4(path) {
  if (path && path.hd === "v4") {
    return path.tl;
  } else {
    return path;
  }
}

function safeParseOpt(st) {
  try {
    return JSON.parse(st);
  } catch (exn) {
    return;
  }
}

function safeParse(st) {
  return Core__Option.getOr(safeParseOpt(st), null);
}

function getDictFromJsonObject(json) {
  var dict = Core__JSON.Decode.object(json);
  if (dict !== undefined) {
    return dict;
  } else {
    return {};
  }
}

function convertMapObjectToDict(genericTypeMapVal) {
  try {
    var map = new Map(genericTypeMapVal);
    var mapIterator = map.entries();
    return getDictFromJsonObject(Object.fromEntries(mapIterator));
  } catch (exn) {
    return {};
  }
}

function removeDuplicate(arr) {
  return arr.filter(function (item, i) {
    return arr.indexOf(item) === i;
  });
}

function sortBasedOnPriority(sortArr, priorityArr) {
  var finalPriorityArr = priorityArr.filter(function (val) {
    return sortArr.includes(val);
  });
  var filteredArr = sortArr.filter(function (item) {
    return !finalPriorityArr.includes(item);
  });
  return finalPriorityArr.concat(filteredArr);
}

function toCamelCase(str) {
  var strArr = str.replace(/[-_]+/g, " ").split(" ");
  return strArr
    .map(function (item, i) {
      var matchFn = function (
        match,
        param,
        param$1,
        param$2,
        param$3,
        param$4,
      ) {
        if (i === 0) {
          return match.toLocaleLowerCase();
        } else {
          return match.toLocaleUpperCase();
        }
      };
      return item.replace(/(?:^\w|[A-Z]|\b\w)/g, matchFn);
    })
    .join("");
}

function getNameFromEmail(email) {
  return Core__Option.getOr(email.split("@")[0], "")
    .split(".")
    .map(function (name) {
      if (name.length === 0) {
        return name;
      } else {
        return Core__Option.getOr(name[0], "").toUpperCase() + name.slice(1);
      }
    })
    .join(" ");
}

function getOptionString(dict, key) {
  return Core__Option.flatMap(dict[key], function (obj) {
    return Core__JSON.Decode.string(obj);
  });
}

function getString(dict, key, $$default) {
  return Core__Option.getOr(getOptionString(dict, key), $$default);
}

function getStringFromJson(json, $$default) {
  return Core__Option.getOr(Core__JSON.Decode.string(json), $$default);
}

function getBoolFromJson(json, defaultValue) {
  return Core__Option.getOr(Core__JSON.Decode.bool(json), defaultValue);
}

function getArrayFromJson(json, $$default) {
  return Core__Option.getOr(Core__JSON.Decode.array(json), $$default);
}

function getOptionalArrayFromDict(dict, key) {
  return Core__Option.flatMap(dict[key], function (obj) {
    return Core__JSON.Decode.array(obj);
  });
}

function getArrayFromDict(dict, key, $$default) {
  return Core__Option.getOr(getOptionalArrayFromDict(dict, key), $$default);
}

function getArrayDataFromJson(json, itemToObjMapper) {
  return Belt_Array.keepMap(
    Core__Option.getOr(Core__JSON.Decode.array(json), []),
    Core__JSON.Decode.object,
  ).map(itemToObjMapper);
}

function getStrArray(dict, key) {
  return Core__Option.getOr(getOptionalArrayFromDict(dict, key), []).map(
    function (json) {
      return Core__Option.getOr(Core__JSON.Decode.string(json), "");
    },
  );
}

function getStrArrayFromJsonArray(jsonArr) {
  return Belt_Array.keepMap(jsonArr, Core__JSON.Decode.string);
}

function getStrArryFromJson(arr) {
  return Core__Option.getOr(
    Core__Option.map(Core__JSON.Decode.array(arr), getStrArrayFromJsonArray),
    [],
  );
}

function getOptionStrArrayFromJson(json) {
  return Core__Option.map(
    Core__JSON.Decode.array(json),
    getStrArrayFromJsonArray,
  );
}

function getStrArrayFromDict(dict, key, $$default) {
  return Core__Option.getOr(
    Core__Option.flatMap(dict[key], function (val) {
      return getOptionStrArrayFromJson(val);
    }),
    $$default,
  );
}

function getOptionStrArrayFromDict(dict, key) {
  return Core__Option.flatMap(dict[key], function (val) {
    return getOptionStrArrayFromJson(val);
  });
}

function getNonEmptyString(str) {
  if (str.length === 0) {
    return;
  } else {
    return str;
  }
}

function getNonEmptyArray(arr) {
  if (arr.length === 0) {
    return;
  } else {
    return arr;
  }
}

function getOptionBool(dict, key) {
  return Core__Option.flatMap(dict[key], function (obj) {
    return Core__JSON.Decode.bool(obj);
  });
}

function getBool(dict, key, $$default) {
  return Core__Option.getOr(getOptionBool(dict, key), $$default);
}

function getJsonObjectFromDict(dict, key) {
  return Core__Option.getOr(dict[key], {});
}

function getBoolFromString(boolString, $$default) {
  var match = boolString.toLowerCase();
  switch (match) {
    case "false":
      return false;
    case "true":
      return true;
    default:
      return $$default;
  }
}

function getStringFromBool(boolValue) {
  if (boolValue) {
    return "true";
  } else {
    return "false";
  }
}

function getOptionIntFromString(str) {
  return Core__Int.fromString(undefined, str);
}

function getOptionFloatFromString(str) {
  return Core__Float.fromString(str);
}

function getFloatFromString(str, $$default) {
  var floatVal = Core__Float.fromString(str);
  if (floatVal !== undefined) {
    return floatVal;
  } else {
    return $$default;
  }
}

function getIntFromJson(json, $$default) {
  var str = Core__JSON.Classify.classify(json);
  if (typeof str !== "object") {
    return $$default;
  }
  switch (str.TAG) {
    case "String":
      var str$1 = str._0;
      var $$int = Core__Int.fromString(undefined, str$1);
      if ($$int !== undefined) {
        return $$int;
      } else {
        return $$default;
      }
    case "Number":
      return str._0 | 0;
    default:
      return $$default;
  }
}

function getOptionIntFromJson(json) {
  var str = Core__JSON.Classify.classify(json);
  if (typeof str !== "object") {
    return;
  }
  switch (str.TAG) {
    case "String":
      return Core__Int.fromString(undefined, str._0);
    case "Number":
      return str._0 | 0;
    default:
      return;
  }
}

function getOptionFloatFromJson(json) {
  var str = Core__JSON.Classify.classify(json);
  if (typeof str !== "object") {
    return;
  }
  switch (str.TAG) {
    case "String":
      return Core__Float.fromString(str._0);
    case "Number":
      return str._0;
    default:
      return;
  }
}

function getFloatFromJson(json, $$default) {
  var str = Core__JSON.Classify.classify(json);
  if (typeof str !== "object") {
    return $$default;
  }
  switch (str.TAG) {
    case "String":
      return getFloatFromString(str._0, $$default);
    case "Number":
      return str._0;
    default:
      return $$default;
  }
}

function getInt(dict, key, $$default) {
  var value = dict[key];
  if (value !== undefined) {
    return getIntFromJson(Caml_option.valFromOption(value), $$default);
  } else {
    return $$default;
  }
}

function getOptionInt(dict, key) {
  var value = dict[key];
  if (value !== undefined) {
    return getOptionIntFromJson(Caml_option.valFromOption(value));
  }
}

function getOptionFloat(dict, key) {
  var value = dict[key];
  if (value !== undefined) {
    return getOptionFloatFromJson(Caml_option.valFromOption(value));
  }
}

function getFloat(dict, key, $$default) {
  return Core__Option.getOr(
    Core__Option.map(dict[key], function (json) {
      return getFloatFromJson(json, $$default);
    }),
    $$default,
  );
}

function getObj(dict, key, $$default) {
  return Core__Option.getOr(
    Core__Option.flatMap(dict[key], function (obj) {
      return Core__JSON.Decode.object(obj);
    }),
    $$default,
  );
}

function getDictFromUrlSearchParams(searchParams) {
  return Object.fromEntries(
    Belt_Array.keepMap(
      Belt_Array.keepMap(searchParams.split("&"), getNonEmptyString),
      function (keyVal) {
        var splitArray = keyVal.split("=");
        var match = splitArray[0];
        var match$1 = splitArray[1];
        if (match !== undefined && match$1 !== undefined) {
          return [match, match$1];
        }
      },
    ),
  );
}

function setDictNull(dict, key, optionStr) {
  if (optionStr !== undefined) {
    dict[key] = optionStr;
  } else {
    dict[key] = null;
  }
}

function setOptionString(dict, key, optionStr) {
  Core__Option.mapOr(optionStr, undefined, function (str) {
    dict[key] = str;
  });
}

function setOptionBool(dict, key, optionInt) {
  Core__Option.mapOr(optionInt, undefined, function (bool) {
    dict[key] = bool;
  });
}

function setOptionArray(dict, key, optionArray) {
  Core__Option.mapOr(optionArray, undefined, function (array) {
    dict[key] = array;
  });
}

function setOptionDict(dict, key, optionDictValue) {
  Core__Option.mapOr(optionDictValue, undefined, function (value) {
    dict[key] = value;
  });
}

function capitalizeString(str) {
  return str.charAt(0).toUpperCase() + str.substring(1);
}

function snakeToCamel(str) {
  return str
    .split("_")
    .map(function (x, i) {
      if (i === 0) {
        return x;
      } else {
        return capitalizeString(x);
      }
    })
    .join("");
}

function camelToSnake(str) {
  return capitalizeString(str)
    .replace(/([a-z0-9A-Z])([A-Z])/g, "$1_$2")
    .toLowerCase();
}

function userNameToTitle(str) {
  return str.split(".").map(capitalizeString).join(" ");
}

function camelCaseToTitle(str) {
  return capitalizeString(str).replace(/([a-z0-9A-Z])([A-Z])/g, "$1 $2");
}

function isContainingStringLowercase(text, searchStr) {
  return text.toLowerCase().includes(searchStr.toLowerCase());
}

function snakeToTitle(str) {
  return str
    .split("_")
    .map(function (x) {
      var first = x.charAt(0).toUpperCase();
      var second = x.substring(1);
      return first + second;
    })
    .join(" ");
}

function titleToSnake(str) {
  return str
    .split(" ")
    .map(function (prim) {
      return prim.toLowerCase();
    })
    .join("_");
}

function getIntFromString(str, $$default) {
  return Core__Option.getOr(Core__Int.fromString(undefined, str), $$default);
}

function removeTrailingZero(numeric_str) {
  return Core__Option.getOr(Core__Float.fromString(numeric_str), 0).toString();
}

function shortNum(labelValue, numberFormat, presisionOpt, param) {
  var presision = presisionOpt !== undefined ? presisionOpt : 2;
  var value = Math.abs(labelValue);
  switch (numberFormat) {
    case "IND":
      if (value >= 1.0e7) {
        return removeTrailingZero((value / 1.0e7).toFixed(presision)) + "Cr";
      } else if (value >= 1.0e5) {
        return removeTrailingZero((value / 1.0e5).toFixed(presision)) + "L";
      } else if (value >= 1.0e3) {
        return removeTrailingZero((value / 1.0e3).toFixed(presision)) + "K";
      } else {
        return removeTrailingZero(labelValue.toFixed(presision));
      }
    case "USD":
    case "DefaultConvert":
      break;
  }
  if (value >= 1.0e9) {
    return removeTrailingZero((value / 1.0e9).toFixed(presision)) + "B";
  } else if (value >= 1.0e6) {
    return removeTrailingZero((value / 1.0e6).toFixed(presision)) + "M";
  } else if (value >= 1.0e3) {
    return removeTrailingZero((value / 1.0e3).toFixed(presision)) + "K";
  } else {
    return removeTrailingZero(labelValue.toFixed(presision));
  }
}

function latencyShortNum(labelValue, includeMilliseconds, param) {
  if (labelValue === 0.0) {
    return "0";
  }
  var value = labelValue | 0;
  var value_days = (value / 86400) | 0;
  var years = (value_days / 365) | 0;
  var months = ((value_days % 365) / 30) | 0;
  var days = (value_days % 365) % 30;
  var hours = (value / 3600) | 0;
  var minutes = ((value % 3600) / 60) | 0;
  var seconds = (value % 3600) % 60;
  var year_disp = years >= 1 ? String(years) + "Y " : "";
  var month_disp = months > 0 ? String(months) + "M " : "";
  var day_disp = days > 0 ? String(days) + "D " : "";
  var hr_disp = hours > 0 ? String(hours) + "H " : "";
  var min_disp = minutes > 0 ? String(minutes) + "M " : "";
  var millisec_disp =
    (labelValue < 1.0 ||
      (Core__Option.getOr(includeMilliseconds, false) && labelValue < 60.0)) &&
    labelValue > 0.0
      ? "." + String(((labelValue * 1000.0) | 0) % 1000)
      : "";
  var sec_disp =
    seconds > 0 || millisec_disp.length > 0
      ? String(seconds) + millisec_disp + "S "
      : "";
  if (days > 0) {
    return year_disp + month_disp + day_disp;
  } else {
    return year_disp + month_disp + day_disp + hr_disp + min_disp + sec_disp;
  }
}

function checkEmptyJson(json) {
  return Caml_obj.equal(json, {});
}

function numericArraySortComperator(a, b) {
  if (Caml_obj.lessthan(a, b)) {
    return -1;
  } else if (Caml_obj.greaterthan(a, b)) {
    return 1;
  } else {
    return 0;
  }
}

function isEmptyDict(dict) {
  return Object.keys(dict).length === 0;
}

function stringReplaceAll(str, old, $$new) {
  return str.split(old).join($$new);
}

function getUniqueArray(arr) {
  return Object.keys(
    Object.fromEntries(
      arr.map(function (item) {
        return [item, ""];
      }),
    ),
  );
}

function getFirstLetterCaps(str, splitByOpt, param) {
  var splitBy = splitByOpt !== undefined ? splitByOpt : "-";
  return str.toLowerCase().split(splitBy).map(capitalizeString).join(" ");
}

function getDictfromDict(dict, key) {
  return getDictFromJsonObject(getJsonObjectFromDict(dict, key));
}

function checkLeapYear(year) {
  if (year % 4 === 0 && year % 100 !== 0) {
    return true;
  } else {
    return year % 400 === 0;
  }
}

function getValueFromArray(arr, index, $$default) {
  return Core__Option.getOr(arr[index], $$default);
}

function isEqualStringArr(arr1, arr2) {
  var arr1$1 = getUniqueArray(arr1);
  var arr2$1 = getUniqueArray(arr2);
  var lengthEqual = arr1$1.length === arr2$1.length;
  var isContainsAll = Core__Array.reduce(arr1$1, true, function (acc, str) {
    if (arr2$1.includes(str)) {
      return acc;
    } else {
      return false;
    }
  });
  if (lengthEqual) {
    return isContainsAll;
  } else {
    return false;
  }
}

function getDefaultNumberFormat() {
  return "USD";
}

function indianShortNum(labelValue) {
  return shortNum(labelValue, "USD", undefined, undefined);
}

function convertNewLineSaperatedDataToArrayOfJson(text) {
  return text
    .split("\n")
    .filter(function (item) {
      return item.length > 0;
    })
    .map(function (item) {
      return safeParse(item);
    });
}

function getObjectArrayFromJson(json) {
  return getArrayFromJson(json, []).map(getDictFromJsonObject);
}

function getListHead(defaultOpt, list) {
  var $$default = defaultOpt !== undefined ? defaultOpt : "";
  return Core__Option.getOr(Core__List.head(list), $$default);
}

function dataMerge(dataArr, dictKey) {
  var finalData = {};
  dataArr.forEach(function (jsonArr) {
    jsonArr.forEach(function (jsonObj) {
      var dict = getDictFromJsonObject(jsonObj);
      var dictKey$1 = dictKey
        .map(function (ele) {
          return getString(dict, ele, "");
        })
        .join("-");
      var existingData = Object.entries(getObj(finalData, dictKey$1, {}));
      var data = Object.entries(dict);
      finalData[dictKey$1] = Object.fromEntries(existingData.concat(data));
    });
  });
  return Object.values(finalData);
}

function getJsonFromStr(data) {
  if (data.length > 0) {
    return JSON.stringify(safeParse(data), null, 2);
  } else {
    return data;
  }
}

function compareLogic(firstValue, secondValue) {
  if (Caml_obj.equal(firstValue, secondValue)) {
    return 0;
  } else if (Caml_obj.greaterthan(firstValue, secondValue)) {
    return -1;
  } else {
    return 1;
  }
}

function getJsonFromArrayOfJson(arr) {
  return Object.fromEntries(arr);
}

function getTitle(name) {
  return name.toLowerCase().split("_").map(capitalizeString).join(" ");
}

function regex(positionToCheckFrom, searchString) {
  var searchStringNew = searchString
    .replace(/[<>\[\]';|?*\\]/g, "")
    .replace(/\(/g, "\\(")
    .replace(/\+/g, "\\+")
    .replace(/\)/g, "\\)");
  return new RegExp(
    "(.*)(" + positionToCheckFrom + searchStringNew + ")(.*)",
    "i",
  );
}

function checkStringStartsWithSubstring(itemToCheck, searchText) {
  var match = itemToCheck.match(regex("\\b", searchText));
  var isMatch =
    match !== null
      ? true
      : Core__Option.isSome(
          Caml_option.null_to_opt(itemToCheck.match(regex("_", searchText))),
        );
  if (isMatch) {
    return searchText.length > 0;
  } else {
    return false;
  }
}

function listOfMatchedText(text, searchText) {
  var r = text.match(regex("\\b", searchText));
  if (r !== null) {
    return Belt_Array.keepMap(r.slice(1), function (x) {
      return x;
    });
  }
  var a = text.match(regex("_", searchText));
  if (a !== null) {
    return Belt_Array.keepMap(a.slice(1), function (x) {
      return x;
    });
  } else {
    return [text];
  }
}

function getJsonFromArrayOfString(arr) {
  return arr.map(function (ele) {
    return ele;
  });
}

function truncateFileNameWithEllipses(fileName, maxTextLength) {
  var lastIndex = fileName.lastIndexOf(".");
  var beforeDotFileName = fileName.substring(0, lastIndex);
  var afterDotFileType = fileName.substring((lastIndex + 1) | 0);
  if (
    ((((beforeDotFileName.length + afterDotFileType.length) | 0) + 1) | 0) <=
    maxTextLength
  ) {
    return fileName;
  }
  var truncatedText = beforeDotFileName.slice(0, maxTextLength).concat("...");
  return truncatedText + "." + afterDotFileType;
}

function getDaysDiffForDates(startDate, endDate) {
  var startDate$1 = new Date(startDate);
  var endDate$1 = new Date(endDate);
  var daysDiff = Math.abs(endDate$1.getTime() - startDate$1.getTime());
  var noOfmiliiseconds = 1000.0 * 60.0 * 60.0 * 24.0;
  return Math.floor(daysDiff / noOfmiliiseconds);
}

function getOptionalFromNullable(val) {
  if (val == null) {
    return;
  } else {
    return Caml_option.some(val);
  }
}

function getValFromNullableValue(val, $$default) {
  return Core__Option.getOr(
    val == null ? undefined : Caml_option.some(val),
    $$default,
  );
}

function dateFormat(timestamp, format) {
  return Dayjs(timestamp).format(format);
}

export {
  isEmptyString,
  isNonEmptyString,
  methodStr,
  useUrlPrefix,
  stripV4,
  safeParseOpt,
  safeParse,
  getDictFromJsonObject,
  convertMapObjectToDict,
  removeDuplicate,
  sortBasedOnPriority,
  toCamelCase,
  getNameFromEmail,
  getOptionString,
  getString,
  getStringFromJson,
  getBoolFromJson,
  getArrayFromJson,
  getOptionalArrayFromDict,
  getArrayFromDict,
  getArrayDataFromJson,
  getStrArray,
  getStrArrayFromJsonArray,
  getStrArryFromJson,
  getOptionStrArrayFromJson,
  getStrArrayFromDict,
  getOptionStrArrayFromDict,
  getNonEmptyString,
  getNonEmptyArray,
  getOptionBool,
  getBool,
  getJsonObjectFromDict,
  getBoolFromString,
  getStringFromBool,
  getOptionIntFromString,
  getOptionFloatFromString,
  getFloatFromString,
  getIntFromJson,
  getOptionIntFromJson,
  getOptionFloatFromJson,
  getFloatFromJson,
  getInt,
  getOptionInt,
  getOptionFloat,
  getFloat,
  getObj,
  getDictFromUrlSearchParams,
  setDictNull,
  setOptionString,
  setOptionBool,
  setOptionArray,
  setOptionDict,
  capitalizeString,
  snakeToCamel,
  camelToSnake,
  userNameToTitle,
  camelCaseToTitle,
  isContainingStringLowercase,
  snakeToTitle,
  titleToSnake,
  getIntFromString,
  removeTrailingZero,
  shortNum,
  latencyShortNum,
  checkEmptyJson,
  numericArraySortComperator,
  isEmptyDict,
  stringReplaceAll,
  getUniqueArray,
  getFirstLetterCaps,
  getDictfromDict,
  checkLeapYear,
  getValueFromArray,
  isEqualStringArr,
  getDefaultNumberFormat,
  indianShortNum,
  convertNewLineSaperatedDataToArrayOfJson,
  getObjectArrayFromJson,
  getListHead,
  dataMerge,
  getJsonFromStr,
  compareLogic,
  getJsonFromArrayOfJson,
  getTitle,
  regex,
  checkStringStartsWithSubstring,
  listOfMatchedText,
  getJsonFromArrayOfString,
  truncateFileNameWithEllipses,
  getDaysDiffForDates,
  getOptionalFromNullable,
  getValFromNullableValue,
  dateFormat,
};
/* dayjs Not a pure module */
