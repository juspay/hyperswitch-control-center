// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "./LogicUtils.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as JsonFlattenUtils from "./JsonFlattenUtils.bs.js";

function deleteKey(dictionary, key) {
  return Object.fromEntries(
    Belt_Array.keepMap(Object.entries(dictionary), function (entry) {
      if (key !== entry[0]) {
        return entry;
      }
    }),
  );
}

function deleteKeys(dictionary, keys) {
  return Object.fromEntries(
    Belt_Array.keepMap(Object.entries(dictionary), function (entry) {
      if (keys.includes(entry[0])) {
        return;
      } else {
        return entry;
      }
    }),
  );
}

function mergeDicts(arrDict) {
  return Object.fromEntries(
    Core__Array.reduce(arrDict, [], function (acc, dict) {
      return acc.concat(Object.entries(dict));
    }),
  );
}

function equalDicts(dictionary1, dictionary2) {
  if (
    Core__Option.isNone(
      Object.entries(dictionary1).find(function (item) {
        return dictionary2[item[0]] !== Caml_option.some(item[1]);
      }),
    )
  ) {
    return Core__Option.isNone(
      Object.entries(dictionary2).find(function (item) {
        return dictionary1[item[0]] !== Caml_option.some(item[1]);
      }),
    );
  } else {
    return false;
  }
}

function checkEqualJsonDicts(checkKeys, ignoreKeys, dictionary1, dictionary2) {
  var dictionary1$1 = JsonFlattenUtils.flattenObject(dictionary1, false);
  var dictionary2$1 = JsonFlattenUtils.flattenObject(dictionary2, false);
  if (
    Core__Option.isNone(
      Object.entries(dictionary1$1).find(function (item) {
        var key = item[0];
        if (
          !(
            (checkKeys.includes(key) || checkKeys.length === 0) &&
            !ignoreKeys.includes(key)
          )
        ) {
          return false;
        }
        var value = item[1];
        var array = Core__JSON.Classify.classify(value);
        if (typeof array !== "object") {
          return LogicUtils.getJsonObjectFromDict(dictionary2$1, key) !== value;
        }
        switch (array.TAG) {
          case "String":
            return array._0 !== LogicUtils.getString(dictionary2$1, key, "");
          case "Array":
            var arr1 = LogicUtils.getStrArrayFromJsonArray(array._0);
            var arr2 = LogicUtils.getStrArrayFromDict(dictionary2$1, key, []);
            return !LogicUtils.isEqualStringArr(arr1, arr2);
          default:
            return (
              LogicUtils.getJsonObjectFromDict(dictionary2$1, key) !== value
            );
        }
      }),
    )
  ) {
    return Core__Option.isNone(
      Object.entries(dictionary2$1).find(function (item) {
        var key = item[0];
        if (!(checkKeys.includes(key) && !ignoreKeys.includes(key))) {
          return false;
        }
        var value = item[1];
        var array = Core__JSON.Classify.classify(value);
        if (typeof array !== "object") {
          return LogicUtils.getJsonObjectFromDict(dictionary1$1, key) !== value;
        }
        switch (array.TAG) {
          case "String":
            return array._0 !== LogicUtils.getString(dictionary1$1, key, "");
          case "Array":
            var arr1 = LogicUtils.getStrArrayFromJsonArray(array._0);
            var arr2 = LogicUtils.getStrArrayFromDict(dictionary1$1, key, []);
            return !LogicUtils.isEqualStringArr(arr1, arr2);
          default:
            return (
              LogicUtils.getJsonObjectFromDict(dictionary1$1, key) !== value
            );
        }
      }),
    );
  } else {
    return false;
  }
}

function copyOfDict(dict) {
  return Object.fromEntries(Object.entries(dict).slice());
}

export {
  deleteKey,
  deleteKeys,
  mergeDicts,
  equalDicts,
  checkEqualJsonDicts,
  copyOfDict,
};
/* LogicUtils Not a pure module */
