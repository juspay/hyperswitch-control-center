// Generated by ReScript, PLEASE EDIT WITH CARE

import * as FRMInfo from "./FRMInfo.bs.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as ConnectorUtils from "../Connectors/ConnectorUtils.bs.js";
import * as ConnectorListMapper from "../../utils/Mappers/ConnectorListMapper.bs.js";

function leadingSpaceStrParser(value, param) {
  var str = Core__Option.getOr(Core__JSON.Decode.string(value), "");
  return str.replace(/^[\s]+/, "");
}

function base64Parse(value, param) {
  return btoa(Core__Option.getOr(Core__JSON.Decode.string(value), ""));
}

function base64Format(value, param) {
  return atob(Core__Option.getOr(Core__JSON.Decode.string(value), ""));
}

function generateInitialValuesDict(selectedFRMName, isLiveMode, param) {
  var frmAccountDetailsDict = LogicUtils.getJsonFromArrayOfJson([
    ["auth_type", FRMInfo.getFRMAuthType(selectedFRMName)],
  ]);
  return Object.fromEntries([
    ["connector_name", ConnectorUtils.getConnectorNameString(selectedFRMName)],
    ["connector_type", "payment_vas"],
    ["disabled", false],
    ["test_mode", !isLiveMode],
    ["connector_account_details", frmAccountDetailsDict],
    ["frm_configs", []],
  ]);
}

function parseFRMConfig(json) {
  return ConnectorListMapper.convertFRMConfigJsonToObj(
    Core__Option.getOr(Core__JSON.Decode.array(json), []),
  );
}

function getPaymentMethod(paymentMethod) {
  var paymentMethodDict = LogicUtils.getDictFromJsonObject(paymentMethod);
  var paymentMethodTypeArr = LogicUtils.getArrayFromDict(
    paymentMethodDict,
    "payment_method_types",
    [],
  );
  var pmTypesArr = paymentMethodTypeArr.map(function (item) {
    return LogicUtils.getString(
      LogicUtils.getDictFromJsonObject(item),
      "payment_method_type",
      "",
    );
  });
  return [
    LogicUtils.getString(paymentMethodDict, "payment_method", ""),
    LogicUtils.getUniqueArray(pmTypesArr),
  ];
}

function parseConnectorConfig(dict) {
  var pmDict = {};
  var connectorPaymentMethods = LogicUtils.getArrayFromDict(
    dict,
    "payment_methods_enabled",
    [],
  );
  connectorPaymentMethods.forEach(function (item) {
    var match = getPaymentMethod(item);
    pmDict[match[0]] = match[1];
  });
  return [LogicUtils.getString(dict, "connector_name", ""), pmDict];
}

function updatePaymentMethodsDict(
  prevPaymentMethodsDict,
  pmName,
  currentPmTypes,
) {
  var prevPmTypes = prevPaymentMethodsDict[pmName];
  if (prevPmTypes !== undefined) {
    var pmTypesArr = prevPmTypes.concat(currentPmTypes);
    prevPaymentMethodsDict[pmName] = LogicUtils.getUniqueArray(pmTypesArr);
    return;
  }
  prevPaymentMethodsDict[pmName] = currentPmTypes;
}

function updateConfigDict(configDict, connectorName, paymentMethodsDict) {
  var prevPaymentMethodsDict = configDict[connectorName];
  if (prevPaymentMethodsDict !== undefined) {
    Object.keys(paymentMethodsDict).forEach(function (pmName) {
      updatePaymentMethodsDict(
        prevPaymentMethodsDict,
        pmName,
        Core__Option.getOr(paymentMethodsDict[pmName], []),
      );
    });
  } else {
    configDict[connectorName] = paymentMethodsDict;
  }
}

function getConnectorConfig(connectors) {
  var configDict = {};
  connectors.forEach(function (connector) {
    var match = parseConnectorConfig(connector);
    updateConfigDict(configDict, match[0], match[1]);
  });
  return configDict;
}

function filterList(items, removeFromList, param) {
  return items.filter(function (dict) {
    var isConnector =
      LogicUtils.getString(dict, "connector_type", "") !== "payment_vas";
    var isThreedsConnector =
      LogicUtils.getString(dict, "connector_type", "") !==
      "authentication_processor";
    switch (removeFromList) {
      case "Connector":
        return !isConnector;
      case "FRMPlayer":
        return isConnector;
      case "ThreedsAuthenticator":
        return isThreedsConnector;
    }
  });
}

function createAllOptions(connectorsConfig) {
  return Object.keys(connectorsConfig).map(function (connectorName) {
    return {
      gateway: connectorName,
      payment_methods: [],
    };
  });
}

function generateFRMPaymentMethodsConfig(paymentMethodsDict) {
  return Object.keys(paymentMethodsDict).map(function (paymentMethodName) {
    var paymentMethodTypesArr = Core__Option.getOr(
      paymentMethodsDict[paymentMethodName],
      [],
    ).map(function (paymentMethodType) {
      return {
        payment_method_type: paymentMethodType,
        flow: "pre",
        action: "cancel_txn",
      };
    });
    return {
      payment_method: paymentMethodName,
      payment_method_types: paymentMethodTypesArr,
    };
  });
}

function ignoreFields(json) {
  return Object.fromEntries(
    Object.entries(LogicUtils.getDictFromJsonObject(json)).filter(
      function (entry) {
        return !FRMInfo.ignoredField.includes(entry[0]);
      },
    ),
  );
}

var toggleDefaultStyle =
  "mb-2 relative inline-flex flex-shrink-0 h-6 w-12 border-2 rounded-full  transition-colors ease-in-out duration-200 focus:outline-none focus-visible:ring-2  focus-visible:ring-white focus-visible:ring-opacity-75 items-center";

var accordionDefaultStyle =
  "border pointer-events-none inline-block h-3 w-3 rounded-full bg-white dark:bg-white shadow-lg transform ring-0 transition ease-in-out duration-200";

var size = "w-14 h-14 rounded-full";

export {
  leadingSpaceStrParser,
  base64Parse,
  base64Format,
  toggleDefaultStyle,
  accordionDefaultStyle,
  size,
  generateInitialValuesDict,
  parseFRMConfig,
  getPaymentMethod,
  parseConnectorConfig,
  updatePaymentMethodsDict,
  updateConfigDict,
  getConnectorConfig,
  filterList,
  createAllOptions,
  generateFRMPaymentMethodsConfig,
  ignoreFields,
};
/* FRMInfo Not a pure module */
