// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Button from "../../components/Button.bs.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as HSwitchUtils from "../HSwitchUtils.bs.js";
import * as ReactFinalForm from "../../libraries/ReactFinalForm.bs.js";
import * as ReactFinalForm$1 from "react-final-form";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var currentTimeInUTC = new Date(Date.now()).toUTCString();

function getCurrentUTCTime() {
  var currentDate = new Date(Date.now());
  var month = currentDate.getUTCMonth() + 1.0;
  var day = currentDate.getUTCDate();
  var currMonth = month < 10.0 ? "0" + month.toString() : month.toString();
  var currDay = day < 10.0 ? "0" + day.toString() : day.toString();
  var currYear = currentDate.getUTCFullYear().toString();
  return currYear + "-" + currMonth + "-" + currDay;
}

function routingTypeMapper(routingType) {
  switch (routingType) {
    case "advanced":
      return "ADVANCED";
    case "default":
      return "DEFAULTFALLBACK";
    case "priority":
      return "PRIORITY";
    case "volume_split":
      return "VOLUME_SPLIT";
    default:
      return "NO_ROUTING";
  }
}

function routingTypeName(routingType) {
  switch (routingType) {
    case "PRIORITY":
      return "rank";
    case "VOLUME_SPLIT":
      return "volume";
    case "ADVANCED":
      return "rule";
    case "DEFAULTFALLBACK":
      return "default";
    case "NO_ROUTING":
      return "";
  }
}

function getRoutingPayload(data, routingType, name, description, profileId) {
  var connectorsOrder = Object.fromEntries([
    ["data", data],
    ["type", routingType],
  ]);
  return Object.fromEntries([
    ["name", name],
    ["description", description],
    ["profile_id", profileId],
    ["algorithm", connectorsOrder],
  ]);
}

function getModalObj(routingType, text) {
  switch (routingType) {
    case "PRIORITY":
      return {
        conType: "Activate current configured configuration?",
        conText:
          "If you want to activate the " +
          text +
          " configuration, the simple configuration, set previously will be lost. Are you sure you want to activate it?",
      };
    case "VOLUME_SPLIT":
      return {
        conType: "Activate current configured configuration?",
        conText:
          "If you want to activate the " +
          text +
          " configuration, the volume based configuration, set previously will be lost. Are you sure you want to activate it?",
      };
    case "ADVANCED":
      return {
        conType: "Activate current configured configuration?",
        conText:
          "If you want to activate the " +
          text +
          " configuration, the advanced configuration, set previously will be lost. Are you sure you want to activate it?",
      };
    case "DEFAULTFALLBACK":
      return {
        conType: "Save the Current Changes ?",
        conText: "Do you want to save the current changes ?",
      };
    case "NO_ROUTING":
      return {
        conType: "Activate Logic",
        conText: "Are you sure you want to ACTIVATE the logic?",
      };
  }
}

function getContent(routetype) {
  switch (routetype) {
    case "PRIORITY":
      return {
        heading: "Rank Based Configuration",
        subHeading:
          "Fallback is activated when the above routing conditions happen to be false.",
      };
    case "VOLUME_SPLIT":
      return {
        heading: "Volume Based Configuration",
        subHeading:
          "Route traffic across various processors by volume distribution",
      };
    case "ADVANCED":
      return {
        heading: "Rule Based Configuration",
        subHeading:
          "Route traffic across processors with advanced logic rules on the basis of various payment parameters",
      };
    case "DEFAULTFALLBACK":
      return {
        heading: "Default fallback ",
        subHeading:
          "Fallback is a priority order of all the configured processors which is used to route traffic standalone or when other routing rules are not applicable. You can reorder the list with simple drag and drop",
      };
    case "NO_ROUTING":
      return {
        heading: "",
        subHeading: "",
      };
  }
}

function getGatewayTypes(arr) {
  return arr.map(function (value) {
    var val = LogicUtils.getDictFromJsonObject(value);
    var connectorDict = LogicUtils.getDictfromDict(val, "connector");
    return {
      distribution: LogicUtils.getInt(val, "split", 0),
      disableFallback: LogicUtils.getBool(val, "disableFallback", false),
      gateway_name: LogicUtils.getString(
        connectorDict,
        "merchant_connector_id",
        "",
      ),
    };
  });
}

function valueTypeMapper(dict) {
  var match = Core__Option.map(dict["value"], Core__JSON.Classify.classify);
  if (match === undefined) {
    return {
      TAG: "String",
      _0: "",
    };
  }
  if (typeof match !== "object") {
    return {
      TAG: "String",
      _0: "",
    };
  }
  switch (match.TAG) {
    case "String":
      return {
        TAG: "String",
        _0: match._0,
      };
    case "Number":
      return {
        TAG: "Int",
        _0: match._0 | 0,
      };
    case "Array":
      return {
        TAG: "StringArray",
        _0: LogicUtils.getStrArrayFromJsonArray(match._0),
      };
    default:
      return {
        TAG: "String",
        _0: "",
      };
  }
}

function threeDsTypeMapper(dict) {
  var getRoutingOutputval = LogicUtils.getString(
    dict,
    "override_3ds",
    "three_ds",
  );
  return {
    override_3ds: getRoutingOutputval,
  };
}

function constructNameDescription(routingType) {
  var routingText = routingTypeName(routingType);
  return Object.fromEntries([
    [
      "name",
      LogicUtils.capitalizeString(routingText) +
        " Based Routing-" +
        getCurrentUTCTime(),
    ],
    [
      "description",
      "This is a " +
        routingText +
        " based routing created at " +
        currentTimeInUTC,
    ],
  ]);
}

function RoutingUtils$SaveAndActivateButton(props) {
  var handleActivateConfiguration = props.handleActivateConfiguration;
  var onSubmit = props.onSubmit;
  var formState = ReactFinalForm$1.useFormState(
    ReactFinalForm.useFormSubscription(["values"]),
  );
  var handleSaveAndActivate = async function (_ev) {
    try {
      var onSubmitResponse = await onSubmit(formState.values, false);
      var currentActivatedFromJson = LogicUtils.getValFromNullableValue(
        onSubmitResponse,
        null,
      );
      var currentActivatedId = LogicUtils.getString(
        LogicUtils.getDictFromJsonObject(currentActivatedFromJson),
        "id",
        "",
      );
      await handleActivateConfiguration(currentActivatedId);
      return;
    } catch (raw_e) {
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === Js_exn.$$Error) {
        Core__Option.getOr(
          e._1.message,
          "Failed to save and activate configuration!",
        );
        return;
      }
      throw e;
    }
  };
  return React.createElement(Button.make, {
    text: "Save and Activate Rule",
    buttonType: "Primary",
    buttonSize: "Small",
    onClick: function (param) {
      handleSaveAndActivate();
    },
    customButtonStyle: "w-1/5 rounded-sm",
  });
}

var SaveAndActivateButton = {
  make: RoutingUtils$SaveAndActivateButton,
};

function RoutingUtils$ConfigureRuleButton(props) {
  var setShowModal = props.setShowModal;
  var formState = ReactFinalForm$1.useFormState(
    ReactFinalForm.useFormSubscription(["values"]),
  );
  return React.createElement(Button.make, {
    buttonState: formState.hasValidationErrors ? "Disabled" : "Normal",
    text: "Configure Rule",
    buttonType: "Primary",
    onClick: function (param) {
      setShowModal(function (param) {
        return true;
      });
    },
    customButtonStyle: "w-1/5",
  });
}

var ConfigureRuleButton = {
  make: RoutingUtils$ConfigureRuleButton,
};

function checkIfValuePresent(dict) {
  var valueFromObject = LogicUtils.getDictfromDict(dict, "value");
  if (
    LogicUtils.getArrayFromDict(valueFromObject, "value", []).filter(
      function (ele) {
        return Caml_obj.notequal(ele, "");
      },
    ).length > 0 ||
    LogicUtils.isNonEmptyString(
      LogicUtils.getString(valueFromObject, "value", ""),
    ) ||
    LogicUtils.getFloat(valueFromObject, "value", -1.0) !== -1.0
  ) {
    return true;
  } else if (
    LogicUtils.isNonEmptyString(
      LogicUtils.getString(
        LogicUtils.getDictfromDict(valueFromObject, "value"),
        "key",
        "",
      ),
    )
  ) {
    return LogicUtils.isNonEmptyString(
      LogicUtils.getString(
        LogicUtils.getDictfromDict(valueFromObject, "value"),
        "value",
        "",
      ),
    );
  } else {
    return false;
  }
}

function validateConditionJson(json, keys) {
  var dict = Core__JSON.Decode.object(json);
  if (
    dict !== undefined &&
    keys.every(function (key) {
      return Core__Option.isSome(dict[key]);
    })
  ) {
    return checkIfValuePresent(dict);
  } else {
    return false;
  }
}

function validateConditionsFor3ds(dict) {
  var conditionsArray = LogicUtils.getArrayFromDict(dict, "statements", []);
  return conditionsArray.every(function (value) {
    return validateConditionJson(value, ["comparison", "lhs"]);
  });
}

function getRecordsObject(json) {
  var jsonDict = Core__JSON.Classify.classify(json);
  if (typeof jsonDict !== "object") {
    return [];
  }
  switch (jsonDict.TAG) {
    case "Object":
      return LogicUtils.getArrayFromDict(jsonDict._0, "records", []);
    case "Array":
      return jsonDict._0;
    default:
      return [];
  }
}

function filter(connector_type, retainInList) {
  var paymentRegex = /(payout_processor|payment_vas)/gi;
  switch (retainInList) {
    case "PaymentConnector":
      return Core__Option.isNone(
        Caml_option.nullable_to_opt(paymentRegex.exec(connector_type)),
      );
    case "FRMPlayer":
      return connector_type === "payment_vas";
    case "PayoutConnector":
      return connector_type === "payout_processor";
  }
}

function filterConnectorList(items, retainInList) {
  return items.filter(function (connector) {
    return filter(connector.connector_type, retainInList);
  });
}

function filterConnectorListJson(json, retainInList) {
  return LogicUtils.getArrayFromJson(json, [])
    .map(LogicUtils.getDictFromJsonObject)
    .filter(function (dict) {
      return filter(
        LogicUtils.getString(dict, "connector_type", ""),
        retainInList,
      );
    });
}

function filterConnectorListCoreJson(json, retainInList) {
  return json
    .map(LogicUtils.getDictFromJsonObject)
    .filter(function (dict) {
      return filter(
        LogicUtils.getString(dict, "connector_type", ""),
        retainInList,
      );
    })
    .map(function (prim) {
      return prim;
    });
}

function urlToVariantMapper(url) {
  var match = HSwitchUtils.urlPath(url.path);
  if (!match) {
    return "Routing";
  }
  switch (match.hd) {
    case "3ds":
      var match$1 = match.tl;
      if (match$1 && !match$1.tl) {
        return "ThreedsRouting";
      } else {
        return "Routing";
      }
    case "payoutrouting":
      var match$2 = match.tl;
      if (match$2 && !match$2.tl) {
        return "PayoutRouting";
      } else {
        return "Routing";
      }
    case "surcharge":
      var match$3 = match.tl;
      if (match$3 && !match$3.tl) {
        return "SurchargeRouting";
      } else {
        return "Routing";
      }
    default:
      return "Routing";
  }
}

var defaultThreeDsObjectValue = {
  override_3ds: "three_ds",
};

export {
  defaultThreeDsObjectValue,
  currentTimeInUTC,
  getCurrentUTCTime,
  routingTypeMapper,
  routingTypeName,
  getRoutingPayload,
  getModalObj,
  getContent,
  getGatewayTypes,
  valueTypeMapper,
  threeDsTypeMapper,
  constructNameDescription,
  SaveAndActivateButton,
  ConfigureRuleButton,
  checkIfValuePresent,
  validateConditionJson,
  validateConditionsFor3ds,
  getRecordsObject,
  filter,
  filterConnectorList,
  filterConnectorListJson,
  filterConnectorListCoreJson,
  urlToVariantMapper,
};
/* currentTimeInUTC Not a pure module */
