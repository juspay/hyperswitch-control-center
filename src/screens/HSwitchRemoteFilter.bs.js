// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Icon from "../components/Icon.bs.js";
import * as React from "react";
import * as Filter from "../components/Filter.bs.js";
import * as APIUtils from "./APIUtils/APIUtils.bs.js";
import * as LogicUtils from "../utils/LogicUtils.bs.js";
import * as ToastState from "../hooks/ToastState.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as InputFields from "../components/InputFields.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as TimeZoneHook from "../hooks/TimeZoneHook.bs.js";
import * as FilterContext from "../context/FilterContext.bs.js";
import * as UrlFetchUtils from "../utils/UrlFetchUtils.bs.js";
import * as JsxPPXReactSupportU from "rescript/lib/es6/jsxPPXReactSupportU.js";

function formateDateString(date) {
  return TimeZoneHook.formattedISOString(
    date.toISOString(),
    "YYYY-MM-DDTHH:mm:[00][Z]",
  );
}

function getDateFilteredObject(rangeOpt, param) {
  var range = rangeOpt !== undefined ? rangeOpt : 7;
  var currentDate = new Date();
  var end_time = formateDateString(currentDate);
  var start_time = formateDateString(
    new Date(
      new Date(
        currentDate.getFullYear(),
        currentDate.getMonth(),
        currentDate.getDate(),
      ).setDate(((currentDate.getDate() | 0) - range) | 0),
    ),
  );
  return {
    start_time: start_time,
    end_time: end_time,
  };
}

function useSetInitialFilters(
  updateExistingKeys,
  startTimeFilterKey,
  endTimeFilterKey,
  rangeOpt,
  origin,
  param,
) {
  var range = rangeOpt !== undefined ? rangeOpt : 7;
  var match = React.useContext(FilterContext.filterContext);
  var filterValueJson = match.filterValueJson;
  return function () {
    var inititalSearchParam = {};
    var defaultDate = getDateFilteredObject(range, undefined);
    if (Object.keys(filterValueJson).length >= 1) {
      return;
    }
    var timeRange =
      origin !== "analytics"
        ? [[startTimeFilterKey, defaultDate.start_time]]
        : [
            [startTimeFilterKey, defaultDate.start_time],
            [endTimeFilterKey, defaultDate.end_time],
          ];
    timeRange.forEach(function (item) {
      var key = item[0];
      var match = inititalSearchParam[key];
      if (match !== undefined) {
        return;
      } else {
        inititalSearchParam[key] = item[1];
        return;
      }
    });
    updateExistingKeys(inititalSearchParam);
  };
}

function HSwitchRemoteFilter$SearchBarFilter(props) {
  var searchVal = props.searchVal;
  var setSearchVal = props.setSearchVal;
  var match = React.useState(function () {
    return "";
  });
  var setBaseValue = match[1];
  var baseValue = match[0];
  var onChange = function (ev) {
    var value = ev.target.value;
    setBaseValue(function (param) {
      return value;
    });
  };
  React.useEffect(
    function () {
      var onKeyPress = function ($$event) {
        var keyPressed = $$event.key;
        if (keyPressed === "Enter") {
          return setSearchVal(function (param) {
            return baseValue;
          });
        }
      };
      window.addEventListener("keydown", onKeyPress);
      return function () {
        window.removeEventListener("keydown", onKeyPress);
      };
    },
    [baseValue],
  );
  React.useEffect(
    function () {
      if (baseValue.length === 0 && LogicUtils.isNonEmptyString(searchVal)) {
        setSearchVal(function (param) {
          return baseValue;
        });
      }
    },
    [baseValue],
  );
  var inputSearch_onBlur = function (_ev) {};
  var inputSearch_onFocus = function (_ev) {};
  var inputSearch = {
    name: "name",
    onBlur: inputSearch_onBlur,
    onChange: onChange,
    onFocus: inputSearch_onFocus,
    value: baseValue,
    checked: true,
  };
  return React.createElement(
    "div",
    {
      className: "w-64",
    },
    InputFields.textInput(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      Caml_option.some(
        React.createElement(Icon.make, {
          name: "search",
          size: 14,
        }),
      ),
      undefined,
      undefined,
      "!placeholder:opacity-90",
      "rounded-lg placeholder:opacity-90",
      undefined,
      "px-0",
      "opacity-100",
      undefined,
      "pl-4",
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    )(inputSearch, props.placeholder),
  );
}

var SearchBarFilter = {
  make: HSwitchRemoteFilter$SearchBarFilter,
};

function HSwitchRemoteFilter$RemoteTableFilters(props) {
  var customLeftView = props.customLeftView;
  var setOffset = props.setOffset;
  var initialFixedFilter = props.initialFixedFilter;
  var initialFilters = props.initialFilters;
  var startTimeFilterKey = props.startTimeFilterKey;
  var endTimeFilterKey = props.endTimeFilterKey;
  var setFilters = props.setFilters;
  var filterUrl = props.filterUrl;
  var __apiType = props.apiType;
  var apiType = __apiType !== undefined ? __apiType : "Get";
  var match = React.useContext(FilterContext.filterContext);
  var reset = match.reset;
  var filterValueJson = match.filterValueJson;
  var updateExistingKeys = match.updateExistingKeys;
  var filterValue = match.filterValue;
  var defaultFilters = "";
  var showToast = ToastState.useShowToast();
  React.useEffect(function () {
    if (Object.keys(filterValueJson).length === 0) {
      setFilters(function (param) {
        return {};
      });
      setOffset(function (param) {
        return 0;
      });
    }
  }, []);
  var match$1 = React.useState(function () {});
  var setFilterDataJson = match$1[1];
  var filterDataJson = match$1[0];
  var updateDetails = APIUtils.useUpdateMethod(undefined, undefined);
  var defaultDate = getDateFilteredObject(30, undefined);
  var start_time = LogicUtils.getString(
    filterValueJson,
    startTimeFilterKey,
    defaultDate.start_time,
  );
  var end_time = LogicUtils.getString(
    filterValueJson,
    endTimeFilterKey,
    defaultDate.end_time,
  );
  var fetchDetails = APIUtils.useGetMethod(undefined, undefined);
  var fetchAllFilters = async function () {
    try {
      setFilterDataJson(function (param) {});
      var response;
      if (typeof apiType !== "object") {
        if (apiType === "Post") {
          var body = LogicUtils.getJsonFromArrayOfJson([
            [startTimeFilterKey, start_time],
            [endTimeFilterKey, end_time],
          ]);
          response = await updateDetails(
            filterUrl,
            body,
            "Post",
            undefined,
            undefined,
            undefined,
            undefined,
          );
        } else {
          response = await fetchDetails(filterUrl);
        }
      } else {
        response = await fetchDetails(filterUrl);
      }
      return setFilterDataJson(function (param) {
        return response;
      });
    } catch (exn) {
      return showToast(
        "Failed to load filters",
        "ToastError",
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
    }
  };
  React.useEffect(function () {
    fetchAllFilters();
  }, []);
  var filterData = Core__Option.getOr(filterDataJson, {});
  var setInitialFilters = useSetInitialFilters(
    updateExistingKeys,
    startTimeFilterKey,
    endTimeFilterKey,
    30,
    "orders",
    undefined,
  );
  React.useEffect(
    function () {
      if (Object.keys(filterValueJson).length < 1) {
        setInitialFilters();
      }
    },
    [filterValueJson],
  );
  React.useEffect(
    function () {
      if (Object.keys(filterValueJson).length !== 0) {
        setFilters(function (param) {
          return filterValueJson;
        });
        setOffset(function (param) {
          return 0;
        });
      } else {
        setFilters(function (param) {
          return {};
        });
        setOffset(function (param) {
          return 0;
        });
      }
    },
    [filterValue],
  );
  var getAllFilter = Object.fromEntries(
    Object.entries(filterValue).map(function (item) {
      return [item[0], UrlFetchUtils.getFilterValue(item[1])];
    }),
  );
  var remoteFilters = React.useMemo(
    function () {
      return initialFilters(filterData, getAllFilter);
    },
    [getAllFilter],
  );
  var initialDisplayFilters = remoteFilters.filter(function (item) {
    return Core__Option.isSome(item.localFilter);
  });
  var remoteOptions = [];
  if (filterDataJson !== undefined) {
    return JsxPPXReactSupportU.createElementWithKey("0", Filter.make, {
      defaultFilters: defaultFilters,
      fixedFilters: initialFixedFilter(),
      requiredSearchFieldsList: [],
      remoteFilters: remoteFilters,
      remoteOptions: remoteOptions,
      localOptions: [],
      localFilters: initialDisplayFilters,
      autoApply: false,
      defaultFilterKeys: [startTimeFilterKey, endTimeFilterKey],
      customLeftView: Caml_option.some(customLeftView),
      updateUrlWith: updateExistingKeys,
      clearFilters: function () {
        reset();
      },
    });
  } else {
    return JsxPPXReactSupportU.createElementWithKey("1", Filter.make, {
      defaultFilters: defaultFilters,
      fixedFilters: initialFixedFilter(),
      requiredSearchFieldsList: [],
      remoteFilters: [],
      remoteOptions: [],
      localOptions: [],
      localFilters: [],
      autoApply: false,
      defaultFilterKeys: [startTimeFilterKey, endTimeFilterKey],
      customLeftView: Caml_option.some(customLeftView),
      updateUrlWith: updateExistingKeys,
      clearFilters: function () {
        reset();
      },
    });
  }
}

var RemoteTableFilters = {
  make: HSwitchRemoteFilter$RemoteTableFilters,
};

export {
  formateDateString,
  getDateFilteredObject,
  useSetInitialFilters,
  SearchBarFilter,
  RemoteTableFilters,
};
/* Icon Not a pure module */
