// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Icon from "../../components/Icon.bs.js";
import * as React from "react";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Recoil from "recoil";
import * as APIUtils from "../APIUtils/APIUtils.bs.js";
import * as RenderIf from "../../utils/RenderIf.bs.js";
import * as UrlUtils from "../../utils/UrlUtils.bs.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as Core__List from "@rescript/core/src/Core__List.bs.js";
import * as GlobalVars from "../../utils/GlobalVars.bs.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as ToastState from "../../hooks/ToastState.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as HSwitchUtils from "../HSwitchUtils.bs.js";
import * as ConnectPayPal from "./ConnectPayPalFlow/ConnectPayPal.bs.js";
import * as ConnectorUtils from "./ConnectorUtils.bs.js";
import * as HyperswitchAtom from "../../Recoils/HyperswitchAtom.bs.js";
import * as PayPalFlowUtils from "./ConnectPayPalFlow/PayPalFlowUtils.bs.js";
import * as ConnectorPreview from "./ConnectorPreview.bs.js";
import * as PageLoaderWrapper from "../Helpers/PageLoaderWrapper.bs.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as DefaultLandingPage from "../Helpers/DefaultLandingPage.bs.js";
import * as RescriptReactRouter from "@rescript/react/src/RescriptReactRouter.bs.js";
import * as BreadCrumbNavigation from "../../utils/BreadCrumbNavigation.bs.js";
import * as ConnectorPaymentMethod from "./ConnectorPaymentMethod.bs.js";
import * as ConnectorAccountDetails from "./ConnectorAccountDetails.bs.js";

function ConnectorHome$ConnectorCurrentStepIndicator(props) {
  var stepsArr = props.stepsArr;
  var currentStep = props.currentStep;
  var cols = stepsArr.length.toString();
  var currIndex = stepsArr.findIndex(function (item) {
    return item === currentStep;
  });
  return React.createElement(
    "div",
    {
      className: " w-full md:w-2/3",
    },
    React.createElement(
      "div",
      {
        className: "grid grid-cols-" + cols + " relative gap-2",
      },
      stepsArr.map(function (step, i) {
        var isStepCompleted = i <= currIndex;
        var isPreviousStepCompleted = i < currIndex;
        var isCurrentStep = i === currIndex;
        var stepNumberIndicator = isPreviousStepCompleted
          ? "border-black bg-white"
          : isCurrentStep
            ? "bg-black"
            : "border-gray-300 bg-white";
        var stepNameIndicator = isStepCompleted
          ? "text-black break-all"
          : "text-jp-gray-700 break-all";
        var textColor = isCurrentStep ? "text-white" : "text-grey-700";
        var stepLineIndicator = isPreviousStepCompleted
          ? "bg-gray-700"
          : "bg-gray-200";
        return React.createElement(
          "div",
          {
            key: i.toString(),
            className: "flex flex-col gap-2 font-semibold ",
          },
          React.createElement(
            "div",
            {
              className: "flex items-center w-full",
            },
            React.createElement(
              "div",
              {
                className:
                  "h-8 w-8 flex items-center justify-center border rounded-full " +
                  stepNumberIndicator,
              },
              isPreviousStepCompleted
                ? React.createElement(Icon.make, {
                    name: "check-black",
                    size: 20,
                  })
                : React.createElement(
                    "p",
                    {
                      className: textColor,
                    },
                    ((i + 1) | 0).toString(),
                  ),
            ),
            React.createElement(RenderIf.make, {
              condition: i !== ((stepsArr.length - 1) | 0),
              children: React.createElement("div", {
                className: "h-0.5 " + stepLineIndicator + " ml-2 flex-1",
              }),
            }),
          ),
          React.createElement(
            "div",
            {
              className: stepNameIndicator,
            },
            ConnectorUtils.getStepName(step),
          ),
        );
      }),
    ),
  );
}

var ConnectorCurrentStepIndicator = {
  make: ConnectorHome$ConnectorCurrentStepIndicator,
};

function ConnectorHome(props) {
  var __showBreadCrumb = props.showBreadCrumb;
  var __showStepIndicator = props.showStepIndicator;
  var __isPayoutFlow = props.isPayoutFlow;
  var isPayoutFlow = __isPayoutFlow !== undefined ? __isPayoutFlow : false;
  var showStepIndicator =
    __showStepIndicator !== undefined ? __showStepIndicator : true;
  var showBreadCrumb = __showBreadCrumb !== undefined ? __showBreadCrumb : true;
  var getURL = APIUtils.useGetURL();
  var url = RescriptReactRouter.useUrl(undefined, undefined);
  var updateDetails = APIUtils.useUpdateMethod(undefined, undefined);
  var featureFlagDetails = Recoil.useRecoilValue(
    HyperswitchAtom.featureFlagAtom,
  );
  var showToast = ToastState.useShowToast();
  var connector = LogicUtils.getString(
    UrlUtils.useGetFilterDictFromUrl(""),
    "name",
    "",
  );
  var connectorTypeFromName = ConnectorUtils.getConnectorNameTypeFromString(
    connector,
    undefined,
    undefined,
  );
  var profileIdFromUrl = LogicUtils.getOptionString(
    UrlUtils.useGetFilterDictFromUrl(""),
    "profile_id",
  );
  var connectorID = HSwitchUtils.getConnectorIDFromUrl(
    Core__List.toArray(url.path),
    "",
  );
  var match = React.useState(function () {
    return "Success";
  });
  var setScreenState = match[1];
  var match$1 = React.useState(function () {
    return {};
  });
  var setInitialValues = match$1[1];
  var initialValues = match$1[0];
  var match$2 = React.useState(function () {
    return "IntegFields";
  });
  var setCurrentStep = match$2[1];
  var currentStep = match$2[0];
  var fetchDetails = APIUtils.useGetMethod(undefined, undefined);
  var match$3 = HSwitchUtils.urlPath(url.path);
  var isUpdateFlow;
  if (match$3) {
    var exit = 0;
    switch (match$3.hd) {
      case "connectors":
      case "payoutconnectors":
        exit = 1;
        break;
      default:
        isUpdateFlow = true;
    }
    if (exit === 1) {
      var match$4 = match$3.tl;
      isUpdateFlow =
        match$4 && match$4.hd === "new" && !match$4.tl ? false : true;
    }
  } else {
    isUpdateFlow = true;
  }
  var setSetupAccountStatus = Recoil.useSetRecoilState(
    HyperswitchAtom.paypalAccountStatusAtom,
  );
  var getConnectorDetails = async function () {
    try {
      var connectorUrl = getURL(
        "CONNECTOR",
        "Get",
        Caml_option.some(connectorID),
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
      var json = await fetchDetails(connectorUrl);
      return setInitialValues(function (param) {
        return json;
      });
    } catch (raw_e) {
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === Js_exn.$$Error) {
        return Js_exn.raiseError(
          Core__Option.getOr(e._1.message, "Failed to update!"),
        );
      } else {
        return Js_exn.raiseError("Something went wrong");
      }
    }
  };
  var profileID = LogicUtils.getOptionString(
    LogicUtils.getDictFromJsonObject(initialValues),
    "profile_id",
  );
  var getPayPalStatus = React.useCallback(
    async function () {
      try {
        setScreenState(function (param) {
          return "Loading";
        });
        var profileId =
          profileID !== undefined
            ? profileID
            : profileIdFromUrl !== undefined
              ? profileIdFromUrl
              : Js_exn.raiseError("Profile Id not found!");
        var paypalBody = PayPalFlowUtils.generatePayPalBody(
          undefined,
          connectorID,
          Caml_option.some(profileId),
          undefined,
        );
        var url = getURL(
          "PAYPAL_ONBOARDING_SYNC",
          "Post",
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
        var responseValue = await updateDetails(
          url,
          paypalBody,
          "Post",
          undefined,
          undefined,
          undefined,
          undefined,
        );
        var paypalDict = LogicUtils.getJsonObjectFromDict(
          LogicUtils.getDictFromJsonObject(responseValue),
          "paypal",
        );
        var str = Core__JSON.Classify.classify(paypalDict);
        if (typeof str === "object") {
          switch (str.TAG) {
            case "String":
              var str$1 = str._0;
              setSetupAccountStatus(function (param) {
                return PayPalFlowUtils.stringToVariantMapper(str$1);
              });
              setCurrentStep(function (param) {
                return "AutomaticFlow";
              });
              break;
            case "Object":
              PayPalFlowUtils.handleObjectResponse(
                str._0,
                setInitialValues,
                connector,
                function () {
                  setCurrentStep(function (param) {
                    return "PaymentMethods";
                  });
                },
              );
              break;
            default:
          }
        }
        return setScreenState(function (param) {
          return "Success";
        });
      } catch (raw_e) {
        var e = Caml_js_exceptions.internalToOCamlException(raw_e);
        if (e.RE_EXN_ID === Js_exn.$$Error) {
          var err = Core__Option.getOr(e._1.message, "Failed to Fetch!");
          if (err.includes("Profile")) {
            showToast(
              "Profile Id not found. Try Again",
              "ToastError",
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
            );
          }
          return setScreenState(function (param) {
            return "Custom";
          });
        }
        throw e;
      }
    },
    [connector, profileID, profileIdFromUrl, connectorID],
  );
  var commonPageState = function () {
    if (isUpdateFlow) {
      setCurrentStep(function (param) {
        return "Preview";
      });
    } else {
      setCurrentStep(function (param) {
        return "IntegFields";
      });
    }
    setScreenState(function (param) {
      return "Success";
    });
  };
  var determinePageState = function () {
    var match = featureFlagDetails.paypalAutomaticFlow;
    if (
      connectorTypeFromName.TAG === "Processors" &&
      connectorTypeFromName._0 === "PAYPAL" &&
      match
    ) {
      PayPalFlowUtils.payPalPageState(
        setScreenState,
        url,
        setSetupAccountStatus,
        getPayPalStatus,
        setCurrentStep,
        isUpdateFlow,
      );
      return;
    } else {
      return commonPageState();
    }
  };
  var getDetails = async function () {
    try {
      setScreenState(function (param) {
        return "Loading";
      });
      await window.init();
      if (isUpdateFlow) {
        await getConnectorDetails();
      }
      return determinePageState();
    } catch (raw_e) {
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID !== Js_exn.$$Error) {
        return setScreenState(function (param) {
          return {
            TAG: "Error",
            _0: "Something went wrong",
          };
        });
      }
      var err = Core__Option.getOr(e._1.message, "Something went wrong");
      return setScreenState(function (param) {
        return {
          TAG: "Error",
          _0: err,
        };
      });
    }
  };
  React.useEffect(
    function () {
      if (LogicUtils.isNonEmptyString(connector)) {
        getDetails();
      } else {
        setScreenState(function (param) {
          return {
            TAG: "Error",
            _0: "Connector name not found",
          };
        });
      }
    },
    [connector],
  );
  var match$5 = isPayoutFlow
    ? ["Payout Processor", "/payoutconnectors"]
    : ["Processor", "/connectors"];
  var link = match$5[1];
  var title = match$5[0];
  var stepsArr = isPayoutFlow
    ? ConnectorUtils.payoutStepsArr
    : ConnectorUtils.stepsArr;
  var borderWidth = isPayoutFlow ? "w-8/12" : "w-9/12";
  var customUiForPaypal = React.createElement(DefaultLandingPage.make, {
    title: "Oops, we hit a little bump on the road!",
    subtitle:
      "We apologize for the inconvenience, but it seems like we encountered a hiccup while processing your request.",
    customStyle: "py-16 !m-0 ",
    isButton: true,
    buttonText: "Go back to processor",
    onClickHandler: function () {
      RescriptReactRouter.push(GlobalVars.appendDashboardPath("/connectors"));
      setScreenState(function (param) {
        return "Success";
      });
    },
    overriddingStylesTitle: "text-2xl font-semibold",
    overriddingStylesSubtitle: "!text-sm text-grey-700 opacity-50 !w-3/4",
  });
  var tmp;
  var exit$1 = 0;
  switch (currentStep) {
    case "IntegFields":
      tmp = React.createElement(ConnectorAccountDetails.make, {
        setCurrentStep: setCurrentStep,
        setInitialValues: setInitialValues,
        initialValues: initialValues,
        isUpdateFlow: isUpdateFlow,
        isPayoutFlow: isPayoutFlow,
      });
      break;
    case "PaymentMethods":
      tmp = React.createElement(ConnectorPaymentMethod.make, {
        setCurrentStep: setCurrentStep,
        connector: connector,
        setInitialValues: setInitialValues,
        initialValues: initialValues,
        isUpdateFlow: isUpdateFlow,
        isPayoutFlow: isPayoutFlow,
      });
      break;
    case "SummaryAndTest":
    case "Preview":
      exit$1 = 1;
      break;
    case "AutomaticFlow":
      tmp =
        connectorTypeFromName.TAG === "Processors" &&
        connectorTypeFromName._0 === "PAYPAL"
          ? React.createElement(ConnectPayPal.make, {
              connector: connector,
              isUpdateFlow: isUpdateFlow,
              setInitialValues: setInitialValues,
              initialValues: initialValues,
              setCurrentStep: setCurrentStep,
              getPayPalStatus: getPayPalStatus,
            })
          : null;
      break;
  }
  if (exit$1 === 1) {
    tmp = React.createElement(ConnectorPreview.make, {
      connectorInfo: initialValues,
      currentStep: currentStep,
      setCurrentStep: setCurrentStep,
      isUpdateFlow: isUpdateFlow,
      isPayoutFlow: isPayoutFlow,
      setInitialValues: setInitialValues,
      getPayPalStatus: getPayPalStatus,
    });
  }
  return React.createElement(PageLoaderWrapper.make, {
    children: Caml_option.some(
      React.createElement(
        "div",
        {
          className: "flex flex-col gap-10 overflow-scroll h-full w-full",
        },
        React.createElement(RenderIf.make, {
          condition: showBreadCrumb,
          children: React.createElement(BreadCrumbNavigation.make, {
            path: [
              connectorID === "new"
                ? {
                    title: title,
                    link: link,
                    warning:
                      "You have not yet completed configuring your " +
                      LogicUtils.snakeToTitle(connector) +
                      " connector. Are you sure you want to go back?",
                  }
                : {
                    title: title,
                    link: link,
                  },
            ],
            currentPageTitle: ConnectorUtils.getDisplayNameForConnector(
              undefined,
              connector,
            ),
            cursorStyle: "cursor-pointer",
          }),
        }),
        React.createElement(RenderIf.make, {
          condition: currentStep !== "Preview" && showStepIndicator,
          children: React.createElement(
            ConnectorHome$ConnectorCurrentStepIndicator,
            {
              currentStep: currentStep,
              stepsArr: stepsArr,
              borderWidth: borderWidth,
            },
          ),
        }),
        React.createElement(RenderIf.make, {
          condition: ConnectorUtils.checkIsDummyConnector(
            connectorTypeFromName,
            featureFlagDetails.testProcessors,
          ),
          children: React.createElement(HSwitchUtils.WarningArea.make, {
            warningText:
              "This is a test connector and will not be reflected on your payment processor dashboard.",
          }),
        }),
        React.createElement(
          "div",
          {
            className:
              "bg-white rounded-lg border h-3/4 overflow-scroll shadow-boxShadowMultiple show-scrollbar",
          },
          tmp,
        ),
      ),
    ),
    screenState: match[0],
    customUI: Caml_option.some(customUiForPaypal),
  });
}

var make = ConnectorHome;

export { ConnectorCurrentStepIndicator, make };
/* Icon Not a pure module */
