// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Icon from "../../components/Icon.bs.js";
import * as React from "react";
import * as Button from "../../components/Button.bs.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Navbar from "../../components/Navbar.bs.js";
import * as Recoil from "recoil";
import * as ToolTip from "../../components/tooltip/ToolTip.bs.js";
import * as APIUtils from "../APIUtils/APIUtils.bs.js";
import * as RenderIf from "../../utils/RenderIf.bs.js";
import * as UrlUtils from "../../utils/UrlUtils.bs.js";
import * as Clipboard from "../../libraries/Clipboard.bs.js";
import * as GlobalVars from "../../utils/GlobalVars.bs.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as PopUpState from "../../hooks/PopUpState.bs.js";
import * as ToastState from "../../hooks/ToastState.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.js";
import * as GatewayIcon from "../../components/custom-icons/GatewayIcon.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as HSwitchUtils from "../HSwitchUtils.bs.js";
import * as MixpanelHook from "../MixpanelHook.bs.js";
import * as ConnectorUtils from "./ConnectorUtils.bs.js";
import * as GlobalProvider from "../../entryPoints/Provider/GlobalProvider.bs.js";
import * as CommonAuthHooks from "../../entryPoints/AuthModule/Common/CommonAuthHooks.bs.js";
import * as HyperswitchAtom from "../../Recoils/HyperswitchAtom.bs.js";
import * as React$1 from "@headlessui/react";
import * as AddDataAttributes from "../../components/AddDataAttributes.bs.js";
import * as PageLoaderWrapper from "../Helpers/PageLoaderWrapper.bs.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as ConnectorListMapper from "../../utils/Mappers/ConnectorListMapper.bs.js";
import * as ConnectorTableUtils from "./ConnectorTableUtils.bs.js";
import * as JsxPPXReactSupportU from "rescript/lib/es6/jsxPPXReactSupportU.js";
import * as MenuOptionForPayPal from "./ConnectPayPalFlow/MenuOptionForPayPal.bs.js";
import * as RescriptReactRouter from "@rescript/react/src/RescriptReactRouter.bs.js";
import * as MerchantAccountUtils from "../Settings/MerchantAccountUtils.bs.js";

function ConnectorPreview$InfoField(props) {
  var str = Core__Option.getOr(props.render, "");
  return React.createElement(RenderIf.make, {
    condition: LogicUtils.isNonEmptyString(str),
    children: React.createElement(
      "div",
      undefined,
      React.createElement(
        "h2",
        {
          className: "text-lg font-semibold",
        },
        props.label,
      ),
      React.createElement(
        "h3",
        {
          className: " break-words",
        },
        str,
      ),
    ),
  });
}

var InfoField = {
  make: ConnectorPreview$InfoField,
};

function ConnectorPreview$KeyAndCopyArea(props) {
  var copyValue = props.copyValue;
  var showToast = ToastState.useShowToast();
  return React.createElement(
    "div",
    {
      className: "flex flex-col md:flex-row gap-2 items-start",
    },
    React.createElement(
      "p",
      {
        className:
          "text-base text-grey-700 opacity-70 break-all overflow-scroll",
      },
      copyValue,
    ),
    React.createElement(
      "div",
      {
        className: "cursor-pointer h-20 w-20 pt-1",
        onClick: function (param) {
          Clipboard.writeText(copyValue);
          showToast(
            "Copied to Clipboard!",
            "ToastSuccess",
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
          );
        },
      },
      React.createElement("img", {
        alt: "copy-clipboard",
        src: "/assets/CopyToClipboard.svg",
      }),
    ),
  );
}

var KeyAndCopyArea = {
  make: ConnectorPreview$KeyAndCopyArea,
};

function ConnectorPreview$DeleteConnectorMenu(props) {
  var connectorInfo = props.connectorInfo;
  var getURL = APIUtils.useGetURL();
  var updateDetails = APIUtils.useUpdateMethod(undefined, undefined);
  var deleteConnector = async function () {
    try {
      var connectorID = connectorInfo.merchant_connector_id;
      var url = getURL(
        "CONNECTOR",
        "Post",
        Caml_option.some(connectorID),
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
      await updateDetails(
        url,
        {},
        "Delete",
        undefined,
        undefined,
        undefined,
        undefined,
      );
      return RescriptReactRouter.push(
        GlobalVars.appendDashboardPath("/connectors"),
      );
    } catch (exn) {
      return;
    }
  };
  var showPopUp = PopUpState.useShowPopUp();
  return React.createElement(AddDataAttributes.make, {
    attributes: [["data-testid", "delete-button".toLowerCase()]],
    children: React.createElement(
      "div",
      undefined,
      React.createElement(Button.make, {
        text: "Delete",
        onClick: function (_e) {
          showPopUp({
            heading: "Confirm Action ? ",
            description:
              "You are about to Delete this connector. This might impact your desired routing configurations. Please confirm to proceed.",
            popUpType: ["Warning", "WithIcon"],
            handleCancel: {
              text: "Cancel",
            },
            handleConfirm: {
              text: "Confirm",
              onClick: function (param) {
                deleteConnector();
              },
            },
          });
        },
      }),
    ),
  });
}

var DeleteConnectorMenu = {
  make: ConnectorPreview$DeleteConnectorMenu,
};

function ConnectorPreview$MenuOption(props) {
  var connector = props.connector;
  var isConnectorDisabled = props.isConnectorDisabled;
  var disableConnector = props.disableConnector;
  var setCurrentStep = props.setCurrentStep;
  var __updateStepValue = props.updateStepValue;
  var updateStepValue =
    __updateStepValue !== undefined ? __updateStepValue : "IntegFields";
  var mixpanelEvent = MixpanelHook.useSendEvent();
  var showPopUp = PopUpState.useShowPopUp();
  var connectorStatusAvailableToSwitch = isConnectorDisabled
    ? "Enable"
    : "Disable";
  return React.createElement(React$1.Popover, {
    as: "div",
    className: "relative inline-block text-left",
    children: function (_popoverProps) {
      return React.createElement(
        React.Fragment,
        {},
        React.createElement(React$1.Popover.Button, {
          children: function (_buttonProps) {
            return React.createElement(Icon.make, {
              name: "menu-option",
              size: 28,
            });
          },
        }),
        React.createElement(React$1.Popover.Panel, {
          className: "absolute z-20 right-5 top-4",
          children: function (panelProps) {
            return React.createElement(
              "div",
              {
                className:
                  "relative flex flex-col bg-white py-3 overflow-hidden rounded ring-1 ring-black ring-opacity-5 w-40",
                id: "neglectTopbarTheme",
              },
              React.createElement(
                React.Fragment,
                {},
                React.createElement(Navbar.MenuOption.make, {
                  text: "Update",
                  onClick: function (param) {
                    panelProps.close();
                    mixpanelEvent(
                      "processor_update_" + connector,
                      undefined,
                      undefined,
                      undefined,
                      undefined,
                      undefined,
                    );
                    setCurrentStep(function (param) {
                      return updateStepValue;
                    });
                  },
                }),
                React.createElement(Navbar.MenuOption.make, {
                  text: connectorStatusAvailableToSwitch,
                  onClick: function (param) {
                    panelProps.close();
                    showPopUp({
                      heading: "Confirm Action ? ",
                      description:
                        "You are about to " +
                        (isConnectorDisabled
                          ? "Enable"
                          : "Disable".toLowerCase()) +
                        " this connector. This might impact your desired routing configurations. Please confirm to proceed.",
                      popUpType: ["Warning", "WithIcon"],
                      handleCancel: {
                        text: "Cancel",
                      },
                      handleConfirm: {
                        text: "Confirm",
                        onClick: function (param) {
                          disableConnector(isConnectorDisabled);
                        },
                      },
                    });
                  },
                }),
              ),
            );
          },
        }),
      );
    },
  });
}

var MenuOption = {
  make: ConnectorPreview$MenuOption,
};

function ConnectorPreview$ConnectorSummaryGrid(props) {
  var setScreenState = props.setScreenState;
  var isPayoutFlow = props.isPayoutFlow;
  var connector = props.connector;
  var connectorInfo = props.connectorInfo;
  var businessProfiles = Recoil.useRecoilValue(
    HyperswitchAtom.businessProfilesAtom,
  );
  var defaultBusinessProfile =
    MerchantAccountUtils.getValueFromBusinessProfile(businessProfiles);
  var currentProfileName = Core__Option.getOr(
    businessProfiles.find(function (ele) {
      return ele.profile_id === connectorInfo.profile_id;
    }),
    defaultBusinessProfile,
  );
  var match = Core__Option.getOr(
    CommonAuthHooks.useCommonAuthInfo(),
    CommonAuthHooks.defaultAuthInfo,
  );
  var copyValueOfWebhookEndpoint = ConnectorUtils.getWebhooksUrl(
    connectorInfo.merchant_connector_id,
    match.merchant_id,
  );
  var connectorDetails = React.useMemo(
    function () {
      try {
        if (!LogicUtils.isNonEmptyString(connector)) {
          return {};
        }
        var dict = isPayoutFlow
          ? window.getPayoutConnectorConfig(connector)
          : window.getConnectorConfig(connector);
        setScreenState(function (param) {
          return "Success";
        });
        return dict;
      } catch (raw_e) {
        var e = Caml_js_exceptions.internalToOCamlException(raw_e);
        if (e.RE_EXN_ID === Js_exn.$$Error) {
          var e$1 = e._1;
          console.log("FAILED TO LOAD CONNECTOR CONFIG", e$1);
          var err = Core__Option.getOr(e$1.message, "Something went wrong");
          setScreenState(function (param) {
            return {
              TAG: "Error",
              _0: err,
            };
          });
          return {};
        }
        throw e;
      }
    },
    [connector],
  );
  var match$1 = ConnectorUtils.getConnectorFields(connectorDetails);
  var connectorAccountFields = match$1[1];
  return React.createElement(
    "div",
    {
      className: "p-2 md:px-10",
    },
    React.createElement(
      "div",
      {
        className: "grid grid-cols-4 my-12",
      },
      React.createElement(
        "h4",
        {
          className: "text-lg font-semibold",
        },
        "Integration status",
      ),
      React.createElement(AddDataAttributes.make, {
        attributes: [["data-testid", "connector_status".toLowerCase()]],
        children: React.createElement(
          "div",
          {
            className:
              "text-black font-semibold text-sm " +
              ConnectorTableUtils.connectorStatusStyle(connectorInfo.status),
          },
          connectorInfo.status.toUpperCase(),
        ),
      }),
    ),
    React.createElement(
      "div",
      {
        className: "grid grid-cols-4 my-12",
      },
      React.createElement(
        "div",
        {
          className: "flex items-start",
        },
        React.createElement(
          "h4",
          {
            className: "text-lg font-semibold",
          },
          "Webhook Endpoint",
        ),
        React.createElement(ToolTip.make, {
          description:
            "Configure this endpoint in the processors dashboard under webhook settings for us to receive events from the processor",
          toolTipFor: Caml_option.some(
            React.createElement(Icon.make, {
              name: "tooltip_info",
              className: "mt-1 ml-1",
            }),
          ),
          tooltipWidthClass: "w-fit",
          toolTipPosition: "Top",
          height: "",
        }),
      ),
      React.createElement(
        "div",
        {
          className: "col-span-3",
        },
        React.createElement(ConnectorPreview$KeyAndCopyArea, {
          copyValue: copyValueOfWebhookEndpoint,
        }),
      ),
    ),
    React.createElement(
      "div",
      {
        className: "grid grid-cols-4 my-12",
      },
      React.createElement(
        "h4",
        {
          className: "text-lg font-semibold",
        },
        "Profile",
      ),
      React.createElement(
        "div",
        {
          className: "col-span-3",
        },
        currentProfileName.profile_name + " - " + connectorInfo.profile_id,
      ),
    ),
    React.createElement(
      "div",
      {
        className: "grid grid-cols-4  my-12",
      },
      React.createElement(
        "h4",
        {
          className: "text-lg font-semibold",
        },
        "API Keys",
      ),
      React.createElement(
        "div",
        {
          className: "flex flex-col gap-6 col-span-3",
        },
        Object.keys(connectorAccountFields).map(function (field, index) {
          var label = LogicUtils.getString(connectorAccountFields, field, "");
          return JsxPPXReactSupportU.createElementWithKey(
            index.toString(),
            ConnectorPreview$InfoField,
            {
              render: ConnectorUtils.getConnectorDetailsValue(
                connectorInfo,
                field,
              ),
              label: label,
            },
          );
        }),
      ),
    ),
    React.createElement(
      "div",
      {
        className: "grid grid-cols-4  my-12",
      },
      React.createElement(
        "h4",
        {
          className: "text-lg font-semibold",
        },
        "PMTs",
      ),
      React.createElement(
        "div",
        {
          className: "flex flex-col gap-6 col-span-3",
        },
        React.createElement(
          "div",
          {
            className:
              "flex border items-start bg-blue-800 border-blue-810 text-sm rounded-md gap-2 px-4 py-3",
          },
          React.createElement(Icon.make, {
            name: "info-vacent",
            size: 18,
          }),
          React.createElement(
            "p",
            undefined,
            "Improve conversion rate by conditionally managing PMTs visibility on checkout . Visit Settings >",
            React.createElement(
              "a",
              {
                className: "text-blue-500 underline cursor-pointer",
                target: "_blank",
                onClick: function (param) {
                  RescriptReactRouter.push(
                    GlobalVars.appendDashboardPath("/configure-pmts"),
                  );
                },
              },
              "Configure PMTs at Checkout",
            ),
          ),
        ),
        connectorInfo.payment_methods_enabled.map(function (field, index) {
          return JsxPPXReactSupportU.createElementWithKey(
            index.toString(),
            ConnectorPreview$InfoField,
            {
              render: Core__Array.reduce(
                field.payment_method_types.map(function (item) {
                  return LogicUtils.snakeToTitle(item.payment_method_type);
                }),
                [],
                function (acc, curr) {
                  if (!acc.includes(curr)) {
                    acc.push(curr);
                  }
                  return acc;
                },
              ).join(", "),
              label: LogicUtils.snakeToTitle(field.payment_method),
            },
          );
        }),
      ),
    ),
  );
}

var ConnectorSummaryGrid = {
  make: ConnectorPreview$ConnectorSummaryGrid,
};

function ConnectorPreview(props) {
  var getPayPalStatus = props.getPayPalStatus;
  var __showMenuOption = props.showMenuOption;
  var isUpdateFlow = props.isUpdateFlow;
  var setCurrentStep = props.setCurrentStep;
  var connectorInfo = props.connectorInfo;
  var showMenuOption = __showMenuOption !== undefined ? __showMenuOption : true;
  var match = Recoil.useRecoilValue(HyperswitchAtom.featureFlagAtom);
  var paypalAutomaticFlow = match.paypalAutomaticFlow;
  var getURL = APIUtils.useGetURL();
  var url = RescriptReactRouter.useUrl(undefined, undefined);
  var updateDetails = APIUtils.useUpdateMethod(undefined, undefined);
  var showToast = ToastState.useShowToast();
  var mixpanelEvent = MixpanelHook.useSendEvent();
  var connector = LogicUtils.getString(
    UrlUtils.useGetFilterDictFromUrl(""),
    "name",
    "",
  );
  var match$1 = React.useContext(GlobalProvider.defaultContext);
  var setShowFeedbackModal = match$1.setShowFeedbackModal;
  var match$2 = React.useState(function () {
    return "Success";
  });
  var setScreenState = match$2[1];
  var connectorInfoDict = LogicUtils.getDictFromJsonObject(connectorInfo);
  var connectorInfo$1 = ConnectorListMapper.getProcessorPayloadType(
    LogicUtils.getDictFromJsonObject(connectorInfo),
  );
  var connectorCount = ConnectorUtils.getProcessorsListFromJson(
    Recoil.useRecoilValue(HyperswitchAtom.connectorListAtom),
    "FRMPlayer",
    undefined,
  ).length;
  var isFeedbackModalToBeOpen =
    match.feedback &&
    !isUpdateFlow &&
    connectorCount <= HSwitchUtils.feedbackModalOpenCountForConnectors;
  var match$3 = HSwitchUtils.urlPath(url.path);
  var redirectPath;
  if (match$3 && match$3.hd === "payoutconnectors") {
    var match$4 = match$3.tl;
    redirectPath = match$4 && !match$4.tl ? "/payoutconnectors" : "/connectors";
  } else {
    redirectPath = "/connectors";
  }
  var isConnectorDisabled = connectorInfo$1.disabled;
  var disableConnector = async function (isConnectorDisabled) {
    try {
      var connectorID = connectorInfo$1.merchant_connector_id;
      var disableConnectorPayload = ConnectorUtils.getDisableConnectorPayload(
        connectorInfo$1.connector_type,
        isConnectorDisabled,
      );
      var url = getURL(
        "CONNECTOR",
        "Post",
        Caml_option.some(connectorID),
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
      await updateDetails(
        url,
        disableConnectorPayload,
        "Post",
        undefined,
        undefined,
        undefined,
        undefined,
      );
      showToast(
        "Successfully Saved the Changes",
        "ToastSuccess",
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
      return RescriptReactRouter.push(
        GlobalVars.appendDashboardPath(redirectPath),
      );
    } catch (raw_exn) {
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Js_exn.$$Error) {
        return showToast(
          "Failed to Disable connector!",
          "ToastError",
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
      }
      throw exn;
    }
  };
  var mixpanelEventName = isUpdateFlow
    ? "processor_step3_onUpdate"
    : "processor_step3";
  var match$5 = ConnectorUtils.getConnectorNameTypeFromString(
    connector,
    undefined,
    undefined,
  );
  var match$6 = connectorInfo$1.status;
  var tmp;
  if (props.currentStep === "Preview") {
    var exit = 0;
    if (
      match$5.TAG === "Processors" &&
      match$5._0 === "PAYPAL" &&
      match$6 === "inactive" &&
      paypalAutomaticFlow
    ) {
      tmp = React.createElement(Button.make, {
        text: "Sync",
        buttonType: "Primary",
        onClick: function (param) {
          getPayPalStatus();
        },
      });
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$7 = ConnectorUtils.getConnectorNameTypeFromString(
        connector,
        undefined,
        undefined,
      );
      var tmp$1;
      var exit$1 = 0;
      if (
        match$7.TAG === "Processors" &&
        match$7._0 === "PAYPAL" &&
        paypalAutomaticFlow
      ) {
        tmp$1 = React.createElement(MenuOptionForPayPal.make, {
          updateStepValue: "PaymentMethods",
          setCurrentStep: setCurrentStep,
          disableConnector: disableConnector,
          isConnectorDisabled: isConnectorDisabled,
          connectorInfoDict: connectorInfoDict,
          setScreenState: setScreenState,
          isUpdateFlow: isUpdateFlow,
          setInitialValues: props.setInitialValues,
        });
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        tmp$1 = React.createElement(ConnectorPreview$MenuOption, {
          setCurrentStep: setCurrentStep,
          disableConnector: disableConnector,
          isConnectorDisabled: isConnectorDisabled,
          connector: connector,
        });
      }
      tmp = React.createElement(
        "div",
        {
          className: "flex gap-6 items-center",
        },
        React.createElement(
          "div",
          {
            className:
              "px-4 py-2 rounded-full w-fit font-medium text-sm !text-black " +
              (isConnectorDisabled
                ? "border bg-red-600 bg-opacity-40 border-red-400 text-red-500"
                : "border bg-green-600 bg-opacity-40 border-green-700 text-green-700"),
          },
          isConnectorDisabled ? "DISABLED" : "ENABLED",
        ),
        React.createElement(RenderIf.make, {
          condition: showMenuOption,
          children: tmp$1,
        }),
      );
    }
  } else {
    tmp = React.createElement(Button.make, {
      text: "Done",
      buttonType: "Primary",
      onClick: function (param) {
        mixpanelEvent(
          mixpanelEventName,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        );
        if (isFeedbackModalToBeOpen) {
          setShowFeedbackModal(function (param) {
            return true;
          });
        }
        RescriptReactRouter.push(GlobalVars.appendDashboardPath(redirectPath));
      },
    });
  }
  return React.createElement(PageLoaderWrapper.make, {
    children: Caml_option.some(
      React.createElement(
        "div",
        undefined,
        React.createElement(
          "div",
          {
            className: "flex justify-between border-b p-2 md:px-10 md:py-6",
          },
          React.createElement(
            "div",
            {
              className: "flex gap-2 items-center",
            },
            React.createElement(GatewayIcon.make, {
              gateway: connectorInfo$1.connector_name.toUpperCase(),
              className: "w-14 h-14",
            }),
            React.createElement(
              "h2",
              {
                className: "text-xl font-semibold",
              },
              ConnectorUtils.getDisplayNameForConnector(
                undefined,
                connectorInfo$1.connector_name,
              ),
            ),
          ),
          React.createElement(
            "div",
            {
              className: "self-center",
            },
            tmp,
          ),
        ),
        React.createElement(ConnectorPreview$ConnectorSummaryGrid, {
          connectorInfo: connectorInfo$1,
          connector: connector,
          isPayoutFlow: props.isPayoutFlow,
          setScreenState: setScreenState,
        }),
      ),
    ),
    screenState: match$2[0],
  });
}

var make = ConnectorPreview;

export {
  InfoField,
  KeyAndCopyArea,
  DeleteConnectorMenu,
  MenuOption,
  ConnectorSummaryGrid,
  make,
};
/* Icon Not a pure module */
