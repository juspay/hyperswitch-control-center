// Generated by ReScript, PLEASE EDIT WITH CARE

import * as LogicUtils from "../../../../utils/LogicUtils.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as ConnectorUtils from "../../ConnectorUtils.bs.js";
import * as CommonMetaDataHelper from "../Common/CommonMetaDataHelper.bs.js";

var allowedAuthMethod = ["PAN_ONLY", "CRYPTOGRAM_3DS"];

var allowedCardNetworks = [
  "AMEX",
  "DISCOVER",
  "INTERAC",
  "JCB",
  "MASTERCARD",
  "VISA",
];

var allowedPaymentMethodparameters = {
  allowed_auth_methods: allowedAuthMethod,
  allowed_card_networks: allowedCardNetworks,
};

function getCustomGateWayName(connector) {
  var match = ConnectorUtils.getConnectorNameTypeFromString(
    connector,
    undefined,
    undefined,
  );
  if (match.TAG !== "Processors") {
    return connector;
  }
  switch (match._0) {
    case "CHECKOUT":
      return "checkoutltd";
    case "AUTHORIZEDOTNET":
      return "authorizenet";
    case "GLOBALPAY":
      return "globalpayments";
    case "BANKOFAMERICA":
    case "CYBERSOURCE":
      return "cybersource";
    case "NUVEI":
      return "nuveidigital";
    default:
      return connector;
  }
}

function tokenizationSpecificationParameters(dict, connector) {
  var tokenizationSpecificationDict = LogicUtils.getDictfromDict(
    LogicUtils.getDictfromDict(dict, "tokenization_specification"),
    "parameters",
  );
  var match = ConnectorUtils.getConnectorNameTypeFromString(
    connector,
    undefined,
    undefined,
  );
  if (match.TAG === "Processors" && match._0 === "STRIPE") {
    return {
      gateway: connector,
      "stripe:version": LogicUtils.getString(
        tokenizationSpecificationDict,
        "stripe:version",
        "2018-10-31",
      ),
      "stripe:publishableKey": LogicUtils.getString(
        tokenizationSpecificationDict,
        "stripe:publishableKey",
        "",
      ),
    };
  }
  return {
    gateway: getCustomGateWayName(connector),
    gateway_merchant_id: LogicUtils.getString(
      tokenizationSpecificationDict,
      "gateway_merchant_id",
      "",
    ),
  };
}

function merchantInfo(dict) {
  return {
    merchant_id: LogicUtils.getOptionString(dict, "merchant_id"),
    merchant_name: LogicUtils.getOptionString(dict, "merchant_name"),
  };
}

function tokenizationSpecification(dict, connector) {
  return {
    type: "PAYMENT_GATEWAY",
    parameters: tokenizationSpecificationParameters(dict, connector),
  };
}

function allowedPaymentMethod(dict, connector) {
  return {
    type: "CARD",
    parameters: allowedPaymentMethodparameters,
    tokenization_specification: tokenizationSpecification(dict, connector),
  };
}

function zenGooglePayConfig(dict) {
  return {
    terminal_uuid: LogicUtils.getString(dict, "terminal_uuid", ""),
    pay_wall_secret: LogicUtils.getString(dict, "pay_wall_secret", ""),
  };
}

function googlePay(dict, connector) {
  var merchantInfoDict = LogicUtils.getDictfromDict(dict, "merchant_info");
  var allowedPaymentMethodDict = LogicUtils.getDictFromJsonObject(
    Core__Option.getOr(
      LogicUtils.getArrayFromDict(dict, "allowed_payment_methods", [])[0],
      {},
    ),
  );
  var standGooglePayConfig_merchant_info = merchantInfo(merchantInfoDict);
  var standGooglePayConfig_allowed_payment_methods = [
    allowedPaymentMethod(allowedPaymentMethodDict, connector),
  ];
  var standGooglePayConfig = {
    merchant_info: standGooglePayConfig_merchant_info,
    allowed_payment_methods: standGooglePayConfig_allowed_payment_methods,
  };
  var match = ConnectorUtils.getConnectorNameTypeFromString(
    connector,
    undefined,
    undefined,
  );
  if (match.TAG === "Processors" && match._0 === "ZEN") {
    return {
      TAG: "Zen",
      _0: zenGooglePayConfig(dict),
    };
  } else {
    return {
      TAG: "Standard",
      _0: standGooglePayConfig,
    };
  }
}

function googlePayNameMapper(name) {
  switch (name) {
    case "merchant_id":
    case "merchant_name":
      return "metadata.google_pay.merchant_info." + name;
    case "pay_wall_secret":
    case "terminal_uuid":
      return "metadata.google_pay." + name;
    default:
      return (
        "metadata.google_pay.allowed_payment_methods[0].tokenization_specification.parameters." +
        name
      );
  }
}

function googlePayValueInput(googlePayField) {
  var formName = googlePayNameMapper(googlePayField.name);
  switch (googlePayField.type) {
    case "Text":
    case "Toggle":
    case "Radio":
      return CommonMetaDataHelper.textInput(googlePayField, formName);
    case "Select":
      return CommonMetaDataHelper.selectInput(
        googlePayField,
        formName,
        undefined,
        undefined,
        undefined,
      );
    case "MultiSelect":
      return CommonMetaDataHelper.multiSelectInput(googlePayField, formName);
  }
}

export {
  allowedAuthMethod,
  allowedCardNetworks,
  allowedPaymentMethodparameters,
  getCustomGateWayName,
  tokenizationSpecificationParameters,
  merchantInfo,
  tokenizationSpecification,
  allowedPaymentMethod,
  zenGooglePayConfig,
  googlePay,
  googlePayNameMapper,
  googlePayValueInput,
};
/* LogicUtils Not a pure module */
