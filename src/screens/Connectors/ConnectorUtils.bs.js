// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_vector from "rescript/lib/es6/js_vector.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as Caml_splice_call from "rescript/lib/es6/caml_splice_call.js";
import * as JsonFlattenUtils from "../../utils/JsonFlattenUtils.bs.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as CommonMetaDataUtils from "./ConnectorMetaData/Common/CommonMetaDataUtils.bs.js";
import * as SuggestedActionHelper from "./ConnectorUIUtils/SuggestedActionHelper.bs.js";
import * as ConnectorMetaDataUtils from "./ConnectorMetaData/ConnectorMetaDataUtils.bs.js";

var stepsArr = ["IntegFields", "PaymentMethods", "SummaryAndTest"];

var payoutStepsArr = ["IntegFields", "PaymentMethods", "SummaryAndTest"];

function getStepName(step) {
  switch (step) {
    case "IntegFields":
      return "Credentials";
    case "PaymentMethods":
      return "Payment Methods";
    case "SummaryAndTest":
      return "Summary";
    case "Preview":
      return "Preview";
    case "AutomaticFlow":
      return "AutomaticFlow";
  }
}

var payoutConnectorList = [
  {
    TAG: "Processors",
    _0: "ADYEN",
  },
  {
    TAG: "Processors",
    _0: "ADYENPLATFORM",
  },
  {
    TAG: "Processors",
    _0: "CYBERSOURCE",
  },
  {
    TAG: "Processors",
    _0: "EBANX",
  },
  {
    TAG: "Processors",
    _0: "PAYPAL",
  },
  {
    TAG: "Processors",
    _0: "STRIPE",
  },
  {
    TAG: "Processors",
    _0: "WISE",
  },
];

var threedsAuthenticatorList = [
  {
    TAG: "ThreeDsAuthenticator",
    _0: "THREEDSECUREIO",
  },
  {
    TAG: "ThreeDsAuthenticator",
    _0: "NETCETERA",
  },
];

var connectorList = [
  {
    TAG: "Processors",
    _0: "STRIPE",
  },
  {
    TAG: "Processors",
    _0: "PAYPAL",
  },
  {
    TAG: "Processors",
    _0: "ACI",
  },
  {
    TAG: "Processors",
    _0: "ADYEN",
  },
  {
    TAG: "Processors",
    _0: "AIRWALLEX",
  },
  {
    TAG: "Processors",
    _0: "AUTHORIZEDOTNET",
  },
  {
    TAG: "Processors",
    _0: "BANKOFAMERICA",
  },
  {
    TAG: "Processors",
    _0: "BAMBORA",
  },
  {
    TAG: "Processors",
    _0: "BILLWERK",
  },
  {
    TAG: "Processors",
    _0: "BITPAY",
  },
  {
    TAG: "Processors",
    _0: "BLUESNAP",
  },
  {
    TAG: "Processors",
    _0: "BRAINTREE",
  },
  {
    TAG: "Processors",
    _0: "CASHTOCODE",
  },
  {
    TAG: "Processors",
    _0: "CHECKOUT",
  },
  {
    TAG: "Processors",
    _0: "COINBASE",
  },
  {
    TAG: "Processors",
    _0: "CRYPTOPAY",
  },
  {
    TAG: "Processors",
    _0: "CYBERSOURCE",
  },
  {
    TAG: "Processors",
    _0: "DATATRANS",
  },
  {
    TAG: "Processors",
    _0: "DLOCAL",
  },
  {
    TAG: "Processors",
    _0: "FISERV",
  },
  {
    TAG: "Processors",
    _0: "FORTE",
  },
  {
    TAG: "Processors",
    _0: "GLOBALPAY",
  },
  {
    TAG: "Processors",
    _0: "GLOBEPAY",
  },
  {
    TAG: "Processors",
    _0: "GOCARDLESS",
  },
  {
    TAG: "Processors",
    _0: "HELCIM",
  },
  {
    TAG: "Processors",
    _0: "IATAPAY",
  },
  {
    TAG: "Processors",
    _0: "KLARNA",
  },
  {
    TAG: "Processors",
    _0: "MIFINITY",
  },
  {
    TAG: "Processors",
    _0: "MOLLIE",
  },
  {
    TAG: "Processors",
    _0: "MULTISAFEPAY",
  },
  {
    TAG: "Processors",
    _0: "NEXINETS",
  },
  {
    TAG: "Processors",
    _0: "NMI",
  },
  {
    TAG: "Processors",
    _0: "NOON",
  },
  {
    TAG: "Processors",
    _0: "NUVEI",
  },
  {
    TAG: "Processors",
    _0: "OPENNODE",
  },
  {
    TAG: "Processors",
    _0: "PAYME",
  },
  {
    TAG: "Processors",
    _0: "PAYU",
  },
  {
    TAG: "Processors",
    _0: "POWERTRANZ",
  },
  {
    TAG: "Processors",
    _0: "PROPHETPAY",
  },
  {
    TAG: "Processors",
    _0: "RAPYD",
  },
  {
    TAG: "Processors",
    _0: "SHIFT4",
  },
  {
    TAG: "Processors",
    _0: "STAX",
  },
  {
    TAG: "Processors",
    _0: "TRUSTPAY",
  },
  {
    TAG: "Processors",
    _0: "TSYS",
  },
  {
    TAG: "Processors",
    _0: "VOLT",
  },
  {
    TAG: "Processors",
    _0: "WORLDLINE",
  },
  {
    TAG: "Processors",
    _0: "WORLDPAY",
  },
  {
    TAG: "Processors",
    _0: "ZEN",
  },
  {
    TAG: "Processors",
    _0: "ZSL",
  },
  {
    TAG: "Processors",
    _0: "PLACETOPAY",
  },
  {
    TAG: "Processors",
    _0: "RAZORPAY",
  },
  {
    TAG: "Processors",
    _0: "BAMBORA_APAC",
  },
  {
    TAG: "Processors",
    _0: "ITAUBANK",
  },
];

var connectorListForLive = [
  {
    TAG: "Processors",
    _0: "STRIPE",
  },
  {
    TAG: "Processors",
    _0: "ADYEN",
  },
  {
    TAG: "Processors",
    _0: "AUTHORIZEDOTNET",
  },
  {
    TAG: "Processors",
    _0: "PAYPAL",
  },
  {
    TAG: "Processors",
    _0: "BANKOFAMERICA",
  },
  {
    TAG: "Processors",
    _0: "BLUESNAP",
  },
  {
    TAG: "Processors",
    _0: "BAMBORA",
  },
  {
    TAG: "Processors",
    _0: "BRAINTREE",
  },
  {
    TAG: "Processors",
    _0: "CHECKOUT",
  },
  {
    TAG: "Processors",
    _0: "CRYPTOPAY",
  },
  {
    TAG: "Processors",
    _0: "CASHTOCODE",
  },
  {
    TAG: "Processors",
    _0: "CYBERSOURCE",
  },
  {
    TAG: "Processors",
    _0: "IATAPAY",
  },
  {
    TAG: "Processors",
    _0: "KLARNA",
  },
  {
    TAG: "Processors",
    _0: "MIFINITY",
  },
  {
    TAG: "Processors",
    _0: "NMI",
  },
  {
    TAG: "Processors",
    _0: "PAYME",
  },
  {
    TAG: "Processors",
    _0: "TRUSTPAY",
  },
  {
    TAG: "Processors",
    _0: "VOLT",
  },
  {
    TAG: "Processors",
    _0: "ZSL",
  },
  {
    TAG: "Processors",
    _0: "ZEN",
  },
];

var connectorListWithAutomaticFlow = ["PAYPAL"];

function getPaymentMethodFromString(paymentMethod) {
  var match = paymentMethod.toLowerCase();
  switch (match) {
    case "bank_debit":
      return "BankDebit";
    case "bank_redirect":
      return "BankRedirect";
    case "bank_transfer":
      return "BankTransfer";
    case "crypto":
      return "Crypto";
    case "card":
    case "credit":
    case "debit":
      return "Card";
    case "paylater":
      return "PayLater";
    case "wallet":
      return "Wallet";
    default:
      return {
        TAG: "UnknownPaymentMethod",
        _0: paymentMethod,
      };
  }
}

function getPaymentMethodTypeFromString(paymentMethodType) {
  var match = paymentMethodType.toLowerCase();
  switch (match) {
    case "apple_pay":
      return "ApplePay";
    case "credit":
      return "Credit";
    case "debit":
      return "Debit";
    case "google_pay":
      return "GooglePay";
    case "paypal":
      return "PayPal";
    default:
      return {
        TAG: "UnknownPaymentMethodType",
        _0: paymentMethodType,
      };
  }
}

function dummyConnectorList(isTestProcessorsEnabled) {
  if (isTestProcessorsEnabled) {
    return [
      {
        TAG: "Processors",
        _0: "STRIPE_TEST",
      },
      {
        TAG: "Processors",
        _0: "PAYPAL_TEST",
      },
      {
        TAG: "Processors",
        _0: "FAUXPAY",
      },
      {
        TAG: "Processors",
        _0: "PRETENDPAY",
      },
    ];
  } else {
    return [];
  }
}

function checkIsDummyConnector(connectorName, isTestProcessorsEnabled) {
  if (!isTestProcessorsEnabled) {
    return false;
  }
  if (connectorName.TAG !== "Processors") {
    return false;
  }
  switch (connectorName._0) {
    case "FAUXPAY":
    case "PRETENDPAY":
    case "STRIPE_TEST":
    case "PAYPAL_TEST":
      return true;
    default:
      return false;
  }
}

var stripeInfo_validate = [
  {
    name: "connector_account_details.api_key",
    liveValidationRegex: "^sk_live_(.+)$",
    testValidationRegex: "^sk_test_(.+)$",
    liveExpectedFormat: "Secret key should have the prefix sk_live_",
    testExpectedFormat: "Secret key should have the prefix sk_test_",
  },
];

var stripeInfo = {
  description:
    "Versatile processor supporting credit cards, digital wallets, and bank transfers.",
  validate: stripeInfo_validate,
};

var goCardLessInfo = {
  description:
    "Simplify payment collection with a single, hassle-free integration across 30+ countries for Direct Debit payments.",
};

var adyenInfo = {
  description:
    "Global processor accepting major credit cards, e-wallets, and local payment methods.",
};

var adyenPlatformInfo = {
  description: "Send payout to third parties with Adyen's Balance Platform!",
};

var checkoutInfo_validate = [
  {
    name: "connector_account_details.api_key",
    liveValidationRegex: "^pk(?!_sbox).*",
    testValidationRegex: "^pk(_sbox)?_(.+)$",
    liveExpectedFormat:
      "API public key should begin with pk_ and not begin with pk_sbox_",
    testExpectedFormat: "API public key should begin with pk_",
  },
  {
    name: "connector_account_details.api_secret",
    liveValidationRegex: "^sk(?!_sbox).*",
    testValidationRegex: "^sk(_sbox)?_(.+)$",
    liveExpectedFormat:
      "API secret key should begin with sk_ and not begin with sk_sbox_",
    testExpectedFormat: "API secret key should begin with sk_",
  },
];

var checkoutInfo = {
  description:
    "Streamlined processor offering multiple payment options for a seamless checkout experience.",
  validate: checkoutInfo_validate,
};

var braintreeInfo = {
  description:
    "Trusted processor supporting credit cards, e-checks, and mobile payments for secure online transactions.",
};

var klarnaInfo = {
  description:
    "Flexible processor offering buy now, pay later options, and seamless checkout experiences for shoppers.",
  inputFieldDescription:
    "Please enter API Key in this format: Basic {API Key}\n\nEx: If your API key is UE4wO please enter Basic UE4wO",
};

var authorizedotnetInfo = {
  description:
    "Trusted processor supporting credit cards, e-checks, and mobile payments for secure online transactions.",
};

var globalpayInfo = {
  description:
    "Comprehensive processor providing global payment solutions for businesses of all sizes.",
};

var bluesnapInfo = {
  description:
    "All-in-one processor supporting global payment methods, subscription billing, and built-in fraud prevention.",
};

var airwallexInfo = {
  description:
    "Innovative processor enabling businesses to manage cross-border payments and foreign exchange seamlessly.",
};

var worldpayInfo = {
  description:
    "Leading processor facilitating secure online and in-person payments with global coverage and a range of payment options.",
};

var cybersourceInfo = {
  description:
    "Reliable processor providing fraud management tools, secure payment processing, and a variety of payment methods.",
};

var ebanxInfo = {
  description:
    "Ebanx enables global organizations to grow exponentially in Rising Markets by leveraging a platform of end-to-end localized payment and financial solutions.",
};

var aciInfo = {
  description:
    "Trusted processor offering a wide range of payment solutions, including cards, digital wallets, and real-time bank transfers.",
};

var worldlineInfo = {
  description:
    "Comprehensive processor supporting secure payment acceptance across various channels and devices with advanced security features.",
};

var fiservInfo = {
  description:
    "Full-service processor offering secure payment solutions and innovative banking technologies for businesses of all sizes.",
};

var shift4Info = {
  description:
    "Integrated processor providing secure payment processing, advanced fraud prevention, and comprehensive reporting and analytics.",
};

var rapydInfo = {
  description:
    "Flexible processor enabling businesses to accept and disburse payments globally with a wide range of payment methods.",
};

var payuInfo = {
  description:
    "Reliable processor offering easy integration, multiple payment methods, and localized solutions for global businesses.",
};

var nuveiInfo = {
  description:
    "Payment technology company providing flexible, scalable, and secure payment solutions for businesses across various industries.",
};

var dlocalInfo = {
  description:
    "Cross-border payment processor enabling businesses to accept and send payments in emerging markets worldwide.",
};

var multisafepayInfo = {
  description:
    "Versatile processor supporting a wide range of payment methods, including credit cards, e-wallets, and online banking.",
};

var bamboraInfo = {
  description:
    "Comprehensive processor offering secure payment solutions and advanced features for businesses in various industries.",
};

var zenInfo = {
  description:
    "Modern processor providing seamless payment solutions with a focus on simplicity, security, and user experience.",
};

var mollieInfo = {
  description:
    "Developer-friendly processor providing simple and customizable payment solutions for businesses of all sizes.",
};

var trustpayInfo = {
  description:
    "Reliable processor offering secure online payment solutions, including credit cards, bank transfers, and e-wallets.",
};

var paypalInfo = {
  description:
    "Well-known processor enabling individuals and businesses to send, receive, and manage online payments securely.",
};

var coinbaseInfo = {
  description:
    "Cryptocurrency processor allowing businesses to accept digital currencies like Bitcoin, Ethereum, and more.",
};

var openNodeInfo = {
  description:
    "Bitcoin payment processor enabling businesses to accept Bitcoin payments and settle in their local currency.",
};

var nmiInfo = {
  description:
    "Versatile payment processor supporting various payment methods and offering advanced customization and integration capabilities.",
};

var iataPayInfo = {
  description:
    "IATA Pay is an alternative method for travelers to pay for air tickets purchased online by directly debiting their bank account. It improves speed and security of payments, while reducing payment costs.",
};

var bitPayInfo = {
  description:
    "BitPay is a payment service provider that allows businesses and individuals to accept and process payments in Bitcoin and other cryptocurrencies securely and conveniently.",
};

var nexinetsInfo = {
  description:
    "Leading Italian payment processor providing a wide range of payment solutions for businesses of all sizes.",
};

var forteInfo = {
  description:
    "Payment processor specializing in secure and reliable payment solutions for variuos industries like healthcare.",
};

var cryptopayInfo = {
  description:
    "Secure cryptocurrency payment solution. Simplify transactions with digital currencies. Convenient and reliable.",
};

var cashToCodeInfo = {
  description:
    "Secure cash-based payment solution. Generate barcode, pay with cash at retail. Convenient alternative for cash transactions online.",
};

var powertranzInfo = {
  description:
    "Versatile processor empowering businesses with flexible payment solutions for online and mobile transactions.",
};

var paymeInfo = {
  description:
    "Convenient and secure mobile payment solution for quick transactions anytime, anywhere.",
};

var globepayInfo = {
  description:
    "Global gateway for seamless cross-border payments, ensuring efficient transactions worldwide.",
};

var tsysInfo = {
  description:
    "Trusted provider offering reliable payment processing services to businesses of all sizes across the globe.",
};

var noonInfo = {
  description:
    "A leading fintech company revolutionizing payments with innovative, secure, and convenient solutions for seamless financial transactions.",
};

var pretendpayInfo = {
  description:
    "Don't be fooled by the name - PretendPay is the real deal when it comes to testing your payments.",
};

var fauxpayInfo = {
  description:
    "Don't worry, it's not really fake - it's just FauxPay! Use it to simulate payments and refunds.",
};

var phonypayInfo = {
  description:
    "Don't want to use real money to test your payment flow? - PhonyPay lets you simulate payments and refunds",
};

var stripeTestInfo = {
  description:
    "A stripe test processor to test payments and refunds without real world consequences.",
};

var paypalTestInfo = {
  description:
    "A paypal test processor to simulate payment flows and experience hyperswitch checkout.",
};

var wiseInfo = {
  description:
    "Get your money moving internationally. Save up to 3.9x when you send with Wise.",
};

var staxInfo = {
  description:
    "Empowering businesses with effortless payment solutions for truly seamless transactions",
};

var voltInfo = {
  description:
    "A secure and versatile payment processor that facilitates seamless electronic transactions for businesses and individuals, offering a wide range of payment options and robust fraud protection.",
};

var prophetpayInfo = {
  description:
    "A secure, affordable, and easy-to-use credit card processing platform for any business.",
};

var helcimInfo = {
  description:
    "Helcim is the easy and affordable solution for small businesses accepting credit card payments.",
};

var threedsecuredotioInfo = {
  description:
    "A secure, affordable and easy to connect 3DS authentication platform. Improve the user experience during checkout, enhance the conversion rates and stay compliant with the regulations with 3dsecure.io",
};

var netceteraInfo = {
  description:
    "Cost-effective 3DS authentication platform ensuring security. Elevate checkout experience, boost conversion rates, and maintain regulatory compliance with Netcetera",
};

var unknownConnectorInfo = {
  description: "unkown connector",
};

var bankOfAmericaInfo = {
  description:
    "A top financial firm offering banking, investing, and risk solutions to individuals and businesses.",
};

var placetopayInfo = {
  description:
    "Reliable payment processor facilitating secure transactions online for businesses, ensuring seamless transactions.",
};

var billwerkInfo = {
  description:
    "Billwerk+ Pay is an acquirer independent payment gateway that helps you get the best acquirer rates, select a wide variety of payment methods.",
};

var mifinityInfo = {
  description:
    "Empowering you to pay online, receive funds, and send money globally, the MiFinity eWallet supports super-low fees, offering infinite possibilities to do more of the things you love.",
};

var zslInfo = {
  description:
    "It is a payment processor that enables businesses to accept payments securely through local bank transfers.",
};

var razorpayInfo = {
  description:
    "Razorpay helps you accept online payments from customers across Desktop, Mobile web, Android & iOS. Additionally by using Razorpay Payment Links, you can collect payments across multiple channels like SMS, Email, Whatsapp, Chatbots & Messenger.",
};

var bamboraApacInfo = {
  description:
    "Bambora offers the ability to securely and efficiently process online, real-time transactions via an API, our user-friendly interface. The API web service accepts and processes SOAP requests from a remote location over TCP/IP. Transaction results are returned in real-time via the API.",
};

var itauBankInfo = {
  description:
    "The Banking as a Service (BaaS) solution allows non-financial companies to offer services with the ecosystem that banking institutions have. Itaú as a Service (IaaS) is the ideal tool for your company to improve your customers' experience, offering a whole new portfolio of products, with Itaú's technology and security.",
};

var dataTransInfo = {
  description:
    "Datatrans is a Swiss payment service provider offering secure online, mobile, and in-store payment processing. Key features include support for multiple payment methods, fraud prevention, multi-currency transactions, and integration options for websites and apps.",
};

var signifydInfo_validate = [
  {
    placeholder: "Enter API Key",
    label: "API Key",
    name: "connector_account_details.api_key",
    isRequired: true,
    encodeToBase64: false,
  },
];

var signifydInfo = {
  description: "One platform to protect the entire shopper journey end-to-end",
  validate: signifydInfo_validate,
};

var riskifyedInfo_validate = [
  {
    placeholder: "Enter Secret token",
    label: "Secret token",
    name: "connector_account_details.api_key",
    isRequired: true,
    encodeToBase64: false,
  },
  {
    placeholder: "Enter Domain name",
    label: "Domain name",
    name: "connector_account_details.key1",
    isRequired: true,
    encodeToBase64: false,
  },
];

var riskifyedInfo = {
  description: "Frictionless fraud management for eCommerce",
  validate: riskifyedInfo_validate,
};

function getThreeDsAuthenticatorNameString(threeDsAuthenticator) {
  if (threeDsAuthenticator === "THREEDSECUREIO") {
    return "threedsecureio";
  } else {
    return "netcetera";
  }
}

function getFRMNameString(frm) {
  if (frm === "Signifyd") {
    return "signifyd";
  } else {
    return "riskified";
  }
}

function getConnectorNameString(connector) {
  switch (connector.TAG) {
    case "Processors":
      var connector$1 = connector._0;
      switch (connector$1) {
        case "ADYEN":
          return "adyen";
        case "ADYENPLATFORM":
          return "adyenplatform";
        case "CHECKOUT":
          return "checkout";
        case "BRAINTREE":
          return "braintree";
        case "BANKOFAMERICA":
          return "bankofamerica";
        case "BILLWERK":
          return "billwerk";
        case "AUTHORIZEDOTNET":
          return "authorizedotnet";
        case "STRIPE":
          return "stripe";
        case "KLARNA":
          return "klarna";
        case "GLOBALPAY":
          return "globalpay";
        case "BLUESNAP":
          return "bluesnap";
        case "AIRWALLEX":
          return "airwallex";
        case "WORLDPAY":
          return "worldpay";
        case "CYBERSOURCE":
          return "cybersource";
        case "EBANX":
          return "ebanx";
        case "ACI":
          return "aci";
        case "WORLDLINE":
          return "worldline";
        case "FISERV":
          return "fiserv";
        case "SHIFT4":
          return "shift4";
        case "RAPYD":
          return "rapyd";
        case "PAYU":
          return "payu";
        case "NUVEI":
          return "nuvei";
        case "DLOCAL":
          return "dlocal";
        case "MULTISAFEPAY":
          return "multisafepay";
        case "BAMBORA":
          return "bambora";
        case "MOLLIE":
          return "mollie";
        case "TRUSTPAY":
          return "trustpay";
        case "ZEN":
          return "zen";
        case "PAYPAL":
          return "paypal";
        case "COINBASE":
          return "coinbase";
        case "OPENNODE":
          return "opennode";
        case "PHONYPAY":
          return "phonypay";
        case "FAUXPAY":
          return "fauxpay";
        case "PRETENDPAY":
          return "pretendpay";
        case "NMI":
          return "nmi";
        case "FORTE":
          return "forte";
        case "NEXINETS":
          return "nexinets";
        case "IATAPAY":
          return "iatapay";
        case "BITPAY":
          return "bitpay";
        case "CRYPTOPAY":
          return "cryptopay";
        case "CASHTOCODE":
          return "cashtocode";
        case "PAYME":
          return "payme";
        case "GLOBEPAY":
          return "globepay";
        case "POWERTRANZ":
          return "powertranz";
        case "TSYS":
          return "tsys";
        case "NOON":
          return "noon";
        case "STRIPE_TEST":
          return "stripe_test";
        case "PAYPAL_TEST":
          return "paypal_test";
        case "STAX":
          return "stax";
        case "WISE":
          return "wise";
        case "GOCARDLESS":
          return "gocardless";
        case "VOLT":
          return "volt";
        case "PROPHETPAY":
          return "prophetpay";
        case "HELCIM":
          return "helcim";
        case "PLACETOPAY":
          return "placetopay";
        case "ZSL":
          return "zsl";
        case "MIFINITY":
          return "mifinity";
        case "RAZORPAY":
          return "razorpay";
        case "BAMBORA_APAC":
          return "bamboraapac";
        case "ITAUBANK":
          return "itaubank";
        case "DATATRANS":
          return "datatrans";
      }
    case "ThreeDsAuthenticator":
      return getThreeDsAuthenticatorNameString(connector._0);
    case "FRM":
      return getFRMNameString(connector._0);
    case "UnknownConnector":
      return connector._0;
  }
}

function getConnectorNameTypeFromString(connector, connectorTypeOpt, param) {
  var connectorType =
    connectorTypeOpt !== undefined ? connectorTypeOpt : "Processor";
  switch (connectorType) {
    case "FRMPlayer":
      switch (connector) {
        case "riskified":
          return {
            TAG: "FRM",
            _0: "Riskifyed",
          };
        case "signifyd":
          return {
            TAG: "FRM",
            _0: "Signifyd",
          };
        default:
          return {
            TAG: "UnknownConnector",
            _0: "Not known",
          };
      }
    case "Processor":
      switch (connector) {
        case "aci":
          return {
            TAG: "Processors",
            _0: "ACI",
          };
        case "adyen":
          return {
            TAG: "Processors",
            _0: "ADYEN",
          };
        case "adyenplatform":
          return {
            TAG: "Processors",
            _0: "ADYENPLATFORM",
          };
        case "airwallex":
          return {
            TAG: "Processors",
            _0: "AIRWALLEX",
          };
        case "authorizedotnet":
          return {
            TAG: "Processors",
            _0: "AUTHORIZEDOTNET",
          };
        case "bambora":
          return {
            TAG: "Processors",
            _0: "BAMBORA",
          };
        case "bamboraapac":
          return {
            TAG: "Processors",
            _0: "BAMBORA_APAC",
          };
        case "bankofamerica":
          return {
            TAG: "Processors",
            _0: "BANKOFAMERICA",
          };
        case "billwerk":
          return {
            TAG: "Processors",
            _0: "BILLWERK",
          };
        case "bitpay":
          return {
            TAG: "Processors",
            _0: "BITPAY",
          };
        case "bluesnap":
          return {
            TAG: "Processors",
            _0: "BLUESNAP",
          };
        case "braintree":
          return {
            TAG: "Processors",
            _0: "BRAINTREE",
          };
        case "cashtocode":
          return {
            TAG: "Processors",
            _0: "CASHTOCODE",
          };
        case "checkout":
          return {
            TAG: "Processors",
            _0: "CHECKOUT",
          };
        case "coinbase":
          return {
            TAG: "Processors",
            _0: "COINBASE",
          };
        case "cryptopay":
          return {
            TAG: "Processors",
            _0: "CRYPTOPAY",
          };
        case "cybersource":
          return {
            TAG: "Processors",
            _0: "CYBERSOURCE",
          };
        case "datatrans":
          return {
            TAG: "Processors",
            _0: "DATATRANS",
          };
        case "dlocal":
          return {
            TAG: "Processors",
            _0: "DLOCAL",
          };
        case "ebanx":
          return {
            TAG: "Processors",
            _0: "EBANX",
          };
        case "fauxpay":
          return {
            TAG: "Processors",
            _0: "FAUXPAY",
          };
        case "fiserv":
          return {
            TAG: "Processors",
            _0: "FISERV",
          };
        case "forte":
          return {
            TAG: "Processors",
            _0: "FORTE",
          };
        case "globalpay":
          return {
            TAG: "Processors",
            _0: "GLOBALPAY",
          };
        case "globepay":
          return {
            TAG: "Processors",
            _0: "GLOBEPAY",
          };
        case "gocardless":
          return {
            TAG: "Processors",
            _0: "GOCARDLESS",
          };
        case "helcim":
          return {
            TAG: "Processors",
            _0: "HELCIM",
          };
        case "iatapay":
          return {
            TAG: "Processors",
            _0: "IATAPAY",
          };
        case "itaubank":
          return {
            TAG: "Processors",
            _0: "ITAUBANK",
          };
        case "klarna":
          return {
            TAG: "Processors",
            _0: "KLARNA",
          };
        case "mifinity":
          return {
            TAG: "Processors",
            _0: "MIFINITY",
          };
        case "mollie":
          return {
            TAG: "Processors",
            _0: "MOLLIE",
          };
        case "multisafepay":
          return {
            TAG: "Processors",
            _0: "MULTISAFEPAY",
          };
        case "nexinets":
          return {
            TAG: "Processors",
            _0: "NEXINETS",
          };
        case "nmi":
          return {
            TAG: "Processors",
            _0: "NMI",
          };
        case "noon":
          return {
            TAG: "Processors",
            _0: "NOON",
          };
        case "nuvei":
          return {
            TAG: "Processors",
            _0: "NUVEI",
          };
        case "opennode":
          return {
            TAG: "Processors",
            _0: "OPENNODE",
          };
        case "payme":
          return {
            TAG: "Processors",
            _0: "PAYME",
          };
        case "paypal":
          return {
            TAG: "Processors",
            _0: "PAYPAL",
          };
        case "paypal_test":
          return {
            TAG: "Processors",
            _0: "PAYPAL_TEST",
          };
        case "payu":
          return {
            TAG: "Processors",
            _0: "PAYU",
          };
        case "phonypay":
          return {
            TAG: "Processors",
            _0: "PHONYPAY",
          };
        case "placetopay":
          return {
            TAG: "Processors",
            _0: "PLACETOPAY",
          };
        case "powertranz":
          return {
            TAG: "Processors",
            _0: "POWERTRANZ",
          };
        case "pretendpay":
          return {
            TAG: "Processors",
            _0: "PRETENDPAY",
          };
        case "prophetpay":
          return {
            TAG: "Processors",
            _0: "PROPHETPAY",
          };
        case "rapyd":
          return {
            TAG: "Processors",
            _0: "RAPYD",
          };
        case "razorpay":
          return {
            TAG: "Processors",
            _0: "RAZORPAY",
          };
        case "shift4":
          return {
            TAG: "Processors",
            _0: "SHIFT4",
          };
        case "stax":
          return {
            TAG: "Processors",
            _0: "STAX",
          };
        case "stripe":
          return {
            TAG: "Processors",
            _0: "STRIPE",
          };
        case "stripe_test":
          return {
            TAG: "Processors",
            _0: "STRIPE_TEST",
          };
        case "trustpay":
          return {
            TAG: "Processors",
            _0: "TRUSTPAY",
          };
        case "tsys":
          return {
            TAG: "Processors",
            _0: "TSYS",
          };
        case "volt":
          return {
            TAG: "Processors",
            _0: "VOLT",
          };
        case "wise":
          return {
            TAG: "Processors",
            _0: "WISE",
          };
        case "worldline":
          return {
            TAG: "Processors",
            _0: "WORLDLINE",
          };
        case "worldpay":
          return {
            TAG: "Processors",
            _0: "WORLDPAY",
          };
        case "zen":
          return {
            TAG: "Processors",
            _0: "ZEN",
          };
        case "zsl":
          return {
            TAG: "Processors",
            _0: "ZSL",
          };
        default:
          return {
            TAG: "UnknownConnector",
            _0: "Not known",
          };
      }
    case "PayoutConnector":
      return {
        TAG: "UnknownConnector",
        _0: "Not known",
      };
    case "ThreeDsAuthenticator":
      switch (connector) {
        case "netcetera":
          return {
            TAG: "ThreeDsAuthenticator",
            _0: "NETCETERA",
          };
        case "threedsecureio":
          return {
            TAG: "ThreeDsAuthenticator",
            _0: "THREEDSECUREIO",
          };
        default:
          return {
            TAG: "UnknownConnector",
            _0: "Not known",
          };
      }
  }
}

function getProcessorInfo(connector) {
  switch (connector) {
    case "ADYEN":
      return adyenInfo;
    case "ADYENPLATFORM":
      return adyenPlatformInfo;
    case "CHECKOUT":
      return checkoutInfo;
    case "BRAINTREE":
      return braintreeInfo;
    case "BANKOFAMERICA":
      return bankOfAmericaInfo;
    case "BILLWERK":
      return billwerkInfo;
    case "AUTHORIZEDOTNET":
      return authorizedotnetInfo;
    case "STRIPE":
      return stripeInfo;
    case "KLARNA":
      return klarnaInfo;
    case "GLOBALPAY":
      return globalpayInfo;
    case "BLUESNAP":
      return bluesnapInfo;
    case "AIRWALLEX":
      return airwallexInfo;
    case "WORLDPAY":
      return worldpayInfo;
    case "CYBERSOURCE":
      return cybersourceInfo;
    case "EBANX":
      return ebanxInfo;
    case "ACI":
      return aciInfo;
    case "WORLDLINE":
      return worldlineInfo;
    case "FISERV":
      return fiservInfo;
    case "SHIFT4":
      return shift4Info;
    case "RAPYD":
      return rapydInfo;
    case "PAYU":
      return payuInfo;
    case "NUVEI":
      return nuveiInfo;
    case "DLOCAL":
      return dlocalInfo;
    case "MULTISAFEPAY":
      return multisafepayInfo;
    case "BAMBORA":
      return bamboraInfo;
    case "MOLLIE":
      return mollieInfo;
    case "TRUSTPAY":
      return trustpayInfo;
    case "ZEN":
      return zenInfo;
    case "PAYPAL":
      return paypalInfo;
    case "COINBASE":
      return coinbaseInfo;
    case "OPENNODE":
      return openNodeInfo;
    case "PHONYPAY":
      return phonypayInfo;
    case "FAUXPAY":
      return fauxpayInfo;
    case "PRETENDPAY":
      return pretendpayInfo;
    case "NMI":
      return nmiInfo;
    case "FORTE":
      return forteInfo;
    case "NEXINETS":
      return nexinetsInfo;
    case "IATAPAY":
      return iataPayInfo;
    case "BITPAY":
      return bitPayInfo;
    case "CRYPTOPAY":
      return cryptopayInfo;
    case "CASHTOCODE":
      return cashToCodeInfo;
    case "PAYME":
      return paymeInfo;
    case "GLOBEPAY":
      return globepayInfo;
    case "POWERTRANZ":
      return powertranzInfo;
    case "TSYS":
      return tsysInfo;
    case "NOON":
      return noonInfo;
    case "STRIPE_TEST":
      return stripeTestInfo;
    case "PAYPAL_TEST":
      return paypalTestInfo;
    case "STAX":
      return staxInfo;
    case "WISE":
      return wiseInfo;
    case "GOCARDLESS":
      return goCardLessInfo;
    case "VOLT":
      return voltInfo;
    case "PROPHETPAY":
      return prophetpayInfo;
    case "HELCIM":
      return helcimInfo;
    case "PLACETOPAY":
      return placetopayInfo;
    case "ZSL":
      return zslInfo;
    case "MIFINITY":
      return mifinityInfo;
    case "RAZORPAY":
      return razorpayInfo;
    case "BAMBORA_APAC":
      return bamboraApacInfo;
    case "ITAUBANK":
      return itauBankInfo;
    case "DATATRANS":
      return dataTransInfo;
  }
}

function getThreedsAuthenticatorInfo(threeDsAuthenticator) {
  if (threeDsAuthenticator === "THREEDSECUREIO") {
    return threedsecuredotioInfo;
  } else {
    return netceteraInfo;
  }
}

function getFrmInfo(frm) {
  if (frm === "Signifyd") {
    return signifydInfo;
  } else {
    return riskifyedInfo;
  }
}

function getConnectorInfo(connector) {
  switch (connector.TAG) {
    case "Processors":
      return getProcessorInfo(connector._0);
    case "ThreeDsAuthenticator":
      return getThreedsAuthenticatorInfo(connector._0);
    case "FRM":
      return getFrmInfo(connector._0);
    case "UnknownConnector":
      return unknownConnectorInfo;
  }
}

function acceptedValues(dict) {
  var values_type = LogicUtils.getString(dict, "type", "enable_only");
  var values_list = LogicUtils.getStrArray(dict, "list");
  var values = {
    type: values_type,
    list: values_list,
  };
  if (values_list.length > 0) {
    return values;
  }
}

function itemProviderMapper(dict) {
  return {
    payment_method_type: LogicUtils.getString(dict, "payment_method_type", ""),
    card_networks: LogicUtils.getStrArrayFromDict(dict, "card_networks", []),
    accepted_currencies: acceptedValues(
      LogicUtils.getDictfromDict(dict, "accepted_currencies"),
    ),
    accepted_countries: acceptedValues(
      LogicUtils.getDictfromDict(dict, "accepted_countries"),
    ),
    minimum_amount: LogicUtils.getOptionInt(dict, "minimum_amount"),
    maximum_amount: LogicUtils.getOptionInt(dict, "maximum_amount"),
    recurring_enabled: LogicUtils.getOptionBool(dict, "recurring_enabled"),
    installment_payment_enabled: LogicUtils.getOptionBool(
      dict,
      "installment_payment_enabled",
    ),
    payment_experience: LogicUtils.getOptionString(dict, "payment_experience"),
  };
}

function getPaymentMethodMapper(json) {
  return LogicUtils.getArrayDataFromJson(json, itemProviderMapper);
}

function itemToObjMapper(dict) {
  var json = LogicUtils.getArrayFromDict(dict, "provider", []);
  var json$1 = LogicUtils.getArrayFromDict(dict, "card_provider", []);
  return {
    payment_method: LogicUtils.getString(dict, "payment_method", ""),
    payment_method_type: LogicUtils.getString(dict, "payment_method_type", ""),
    provider: LogicUtils.getArrayDataFromJson(json, itemProviderMapper),
    card_provider: LogicUtils.getArrayDataFromJson(json$1, itemProviderMapper),
  };
}

function getPaymentMethodEnabled(json) {
  return LogicUtils.getArrayDataFromJson(json, itemToObjMapper);
}

var connectorIgnoredField = [
  "business_country",
  "business_label",
  "business_sub_label",
  "merchant_connector_id",
  "connector_name",
  "profile_id",
  "applepay_verified_domains",
];

var configKeysToIgnore = [
  "connector_auth",
  "is_verifiable",
  "metadata",
  "connector_webhook_details",
];

var verifyConnectorIgnoreField = [
  "business_country",
  "business_label",
  "business_sub_label",
  "merchant_connector_id",
  "applepay_verified_domains",
];

function ignoreFields(json, id, fields) {
  if (id.length <= 0 || id === "new") {
    return json;
  } else {
    return LogicUtils.getJsonFromArrayOfJson(
      Object.entries(LogicUtils.getDictFromJsonObject(json)).filter(
        function (entry) {
          return !fields.includes(entry[0]);
        },
      ),
    );
  }
}

function mapAuthType(authType) {
  var match = authType.toLowerCase();
  switch (match) {
    case "bodykey":
      return "BodyKey";
    case "currencyauthkey":
      return "CurrencyAuthKey";
    case "headerkey":
      return "HeaderKey";
    case "multiauthkey":
      return "MultiAuthKey";
    case "signaturekey":
      return "SignatureKey";
    case "temporaryauth":
      return "TemporaryAuth";
    default:
      return "Nokey";
  }
}

function getConnectorType(connector, isPayoutFlow, param) {
  if (isPayoutFlow) {
    return "payout_processor";
  }
  switch (connector.TAG) {
    case "ThreeDsAuthenticator":
      return "authentication_processor";
    case "Processors":
    case "FRM":
      return "payment_processor";
    case "UnknownConnector":
      return connector._0;
  }
}

function getSelectedPaymentObj(paymentMethodsEnabled, paymentMethod) {
  return Core__Option.getOr(
    paymentMethodsEnabled.find(function (item) {
      return (
        item.payment_method_type.toLowerCase() === paymentMethod.toLowerCase()
      );
    }),
    {
      payment_method: "unknown",
      payment_method_type: "unkonwn",
    },
  );
}

function addMethod(paymentMethodsEnabled, paymentMethod, method) {
  var pmts = paymentMethodsEnabled.slice();
  var match = getPaymentMethodFromString(paymentMethod);
  var exit = 0;
  if (typeof match !== "object" && match === "Card") {
    pmts.forEach(function (val) {
      if (
        val.payment_method_type.toLowerCase() === paymentMethod.toLowerCase()
      ) {
        Core__Option.getOr(
          val.card_provider,
          LogicUtils.getArrayDataFromJson([], itemProviderMapper),
        ).push(method);
        return;
      }
    });
  } else {
    exit = 1;
  }
  if (exit === 1) {
    pmts.forEach(function (val) {
      if (
        val.payment_method_type.toLowerCase() === paymentMethod.toLowerCase()
      ) {
        Core__Option.getOr(
          val.provider,
          LogicUtils.getArrayDataFromJson([], itemProviderMapper),
        ).push(method);
        return;
      }
    });
  }
  return pmts;
}

function removeMethod(paymentMethodsEnabled, paymentMethod, method, connector) {
  var pmts = paymentMethodsEnabled.slice();
  var match = getPaymentMethodTypeFromString(method.payment_method_type);
  var match$1 = getPaymentMethodFromString(paymentMethod);
  var match$2 = getConnectorNameTypeFromString(connector, undefined, undefined);
  var exit = 0;
  var exit$1 = 0;
  if (typeof match !== "object" && match === "PayPal") {
    if (typeof match$1 !== "object") {
      switch (match$1) {
        case "Card":
          exit$1 = 2;
          break;
        case "Wallet":
          if (match$2.TAG === "Processors" && match$2._0 === "PAYPAL") {
            pmts.forEach(function (val) {
              if (
                val.payment_method_type.toLowerCase() !==
                paymentMethod.toLowerCase()
              ) {
                return;
              }
              var indexOfRemovalItem = Core__Option.getOr(
                val.provider,
                LogicUtils.getArrayDataFromJson([], itemProviderMapper),
              )
                .map(function (ele) {
                  return ele.payment_experience;
                })
                .indexOf(method.payment_experience);
              Caml_splice_call.spliceObjApply(
                Core__Option.getOr(
                  val.provider,
                  LogicUtils.getArrayDataFromJson([], itemProviderMapper),
                ),
                "splice",
                [
                  indexOfRemovalItem,
                  1,
                  LogicUtils.getArrayDataFromJson([], itemProviderMapper),
                ],
              );
            });
          } else {
            exit = 1;
          }
          break;
        default:
          exit = 1;
      }
    } else {
      exit = 1;
    }
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    if (typeof match$1 !== "object" && match$1 === "Card") {
      pmts.forEach(function (val) {
        if (
          val.payment_method_type.toLowerCase() !== paymentMethod.toLowerCase()
        ) {
          return;
        }
        var indexOfRemovalItem = Core__Option.getOr(
          val.card_provider,
          LogicUtils.getArrayDataFromJson([], itemProviderMapper),
        )
          .map(function (ele) {
            return ele.payment_method_type;
          })
          .indexOf(method.payment_method_type);
        Caml_splice_call.spliceObjApply(
          Core__Option.getOr(
            val.card_provider,
            LogicUtils.getArrayDataFromJson([], itemProviderMapper),
          ),
          "splice",
          [
            indexOfRemovalItem,
            1,
            LogicUtils.getArrayDataFromJson([], itemProviderMapper),
          ],
        );
      });
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    pmts.forEach(function (val) {
      if (
        val.payment_method_type.toLowerCase() !== paymentMethod.toLowerCase()
      ) {
        return;
      }
      var indexOfRemovalItem = Core__Option.getOr(
        val.provider,
        LogicUtils.getArrayDataFromJson([], itemProviderMapper),
      )
        .map(function (ele) {
          return ele.payment_method_type;
        })
        .indexOf(method.payment_method_type);
      Caml_splice_call.spliceObjApply(
        Core__Option.getOr(
          val.provider,
          LogicUtils.getArrayDataFromJson([], itemProviderMapper),
        ),
        "splice",
        [
          indexOfRemovalItem,
          1,
          LogicUtils.getArrayDataFromJson([], itemProviderMapper),
        ],
      );
    });
  }
  return pmts;
}

function generateInitialValuesDict(
  values,
  connector,
  bodyType,
  isPayoutFlowOpt,
  isLiveModeOpt,
  connectorTypeOpt,
  param,
) {
  var isPayoutFlow = isPayoutFlowOpt !== undefined ? isPayoutFlowOpt : false;
  var isLiveMode = isLiveModeOpt !== undefined ? isLiveModeOpt : false;
  var connectorType =
    connectorTypeOpt !== undefined ? connectorTypeOpt : "Processor";
  var dict = LogicUtils.getDictFromJsonObject(values);
  var connectorAccountDetails = LogicUtils.getDictFromJsonObject(
    LogicUtils.getJsonObjectFromDict(dict, "connector_account_details"),
  );
  connectorAccountDetails["auth_type"] = bodyType;
  dict["connector_account_details"] = connectorAccountDetails;
  dict["connector_name"] = connector;
  dict["connector_type"] = getConnectorType(
    getConnectorNameTypeFromString(connector, connectorType, undefined),
    isPayoutFlow,
    undefined,
  );
  dict["disabled"] = LogicUtils.getBool(dict, "disabled", false);
  dict["test_mode"] = isLiveMode ? false : true;
  dict["connector_label"] = LogicUtils.getString(dict, "connector_label", "");
  var connectorWebHookDetails = LogicUtils.getDictFromJsonObject(
    LogicUtils.getJsonObjectFromDict(dict, "connector_webhook_details"),
  );
  dict["connector_webhook_details"] = Core__Option.isSome(
    LogicUtils.getOptionString(connectorWebHookDetails, "merchant_secret"),
  )
    ? connectorWebHookDetails
    : null;
  return dict;
}

function getDisableConnectorPayload(connectorType, previousConnectorState) {
  return Object.fromEntries([
    ["connector_type", connectorType],
    ["disabled", !previousConnectorState],
  ]);
}

function getWebHookRequiredFields(connector, fieldName) {
  if (
    connector.TAG === "Processors" &&
    connector._0 === "ADYEN" &&
    fieldName === "merchant_secret"
  ) {
    return true;
  } else {
    return false;
  }
}

function getAuthKeyMapFromConnectorAccountFields(connectorAccountFields) {
  var authKeyMap = LogicUtils.getDictfromDict(
    connectorAccountFields,
    "auth_key_map",
  );
  return LogicUtils.convertMapObjectToDict(authKeyMap);
}

function checkCashtoCodeFields(keys, country, valuesFlattenJson) {
  return keys.map(function (field) {
    var key = "connector_account_details.auth_key_map." + country + "." + field;
    var value = LogicUtils.getString(valuesFlattenJson, key, "");
    return value.length !== 0;
  });
}

function checkCashtoCodeInnerField(valuesFlattenJson, dict, country) {
  var value = Object.keys(LogicUtils.getDictfromDict(dict, country));
  var result = value.map(function (method) {
    var keys = Object.keys(
      LogicUtils.getDictfromDict(
        LogicUtils.getDictfromDict(dict, country),
        method,
      ),
    );
    if (
      checkCashtoCodeFields(keys, country, valuesFlattenJson).includes(false)
    ) {
      return false;
    } else {
      return true;
    }
  });
  return result.includes(true);
}

function validateConnectorRequiredFields(
  connector,
  valuesFlattenJson,
  connectorAccountFields,
  connectorMetaDataFields,
  connectorWebHookDetails,
  connectorLabelDetailField,
  errors,
) {
  var newDict = LogicUtils.getDictFromJsonObject(errors);
  var exit = 0;
  if (connector.TAG === "Processors" && connector._0 === "CASHTOCODE") {
    var dict = getAuthKeyMapFromConnectorAccountFields(connectorAccountFields);
    var indexLength = Object.keys(dict).length;
    var vector = Caml_array.make(indexLength, false);
    Object.keys(dict).forEach(function (country, index) {
      var res = checkCashtoCodeInnerField(valuesFlattenJson, dict, country);
      Caml_array.set(vector, index, res);
    });
    Js_vector.filterInPlace(function (val) {
      return val === true;
    }, vector);
    if (vector.length === 0) {
      newDict["Currency"] = "Please enter currency";
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    Object.keys(connectorAccountFields).forEach(function (value) {
      var key = "connector_account_details." + value;
      var errorKey = LogicUtils.getString(connectorAccountFields, value, "");
      var value$1 = LogicUtils.getString(
        valuesFlattenJson,
        "connector_account_details." + value,
        "",
      );
      if (value$1.length === 0) {
        newDict[key] = "Please enter " + errorKey;
        return;
      }
    });
  }
  var keys = Object.keys(connectorMetaDataFields).filter(function (ele) {
    return !ConnectorMetaDataUtils.metaDataInputKeysToIgnore.includes(ele);
  });
  keys.forEach(function (field) {
    var match = CommonMetaDataUtils.inputFieldMapper(
      LogicUtils.convertMapObjectToDict(
        LogicUtils.getDictfromDict(connectorMetaDataFields, field),
      ),
    );
    var key = "metadata." + match.name;
    var value;
    var exit = 0;
    switch (match.type) {
      case "Toggle":
        value = LogicUtils.getStringFromBool(
          LogicUtils.getBool(valuesFlattenJson, key, false),
        );
        break;
      case "Text":
      case "Select":
        exit = 1;
        break;
      case "Radio":
      case "MultiSelect":
        value = "";
        break;
    }
    if (exit === 1) {
      value = LogicUtils.getString(valuesFlattenJson, key, "");
    }
    if (value.length === 0 && match.required) {
      newDict[key] = "Please enter " + match.label;
      return;
    }
  });
  Object.keys(connectorWebHookDetails).forEach(function (fieldName) {
    var key = "connector_webhook_details." + fieldName;
    var errorKey = LogicUtils.getString(connectorWebHookDetails, fieldName, "");
    var value = LogicUtils.getString(
      valuesFlattenJson,
      "connector_webhook_details." + fieldName,
      "",
    );
    if (value.length === 0 && getWebHookRequiredFields(connector, fieldName)) {
      newDict[key] = "Please enter " + errorKey;
      return;
    }
  });
  Object.keys(connectorLabelDetailField).forEach(function (fieldName) {
    var errorKey = LogicUtils.getString(
      connectorLabelDetailField,
      fieldName,
      "",
    );
    var value = LogicUtils.getString(valuesFlattenJson, fieldName, "");
    if (value.length === 0) {
      newDict[fieldName] = "Please enter " + errorKey;
      return;
    }
  });
  return newDict;
}

function getPlaceHolder(label) {
  return "Enter " + LogicUtils.snakeToTitle(label);
}

function getConnectorDetailsValue(connectorInfo, str) {
  switch (str) {
    case "api_key":
      return connectorInfo.connector_account_details.api_key;
    case "api_secret":
      return connectorInfo.connector_account_details.api_secret;
    case "auth_type":
      return connectorInfo.connector_account_details.auth_type;
    case "key1":
      return connectorInfo.connector_account_details.key1;
    case "key2":
      return connectorInfo.connector_account_details.key2;
    default:
      return "";
  }
}

var connectorLabelDetailField = Object.fromEntries([
  ["connector_label", "Connector label"],
]);

function getConnectorFields(connectorDetails) {
  var connectorAccountDict = LogicUtils.getDictfromDict(
    LogicUtils.getDictFromJsonObject(connectorDetails),
    "connector_auth",
  );
  var bodyType = Core__Option.getOr(Object.keys(connectorAccountDict)[0], "");
  var connectorAccountFields = LogicUtils.getDictfromDict(
    connectorAccountDict,
    bodyType,
  );
  var connectorMetaDataFields = LogicUtils.getDictfromDict(
    LogicUtils.getDictFromJsonObject(connectorDetails),
    "metadata",
  );
  var isVerifyConnector = LogicUtils.getBool(
    LogicUtils.getDictFromJsonObject(connectorDetails),
    "is_verifiable",
    false,
  );
  var connectorWebHookDetails = LogicUtils.getDictfromDict(
    LogicUtils.getDictFromJsonObject(connectorDetails),
    "connector_webhook_details",
  );
  return [
    bodyType,
    connectorAccountFields,
    connectorMetaDataFields,
    isVerifyConnector,
    connectorWebHookDetails,
    connectorLabelDetailField,
  ];
}

function validateRequiredFiled(valuesFlattenJson, dict, fieldName, errors) {
  var newDict = LogicUtils.getDictFromJsonObject(errors);
  Object.keys(dict).forEach(function (_value) {
    var lastItem = Core__Option.getOr(fieldName.split(".").pop(), "");
    var errorKey = LogicUtils.getString(dict, lastItem, "");
    var value = LogicUtils.getString(valuesFlattenJson, fieldName, "");
    if (value.length === 0) {
      newDict[fieldName] = "Please enter " + errorKey;
      return;
    }
  });
  return newDict;
}

function validate(selectedConnector, dict, fieldName, isLiveMode) {
  return function (values) {
    var errors = {};
    var valuesFlattenJson = JsonFlattenUtils.flattenObject(values, true);
    var labelArr = Object.values(dict);
    Core__Option.getOr(selectedConnector.validate, []).forEach(
      function (field, index) {
        var key = field.name;
        var value = LogicUtils.getStringFromJson(
          Core__Option.getOr(valuesFlattenJson[key], ""),
          "",
        );
        var regexToUse = isLiveMode
          ? field.liveValidationRegex
          : field.testValidationRegex;
        var validationResult =
          regexToUse !== undefined ? new RegExp(regexToUse).test(value) : true;
        if (Core__Option.getOr(field.isRequired, true) && value.length === 0) {
          var errorLabel = LogicUtils.getStringFromJson(
            Core__Option.getOr(labelArr[index], ""),
            "",
          );
          errors[key] = "Please enter " + errorLabel;
          return;
        }
        if (!(!validationResult && value.length !== 0)) {
          return;
        }
        var expectedFormat = isLiveMode
          ? field.liveExpectedFormat
          : field.testExpectedFormat;
        var warningMessage = Core__Option.getOr(expectedFormat, "");
        errors[key] = warningMessage;
      },
    );
    var profileId = LogicUtils.getString(valuesFlattenJson, "profile_id", "");
    if (profileId.length === 0) {
      errors["Profile Id"] = "Please select your business profile";
    }
    return validateRequiredFiled(valuesFlattenJson, dict, fieldName, errors);
  };
}

function getSuggestedAction(verifyErrorMessage, connector) {
  var msg = Core__Option.getOr(verifyErrorMessage, "");
  var match = getConnectorNameTypeFromString(connector, undefined, undefined);
  var match$1;
  if (match.TAG === "Processors") {
    switch (match._0) {
      case "STRIPE":
        match$1 = [
          msg.includes("Sending credit card numbers directly")
            ? React.createElement(
                SuggestedActionHelper.StripSendingCreditCard.make,
                {},
              )
            : msg.includes("Invalid API Key")
              ? React.createElement(
                  SuggestedActionHelper.StripeInvalidAPIKey.make,
                  {},
                )
              : null,
          true,
        ];
        break;
      case "PAYPAL":
        match$1 = [
          msg.includes("Client Authentication failed")
            ? React.createElement(
                SuggestedActionHelper.PaypalClientAuthenticationFalied.make,
                {},
              )
            : null,
          true,
        ];
        break;
      default:
        match$1 = [null, false];
    }
  } else {
    match$1 = [null, false];
  }
  return [match$1[0], match$1[1]];
}

async function onSubmit(
  values,
  onSubmitVerify,
  onSubmitMain,
  setVerifyDone,
  verifyDone,
  isVerifyConnector,
) {
  setVerifyDone(function (param) {
    return "Loading";
  });
  if (verifyDone === "NoAttempt" && isVerifyConnector) {
    onSubmitVerify(values);
  } else {
    onSubmitMain(values);
  }
  return null;
}

function getWebhooksUrl(connectorName, merchantId) {
  return (
    window._env_.apiBaseUrl + "/webhooks/" + merchantId + "/" + connectorName
  );
}

function constructConnectorRequestBody(wasmRequest, payload) {
  var dict = LogicUtils.getDictFromJsonObject(payload);
  var connectorAccountDetails = LogicUtils.getDictfromDict(
    dict,
    "connector_account_details",
  );
  var payLoadDetails_profile_id = LogicUtils.getString(dict, "profile_id", "");
  var payLoadDetails_connector_type = LogicUtils.getString(
    dict,
    "connector_type",
    "",
  );
  var payLoadDetails_connector_name = LogicUtils.getString(
    dict,
    "connector_name",
    "",
  );
  var payLoadDetails_disabled = LogicUtils.getBool(dict, "disabled", false);
  var payLoadDetails_test_mode = LogicUtils.getBool(dict, "test_mode", false);
  var payLoadDetails_connector_webhook_details = LogicUtils.isEmptyDict(
    LogicUtils.getDictfromDict(dict, "connector_webhook_details"),
  )
    ? undefined
    : LogicUtils.getDictfromDict(dict, "connector_webhook_details");
  var payLoadDetails = {
    profile_id: payLoadDetails_profile_id,
    connector_type: payLoadDetails_connector_type,
    connector_name: payLoadDetails_connector_name,
    connector_account_details: connectorAccountDetails,
    disabled: payLoadDetails_disabled,
    test_mode: payLoadDetails_test_mode,
    connector_webhook_details: payLoadDetails_connector_webhook_details,
  };
  var values = getRequestPayload(wasmRequest, payLoadDetails);
  var dict$1 = Object.fromEntries([
    ["connector_account_details", connectorAccountDetails],
    ["connector_label", LogicUtils.getString(dict, "connector_label", "")],
    ["status", LogicUtils.getString(dict, "status", "active")],
  ]);
  return Object.fromEntries(
    Object.entries(LogicUtils.getDictFromJsonObject(values)).concat(
      Object.entries(dict$1),
    ),
  );
}

function defaultSelectAllCards(
  pmts,
  isUpdateFlow,
  isPayoutFlow,
  connector,
  updateDetails,
) {
  if (isUpdateFlow) {
    return;
  }
  var config = LogicUtils.getDictFromJsonObject(
    isPayoutFlow
      ? window.getPayoutConnectorConfig(connector)
      : window.getConnectorConfig(connector),
  );
  pmts.forEach(function (val) {
    var match = getPaymentMethodFromString(val.payment_method);
    if (typeof match === "object") {
      return;
    }
    switch (match) {
      case "Card":
        var json = LogicUtils.getArrayFromDict(
          config,
          val.payment_method_type,
          [],
        );
        var arr = LogicUtils.getArrayDataFromJson(json, itemProviderMapper);
        var length = Core__Option.getOr(
          val.card_provider,
          LogicUtils.getArrayDataFromJson([], itemProviderMapper),
        ).length;
        Caml_splice_call.spliceObjApply(
          Core__Option.getOr(
            val.card_provider,
            LogicUtils.getArrayDataFromJson([], itemProviderMapper),
          ),
          "splice",
          [0, length, arr],
        );
        return;
      case "BankRedirect":
      case "BankTransfer":
        break;
      default:
        return;
    }
    var json$1 = LogicUtils.getArrayFromDict(
      config,
      val.payment_method_type,
      [],
    );
    var arr$1 = LogicUtils.getArrayDataFromJson(json$1, itemProviderMapper);
    var length$1 = Core__Option.getOr(
      val.provider,
      LogicUtils.getArrayDataFromJson([], itemProviderMapper),
    ).length;
    Caml_splice_call.spliceObjApply(
      Core__Option.getOr(
        val.provider,
        LogicUtils.getArrayDataFromJson([], itemProviderMapper),
      ),
      "splice",
      [0, length$1, arr$1],
    );
  });
  updateDetails(pmts);
}

async function getConnectorPaymentMethodDetails(
  initialValues,
  setPaymentMethods,
  setMetaData,
  isUpdateFlow,
  isPayoutFlow,
  connector,
  updateDetails,
) {
  try {
    var json = window.getResponsePayload(initialValues);
    var metaData = LogicUtils.getJsonObjectFromDict(
      LogicUtils.getDictFromJsonObject(json),
      "metadata",
    );
    var json$1 = LogicUtils.getJsonObjectFromDict(
      LogicUtils.getDictFromJsonObject(json),
      "payment_methods_enabled",
    );
    var paymentMethodEnabled = LogicUtils.getArrayDataFromJson(
      json$1,
      itemToObjMapper,
    );
    setPaymentMethods(function (param) {
      return paymentMethodEnabled;
    });
    setMetaData(function (param) {
      return metaData;
    });
    return defaultSelectAllCards(
      paymentMethodEnabled,
      isUpdateFlow,
      isPayoutFlow,
      connector,
      updateDetails,
    );
  } catch (raw_e) {
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === Js_exn.$$Error) {
      return Js_exn.raiseError(
        Core__Option.getOr(e._1.message, "Something went wrong"),
      );
    }
    throw e;
  }
}

function filterList(items, removeFromList) {
  return items.filter(function (dict) {
    var connectorType = dict.connector_type;
    var isPayoutConnector = connectorType === "payout_processor";
    var isThreeDsAuthenticator = connectorType === "authentication_processor";
    var isConnector =
      connectorType !== "payment_vas" &&
      !isPayoutConnector &&
      !isThreeDsAuthenticator;
    switch (removeFromList) {
      case "FRMPlayer":
        return isConnector;
      case "Processor":
        return !isConnector;
      case "PayoutConnector":
        return isPayoutConnector;
      case "ThreeDsAuthenticator":
        return isThreeDsAuthenticator;
    }
  });
}

function getProcessorsListFromJson(connnectorList, removeFromListOpt, param) {
  var removeFromList =
    removeFromListOpt !== undefined ? removeFromListOpt : "FRMPlayer";
  return filterList(connnectorList, removeFromList);
}

function getDisplayNameForProcessor(connector) {
  switch (connector) {
    case "ADYEN":
      return "Adyen";
    case "ADYENPLATFORM":
      return "Adyen Platform";
    case "CHECKOUT":
      return "Checkout";
    case "BRAINTREE":
      return "Braintree";
    case "BANKOFAMERICA":
      return "Bank of America";
    case "BILLWERK":
      return "Billwerk";
    case "AUTHORIZEDOTNET":
      return "Authorize.net";
    case "STRIPE":
      return "Stripe";
    case "KLARNA":
      return "Klarna";
    case "GLOBALPAY":
      return "Global Payments";
    case "BLUESNAP":
      return "Bluesnap";
    case "AIRWALLEX":
      return "Airwallex";
    case "WORLDPAY":
      return "Worldpay";
    case "CYBERSOURCE":
      return "Cybersource";
    case "EBANX":
      return "Ebanx";
    case "ACI":
      return "ACI Worldwide";
    case "WORLDLINE":
      return "Worldline";
    case "FISERV":
      return "Fiserv";
    case "SHIFT4":
      return "Shift4";
    case "RAPYD":
      return "Rapyd";
    case "PAYU":
      return "PayU";
    case "NUVEI":
      return "Nuvei";
    case "DLOCAL":
      return "dLocal";
    case "MULTISAFEPAY":
      return "MultiSafepay";
    case "BAMBORA":
      return "Bambora";
    case "MOLLIE":
      return "Mollie";
    case "TRUSTPAY":
      return "TrustPay";
    case "ZEN":
      return "Zen";
    case "PAYPAL":
      return "PayPal";
    case "COINBASE":
      return "Coinbase";
    case "OPENNODE":
      return "Opennode";
    case "PHONYPAY":
      return "Phony Pay";
    case "FAUXPAY":
      return "Fauxpay";
    case "PRETENDPAY":
      return "Pretendpay";
    case "NMI":
      return "NMI";
    case "FORTE":
      return "Forte";
    case "NEXINETS":
      return "Nexinets";
    case "IATAPAY":
      return "IATA Pay";
    case "BITPAY":
      return "Bitpay";
    case "CRYPTOPAY":
      return "Cryptopay";
    case "CASHTOCODE":
      return "CashtoCode";
    case "PAYME":
      return "PayMe";
    case "GLOBEPAY":
      return "GlobePay";
    case "POWERTRANZ":
      return "Powertranz";
    case "TSYS":
      return "TSYS";
    case "NOON":
      return "Noon";
    case "STRIPE_TEST":
      return "Stripe Dummy";
    case "PAYPAL_TEST":
      return "Paypal Dummy";
    case "STAX":
      return "Stax";
    case "WISE":
      return "Wise";
    case "GOCARDLESS":
      return "GoCardless";
    case "VOLT":
      return "Volt";
    case "PROPHETPAY":
      return "Prophet Pay";
    case "HELCIM":
      return "Helcim";
    case "PLACETOPAY":
      return "Placetopay";
    case "ZSL":
      return "ZSL";
    case "MIFINITY":
      return "MiFinity";
    case "RAZORPAY":
      return "Razorpay";
    case "BAMBORA_APAC":
      return "Bambora Apac";
    case "ITAUBANK":
      return "Itaubank";
    case "DATATRANS":
      return "Datatrans";
  }
}

function getDisplayNameForThreedsAuthenticator(threeDsAuthenticator) {
  if (threeDsAuthenticator === "THREEDSECUREIO") {
    return "3dsecure.io";
  } else {
    return "Netcetera";
  }
}

function getDisplayNameForFRMConnector(frmConnector) {
  if (frmConnector === "Signifyd") {
    return "Signifyd";
  } else {
    return "Riskified";
  }
}

function getDisplayNameForConnector(connectorTypeOpt, connector) {
  var connectorType =
    connectorTypeOpt !== undefined ? connectorTypeOpt : "Processor";
  var connectorType$1 = getConnectorNameTypeFromString(
    connector.toLowerCase(),
    connectorType,
    undefined,
  );
  switch (connectorType$1.TAG) {
    case "Processors":
      return getDisplayNameForProcessor(connectorType$1._0);
    case "ThreeDsAuthenticator":
      return getDisplayNameForThreedsAuthenticator(connectorType$1._0);
    case "FRM":
      return getDisplayNameForFRMConnector(connectorType$1._0);
    case "UnknownConnector":
      return connectorType$1._0;
  }
}

function getConnectorTypeArrayFromListConnectors(
  connectorTypeOpt,
  connectorsList,
) {
  var connectorType =
    connectorTypeOpt !== undefined ? connectorTypeOpt : "Processor";
  return connectorsList.map(function (connectorDetail) {
    return getConnectorNameTypeFromString(
      connectorDetail.connector_name,
      connectorType,
      undefined,
    );
  });
}

function connectorTypeStringToTypeMapper(connector_type) {
  switch (connector_type) {
    case "authentication_processor":
      return "AuthenticationProcessor";
    case "payment_vas":
      return "PaymentVas";
    case "payout_processor":
      return "PayoutProcessor";
    default:
      return "PaymentProcessor";
  }
}

function sortByName(c1, c2) {
  return LogicUtils.compareLogic(
    getConnectorNameString(c2),
    getConnectorNameString(c1),
  );
}

function existsInArray(element, connectorList) {
  return connectorList.some(function (e) {
    if (e.TAG === "Processors" && element.TAG === "Processors") {
      return e._0 === element._0;
    } else {
      return false;
    }
  });
}

function updateMetaData(metaData) {
  var apple_pay_combined = LogicUtils.getDictfromDict(
    LogicUtils.getDictFromJsonObject(metaData),
    "apple_pay_combined",
  );
  var manual = LogicUtils.getDictfromDict(apple_pay_combined, "manual");
  if (Object.keys(manual).length <= 0) {
    return;
  }
  var applepay = LogicUtils.convertMapObjectToDict(
    LogicUtils.getDictfromDict(manual, "session_token_data"),
  );
  manual["session_token_data"] = applepay;
}

export {
  stepsArr,
  payoutStepsArr,
  getStepName,
  payoutConnectorList,
  threedsAuthenticatorList,
  connectorList,
  connectorListForLive,
  connectorListWithAutomaticFlow,
  getPaymentMethodFromString,
  getPaymentMethodTypeFromString,
  dummyConnectorList,
  checkIsDummyConnector,
  stripeInfo,
  goCardLessInfo,
  adyenInfo,
  adyenPlatformInfo,
  checkoutInfo,
  braintreeInfo,
  klarnaInfo,
  authorizedotnetInfo,
  globalpayInfo,
  bluesnapInfo,
  airwallexInfo,
  worldpayInfo,
  cybersourceInfo,
  ebanxInfo,
  aciInfo,
  worldlineInfo,
  fiservInfo,
  shift4Info,
  rapydInfo,
  payuInfo,
  nuveiInfo,
  dlocalInfo,
  multisafepayInfo,
  bamboraInfo,
  zenInfo,
  mollieInfo,
  trustpayInfo,
  paypalInfo,
  coinbaseInfo,
  openNodeInfo,
  nmiInfo,
  iataPayInfo,
  bitPayInfo,
  nexinetsInfo,
  forteInfo,
  cryptopayInfo,
  cashToCodeInfo,
  powertranzInfo,
  paymeInfo,
  globepayInfo,
  tsysInfo,
  noonInfo,
  pretendpayInfo,
  fauxpayInfo,
  phonypayInfo,
  stripeTestInfo,
  paypalTestInfo,
  wiseInfo,
  staxInfo,
  voltInfo,
  prophetpayInfo,
  helcimInfo,
  threedsecuredotioInfo,
  netceteraInfo,
  unknownConnectorInfo,
  bankOfAmericaInfo,
  placetopayInfo,
  billwerkInfo,
  mifinityInfo,
  zslInfo,
  razorpayInfo,
  bamboraApacInfo,
  itauBankInfo,
  dataTransInfo,
  signifydInfo,
  riskifyedInfo,
  getThreeDsAuthenticatorNameString,
  getFRMNameString,
  getConnectorNameString,
  getConnectorNameTypeFromString,
  getProcessorInfo,
  getThreedsAuthenticatorInfo,
  getFrmInfo,
  getConnectorInfo,
  acceptedValues,
  itemProviderMapper,
  getPaymentMethodMapper,
  itemToObjMapper,
  getPaymentMethodEnabled,
  connectorIgnoredField,
  configKeysToIgnore,
  verifyConnectorIgnoreField,
  ignoreFields,
  mapAuthType,
  getConnectorType,
  getSelectedPaymentObj,
  addMethod,
  removeMethod,
  generateInitialValuesDict,
  getDisableConnectorPayload,
  getWebHookRequiredFields,
  getAuthKeyMapFromConnectorAccountFields,
  checkCashtoCodeFields,
  checkCashtoCodeInnerField,
  validateConnectorRequiredFields,
  getPlaceHolder,
  getConnectorDetailsValue,
  connectorLabelDetailField,
  getConnectorFields,
  validateRequiredFiled,
  validate,
  getSuggestedAction,
  onSubmit,
  getWebhooksUrl,
  constructConnectorRequestBody,
  defaultSelectAllCards,
  getConnectorPaymentMethodDetails,
  filterList,
  getProcessorsListFromJson,
  getDisplayNameForProcessor,
  getDisplayNameForThreedsAuthenticator,
  getDisplayNameForFRMConnector,
  getDisplayNameForConnector,
  getConnectorTypeArrayFromListConnectors,
  connectorTypeStringToTypeMapper,
  sortByName,
  existsInArray,
  updateMetaData,
};
/* connectorLabelDetailField Not a pure module */
