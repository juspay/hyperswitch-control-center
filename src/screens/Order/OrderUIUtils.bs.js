// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Icon from "../../components/Icon.bs.js";
import * as React from "react";
import * as ACLDiv from "../../components/ACLDiv.bs.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Recoil from "recoil";
import * as APIUtils from "../APIUtils/APIUtils.bs.js";
import * as RenderIf from "../../utils/RenderIf.bs.js";
import * as ACLButton from "../../components/ACLButton.bs.js";
import * as Accordion from "../../components/Accordion.bs.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as PopUpState from "../../hooks/PopUpState.bs.js";
import * as ToastState from "../../hooks/ToastState.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.js";
import * as InputFields from "../../components/InputFields.bs.js";
import * as OrderEntity from "./OrderEntity.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as FormRenderer from "../../components/form/FormRenderer.bs.js";
import * as MixpanelHook from "../MixpanelHook.bs.js";
import * as FilterSelectBox from "../../components/FilterSelectBox.bs.js";
import * as HyperswitchAtom from "../../Recoils/HyperswitchAtom.bs.js";
import * as HelperComponents from "../Helpers/HelperComponents.bs.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function getFilterTypeFromString(filterType) {
  switch (filterType) {
    case "authentication_type":
      return "authentication_type";
    case "connector":
      return "connector";
    case "connector_label":
      return "connector_label";
    case "currency":
      return "currency";
    case "payment_method":
      return "payment_method";
    case "payment_method_type":
      return "payment_method_type";
    case "status":
      return "status";
    default:
      return "unknown";
  }
}

function OrderUIUtils$RenderAccordian(props) {
  var __initialExpandedArray = props.initialExpandedArray;
  var initialExpandedArray =
    __initialExpandedArray !== undefined ? __initialExpandedArray : [];
  return React.createElement(Accordion.make, {
    accordion: props.accordion,
    accordianTopContainerCss: "border",
    accordianBottomContainerCss: "p-5",
    contentExpandCss: "px-4 py-3 !border-t-0",
    initialExpandedArray: initialExpandedArray,
    titleStyle: "font-semibold text-bold text-md",
  });
}

var RenderAccordian = {
  make: OrderUIUtils$RenderAccordian,
};

function OrderUIUtils$GenerateSampleDataButton(props) {
  var getOrdersList = props.getOrdersList;
  var getURL = APIUtils.useGetURL();
  var mixpanelEvent = MixpanelHook.useSendEvent();
  var updateDetails = APIUtils.useUpdateMethod(undefined, undefined);
  var showToast = ToastState.useShowToast();
  var showPopUp = PopUpState.useShowPopUp();
  var match = Recoil.useRecoilValue(HyperswitchAtom.featureFlagAtom);
  var userPermissionJson = Recoil.useRecoilValue(
    HyperswitchAtom.userPermissionAtom,
  );
  var generateSampleData = async function () {
    mixpanelEvent(
      "generate_sample_data",
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    );
    try {
      var generateSampleDataUrl = getURL(
        "GENERATE_SAMPLE_DATA",
        "Post",
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
      await updateDetails(
        generateSampleDataUrl,
        Object.fromEntries([["record", 50.0]]),
        "Post",
        undefined,
        undefined,
        undefined,
        undefined,
      );
      showToast(
        "Sample data generated successfully.",
        "ToastSuccess",
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
      getOrdersList();
      return;
    } catch (exn) {
      return;
    }
  };
  var deleteSampleData = async function () {
    try {
      var generateSampleDataUrl = getURL(
        "GENERATE_SAMPLE_DATA",
        "Delete",
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
      await updateDetails(
        generateSampleDataUrl,
        {},
        "Delete",
        undefined,
        undefined,
        undefined,
        undefined,
      );
      showToast(
        "Sample data deleted successfully",
        "ToastSuccess",
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
      getOrdersList();
      return;
    } catch (exn) {
      return;
    }
  };
  return React.createElement(RenderIf.make, {
    condition: match.sampleData && !props.previewOnly,
    children: React.createElement(
      "div",
      {
        className: "flex items-start",
      },
      React.createElement(ACLButton.make, {
        text: "Generate Sample Data",
        buttonType: "Secondary",
        buttonSize: "XSmall",
        leftIcon: {
          TAG: "CustomIcon",
          _0: React.createElement(Icon.make, {
            name: "plus",
            size: 13,
          }),
        },
        onClick: function (param) {
          generateSampleData();
        },
        customButtonStyle: "!rounded-l-md !rounded-none",
        access: userPermissionJson.operationsManage,
      }),
      React.createElement(ACLDiv.make, {
        permission: userPermissionJson.operationsManage,
        onClick: function (ev) {
          ev.stopPropagation();
          showPopUp({
            heading: "Are you sure?",
            description:
              "This action cannot be undone. This will permanently delete all the sample payments and refunds data. To confirm, click the 'Delete All' button below.",
            popUpType: ["Warning", "WithIcon"],
            handleCancel: {
              text: "Cancel",
              onClick: function (param) {},
            },
            handleConfirm: {
              text: "Delete All",
              onClick: function (param) {
                deleteSampleData();
              },
            },
          });
        },
        children: React.createElement(Icon.make, {
          name: "delete",
          size: 16,
          className: "scale-125",
          customWidth: "14",
        }),
        className:
          "bg-jp-gray-button_gray text-jp-gray-900 text-opacity-75 hover:bg-jp-gray-secondary_hover hover:text-jp-gray-890  focus:outline-none items-center border border-border_gray cursor-pointer p-2.5 overflow-hidden text-jp-gray-950 hover:text-black\n          border flex items-center justify-center rounded-r-md",
        height: "h-fit",
      }),
    ),
  });
}

var GenerateSampleDataButton = {
  make: OrderUIUtils$GenerateSampleDataButton,
};

function OrderUIUtils$NoData(props) {
  var isConfigureConnector = props.isConfigureConnector;
  var match = Recoil.useRecoilValue(HyperswitchAtom.featureFlagAtom);
  var isLiveMode = match.isLiveMode;
  return React.createElement(HelperComponents.BluredTableComponent.make, {
    infoText: isConfigureConnector
      ? isLiveMode
        ? "There are no payments as of now."
        : "There are no payments as of now. Try making a test payment and visualise the checkout experience."
      : "Connect to a payment processor to make your first payment",
    buttonText: isConfigureConnector ? "Make a payment" : "Connect a connector",
    onClickUrl: isConfigureConnector ? "/sdk" : "/connectors",
    paymentModal: props.paymentModal,
    setPaymentModal: props.setPaymentModal,
    moduleName: "",
    showRedirectCTA: !isLiveMode,
  });
}

var NoData = {
  make: OrderUIUtils$NoData,
};

var startTimeFilterKey = "start_time";

var endTimeFilterKey = "end_time";

function filterByData(txnArr, value) {
  var searchText = LogicUtils.getStringFromJson(value, "");
  return Belt_Array.keepMap(
    Belt_Array.keepMap(txnArr, function (prim) {
      if (prim == null) {
        return;
      } else {
        return Caml_option.some(prim);
      }
    }),
    function (data) {
      var valueArr = Core__Array.reduce(
        Object.entries(data).map(function (item) {
          return LogicUtils.getStringFromJson(item[1], "")
            .toLowerCase()
            .includes(searchText);
        }),
        false,
        function (acc, item) {
          if (item) {
            return true;
          } else {
            return acc;
          }
        },
      );
      if (valueArr) {
        return Caml_option.some(data);
      }
    },
  );
}

function getConditionalFilter(key, dict, filterValues) {
  var match = getFilterTypeFromString(key);
  if (match === "connector_label") {
    var arr = LogicUtils.getStrArrayFromJsonArray(
      LogicUtils.getArrayFromDict(filterValues, "connector", []),
    );
    return arr.flatMap(function (connector) {
      var connectorLabelArr = LogicUtils.getArrayFromDict(
        LogicUtils.getDictfromDict(dict, "connector"),
        connector,
        [],
      );
      return connectorLabelArr.map(function (item) {
        return LogicUtils.getString(
          LogicUtils.getDictFromJsonObject(item),
          "connector_label",
          "",
        );
      });
    });
  }
  if (match !== "payment_method_type") {
    return [];
  }
  var arr$1 = LogicUtils.getStrArrayFromJsonArray(
    LogicUtils.getArrayFromDict(filterValues, "payment_method", []),
  );
  return arr$1.flatMap(function (paymentMethod) {
    var paymentMethodTypeArr = LogicUtils.getStrArrayFromJsonArray(
      LogicUtils.getArrayFromDict(
        LogicUtils.getDictfromDict(dict, "payment_method"),
        paymentMethod,
        [],
      ),
    );
    return paymentMethodTypeArr.map(function (item) {
      return item;
    });
  });
}

function getOptionsForOrderFilters(dict, filterValues) {
  var arr = LogicUtils.getStrArrayFromJsonArray(
    LogicUtils.getArrayFromDict(filterValues, "connector", []),
  );
  return arr.flatMap(function (connector) {
    var connectorLabelArr = LogicUtils.getArrayFromDict(
      LogicUtils.getDictfromDict(dict, "connector"),
      connector,
      [],
    );
    return connectorLabelArr.map(function (item) {
      var label = LogicUtils.getString(
        LogicUtils.getDictFromJsonObject(item),
        "connector_label",
        "",
      );
      var value = LogicUtils.getString(
        LogicUtils.getDictFromJsonObject(item),
        "merchant_connector_id",
        "",
      );
      return {
        label: label,
        value: value,
      };
    });
  });
}

function getAllPaymentMethodType(dict) {
  var paymentMethods = Object.keys(
    LogicUtils.getDictfromDict(dict, "payment_method"),
  );
  return Core__Array.reduce(paymentMethods, [], function (acc, item) {
    return acc.concat(
      LogicUtils.getStrArrayFromJsonArray(
        LogicUtils.getArrayFromDict(
          LogicUtils.getDictfromDict(dict, "payment_method"),
          item,
          [],
        ),
      ),
    );
  });
}

function itemToObjMapper(dict) {
  return {
    connector: Object.keys(LogicUtils.getDictfromDict(dict, "connector")),
    currency: LogicUtils.getStrArrayFromJsonArray(
      LogicUtils.getArrayFromDict(dict, "currency", []),
    ),
    authentication_type: LogicUtils.getStrArrayFromJsonArray(
      LogicUtils.getArrayFromDict(dict, "authentication_type", []),
    ),
    payment_method: Object.keys(
      LogicUtils.getDictfromDict(dict, "payment_method"),
    ),
    payment_method_type: getAllPaymentMethodType(dict),
    status: LogicUtils.getStrArrayFromJsonArray(
      LogicUtils.getArrayFromDict(dict, "status", []),
    ),
    connector_label: [],
  };
}

function initialFilters(json, filtervalues) {
  var connectorFilter = LogicUtils.getStrArrayFromJsonArray(
    LogicUtils.getArrayFromDict(filtervalues, "connector", []),
  );
  var filterDict = LogicUtils.getDictFromJsonObject(json);
  var filterArr = itemToObjMapper(filterDict);
  var arr = Object.keys(filterDict);
  if (connectorFilter.length !== 0) {
    arr.push("connector_label");
  }
  arr.push("payment_method_type");
  return arr.map(function (key) {
    var match = getFilterTypeFromString(key);
    var values =
      match === "connector_label"
        ? getConditionalFilter(key, filterDict, filtervalues)
        : match === "authentication_type"
          ? filterArr.authentication_type
          : match === "payment_method_type"
            ? getConditionalFilter(key, filterDict, filtervalues).length > 0
              ? getConditionalFilter(key, filterDict, filtervalues)
              : filterArr.payment_method_type
            : match === "payment_method"
              ? filterArr.payment_method
              : match === "status"
                ? filterArr.status
                : match === "currency"
                  ? filterArr.currency
                  : match === "connector"
                    ? filterArr.connector
                    : [];
    var title = "Select " + LogicUtils.snakeToTitle(key);
    var match$1 = getFilterTypeFromString(key);
    var options =
      match$1 === "connector_label"
        ? getOptionsForOrderFilters(filterDict, filtervalues)
        : FilterSelectBox.makeOptions(values);
    var match$2 = getFilterTypeFromString(key);
    var name = match$2 === "connector_label" ? "merchant_connector_id" : key;
    return {
      field: FormRenderer.makeFieldInfo(
        key,
        undefined,
        name,
        InputFields.filterMultiSelectInput(
          options,
          undefined,
          title,
          undefined,
          undefined,
          false,
          undefined,
          undefined,
          true,
          undefined,
          undefined,
          undefined,
          undefined,
          "bg-none",
          undefined,
          undefined,
          true,
          true,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        ),
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      ),
      localFilter: filterByData,
    };
  });
}

function initialFixedFilter() {
  return [
    {
      field: FormRenderer.makeMultiInputFieldInfo(
        "",
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        false,
        InputFields.filterDateRangeField(
          startTimeFilterKey,
          endTimeFilterKey,
          "YYYY-MM-DDTHH:mm:ss[Z]",
          false,
          true,
          false,
          [
            {
              TAG: "Hour",
              _0: 0.5,
            },
            {
              TAG: "Hour",
              _0: 1.0,
            },
            {
              TAG: "Hour",
              _0: 2.0,
            },
            "Today",
            "Yesterday",
            {
              TAG: "Day",
              _0: 2.0,
            },
            {
              TAG: "Day",
              _0: 7.0,
            },
            {
              TAG: "Day",
              _0: 30.0,
            },
            "ThisMonth",
            "LastMonth",
          ],
          false,
          2,
          180,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
          undefined,
        ),
        undefined,
        [],
        undefined,
      ),
      localFilter: undefined,
    },
  ];
}

function setData(
  offset,
  setOffset,
  total,
  data,
  setTotalCount,
  setOrdersData,
  setScreenState,
  previewOnly,
) {
  var arr = Core__Array.make(offset, {});
  if (total <= offset) {
    setOffset(function (param) {
      return 0;
    });
  }
  if (total <= 0) {
    return setScreenState(function (param) {
      return "Custom";
    });
  }
  var orderDataDictArr = Belt_Array.keepMap(data, Core__JSON.Decode.object);
  var orderData = arr
    .concat(orderDataDictArr)
    .map(OrderEntity.itemToObjMapper)
    .filter(function (param, i) {
      if (previewOnly) {
        return i <= 2;
      } else {
        return true;
      }
    });
  var list = orderData.map(function (prim) {
    return prim;
  });
  setTotalCount(function (param) {
    return total;
  });
  setOrdersData(function (param) {
    return list;
  });
  return setScreenState(function (param) {
    return "Success";
  });
}

async function getOrdersList(
  filterValueJson,
  updateDetails,
  getURL,
  setOrdersData,
  previewOnly,
  setScreenState,
  setOffset,
  setTotalCount,
  offset,
) {
  setScreenState(function (param) {
    return "Loading";
  });
  try {
    var ordersUrl = getURL(
      "ORDERS",
      "Post",
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    );
    var res = await updateDetails(
      ordersUrl,
      filterValueJson,
      "Post",
      undefined,
      undefined,
      undefined,
      undefined,
    );
    var data = LogicUtils.getArrayFromDict(
      LogicUtils.getDictFromJsonObject(res),
      "data",
      [],
    );
    var total = LogicUtils.getInt(
      LogicUtils.getDictFromJsonObject(res),
      "total_count",
      0,
    );
    if (
      !(data.length === 0 && Core__Option.isSome(filterValueJson["payment_id"]))
    ) {
      return setData(
        offset,
        setOffset,
        total,
        data,
        setTotalCount,
        setOrdersData,
        setScreenState,
        previewOnly,
      );
    }
    var payment_id = Core__Option.getOr(
      Core__JSON.Decode.string(
        Core__Option.getOr(filterValueJson["payment_id"], ""),
      ),
      "",
    );
    if (!/^[A-Za-z0-9]+_[A-Za-z0-9]+_[0-9]+/.test(payment_id)) {
      return setScreenState(function (param) {
        return "Custom";
      });
    }
    var newID = payment_id.replace(/_[0-9]$/g, "");
    filterValueJson["payment_id"] = newID;
    var res$1 = await updateDetails(
      ordersUrl,
      filterValueJson,
      "Post",
      undefined,
      undefined,
      undefined,
      undefined,
    );
    var data$1 = LogicUtils.getArrayFromDict(
      LogicUtils.getDictFromJsonObject(res$1),
      "data",
      [],
    );
    var total$1 = LogicUtils.getInt(
      LogicUtils.getDictFromJsonObject(res$1),
      "total_count",
      0,
    );
    return setData(
      offset,
      setOffset,
      total$1,
      data$1,
      setTotalCount,
      setOrdersData,
      setScreenState,
      previewOnly,
    );
  } catch (raw_exn) {
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Js_exn.$$Error) {
      return setScreenState(function (param) {
        return {
          TAG: "Error",
          _0: "Something went wrong!",
        };
      });
    }
    throw exn;
  }
}

function isNonEmptyValue(value) {
  return Object.entries(Core__Option.getOr(value, {})).length > 0;
}

export {
  getFilterTypeFromString,
  RenderAccordian,
  GenerateSampleDataButton,
  NoData,
  startTimeFilterKey,
  endTimeFilterKey,
  filterByData,
  getConditionalFilter,
  getOptionsForOrderFilters,
  getAllPaymentMethodType,
  itemToObjMapper,
  initialFilters,
  initialFixedFilter,
  setData,
  getOrdersList,
  isNonEmptyValue,
};
/* Icon Not a pure module */
