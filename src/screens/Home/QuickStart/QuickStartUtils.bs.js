// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as LogicUtils from "../../../utils/LogicUtils.bs.js";
import * as ConnectorUtils from "../../Connectors/ConnectorUtils.bs.js";

function getTestConnectorName(connector, quickStartPageState) {
  var exit = 0;
  if (connector.TAG === "Processors") {
    switch (connector._0) {
      case "STRIPE":
      case "PAYPAL":
        exit = 2;
        break;
      default:
        exit = 1;
    }
  } else {
    exit = 1;
  }
  switch (exit) {
    case 1:
      if (
        typeof quickStartPageState !== "object" ||
        !(
          quickStartPageState.TAG === "ConnectProcessor" &&
          quickStartPageState._0 === "CONFIGURE_PRIMARY"
        )
      ) {
        return "pretendpay";
      } else {
        return "fauxpay";
      }
    case 2:
      return ConnectorUtils.getConnectorNameString(connector) + "_test";
  }
}

var quickStartEnumIntialArray = [
  "ConfigurationType",
  "FirstProcessorConnected",
  "SecondProcessorConnected",
  "ConfiguredRouting",
  "TestPayment",
  "IntegrationMethod",
  "IntegrationCompleted",
  "DownloadWoocom",
  "ConfigureWoocom",
  "SetupWoocomWebhook",
  "StripeConnected",
  "PaypalConnected",
  "SPTestPayment",
  "OnboardingSurvey",
];

function connectorChoiceStringVariantMapper(stringValue) {
  switch (stringValue) {
    case "":
      return "NotSelected";
    case "Single":
      return "SinglePaymentProcessor";
    default:
      return "MultipleProcessorWithSmartRouting";
  }
}

function connectorChoiceVariantToString(variantValue) {
  if (variantValue === "SinglePaymentProcessor") {
    return "Single";
  } else if (variantValue === "MultipleProcessorWithSmartRouting") {
    return "Multiple";
  } else {
    return "";
  }
}

var connectorChoiceArray = [
  {
    displayText: "Single Payment Processor",
    description:
      "Connect any one processor and test a payment with Hyperswitch Checkout",
    variantType: "SinglePaymentProcessor",
  },
  {
    displayText: "Multiple processors with Smart Routing",
    description:
      "Connect a primary and secondary processor, define smart routing rules and test a payment with Hyperswitch Checkout",
    variantType: "MultipleProcessorWithSmartRouting",
  },
];

function getTypeOfConfigurationArray(selectedConnector) {
  var connectorName = ConnectorUtils.getDisplayNameForConnector(
    undefined,
    ConnectorUtils.getConnectorNameString(selectedConnector),
  );
  var testAPIDescription;
  if (selectedConnector.TAG === "Processors") {
    switch (selectedConnector._0) {
      case "STRIPE":
      case "PAYPAL":
        testAPIDescription =
          "We've got you covered. Try connecting with our test processor modeled like " +
          connectorName +
          " to continue your setup.";
        break;
      default:
        testAPIDescription =
          "We've got you covered. Try connecting with one of Hyperswitch's test processor to continue your setup.";
    }
  } else {
    testAPIDescription =
      "We've got you covered. Try connecting with one of Hyperswitch's test processor to continue your setup.";
  }
  return [
    {
      displayText: "Try with a test processor",
      description: testAPIDescription,
      variantType: "TestApiKeys",
    },
    {
      displayText: "I have " + connectorName + " API keys",
      description:
        "Enter your " +
        connectorName +
        "  test mode secret key and enable desired payment methods to proceed with the setup. ",
      variantType: "ConnectorApiKeys",
    },
  ];
}

var getSmartRoutingConfigurationText = [
  {
    displayText: "Fallback routing (active - passive)",
    description:
      "Fallback to the secondary processor in case your primary processor couldn't process the transactions",
    variantType: "DefaultFallback",
    imageLink: "/assets/FallbackRoutingImage.svg",
  },
  {
    displayText: "Volume based routing (active - active)",
    description:
      "Split & route your transaction volume via more than one processor. Default is 50-50, this can be updated later",
    variantType: "VolumeBasedRouting",
    imageLink: "/assets/VolumeBasedRoutingImage.svg",
  },
];

var integrateYourAppArray = [
  {
    displayText: "Quick Integration for Stripe users",
    description:
      "Continue using Stripe with 40+ payment processors by changing few lines of code.",
    leftIcon: "stripe-icon",
    footerTags: ["Low code", "Stripe elements compatible"],
    variantType: "MigrateFromStripe",
  },
  {
    displayText: "Standard Integration",
    description: "Integrate Hyperswitch into your app with four simple steps",
    leftIcon: "hyperswitch-logo-short",
    footerTags: ["Code required", "Supports all platforms"],
    variantType: "StandardIntegration",
  },
];

function getProcessorType(value) {
  var processorID = LogicUtils.getString(value, "processor_id", "");
  var processorName = LogicUtils.getString(value, "processor_name", "");
  return {
    processorID: processorID,
    processorName: processorName,
  };
}

function getRoutingType(value) {
  return {
    routing_id: LogicUtils.getString(value, "routing_id", ""),
  };
}

function getPaymentType(value) {
  return {
    payment_id: LogicUtils.getString(value, "payment_id", ""),
  };
}

function getIntegrationType(value) {
  return {
    integration_type: LogicUtils.getString(value, "integration_type", ""),
  };
}

function getStringFromVariant(variant) {
  return variant;
}

function getTypedValueFromDict(valueString) {
  var value = LogicUtils.getDictFromJsonObject(valueString);
  return {
    productionAgreement: LogicUtils.getBool(
      value,
      "ProductionAgreement",
      false,
    ),
    firstProcessorConnected: getProcessorType(
      LogicUtils.getDictfromDict(value, "FirstProcessorConnected"),
    ),
    secondProcessorConnected: getProcessorType(
      LogicUtils.getDictfromDict(value, "SecondProcessorConnected"),
    ),
    configuredRouting: getRoutingType(
      LogicUtils.getDictfromDict(value, "ConfiguredRouting"),
    ),
    testPayment: getPaymentType(
      LogicUtils.getDictfromDict(value, "TestPayment"),
    ),
    integrationMethod: getIntegrationType(
      LogicUtils.getDictfromDict(value, "IntegrationMethod"),
    ),
    integrationCompleted: LogicUtils.getBool(
      value,
      "IntegrationCompleted",
      false,
    ),
    stripeConnected: getProcessorType(
      LogicUtils.getDictfromDict(value, "StripeConnected"),
    ),
    paypalConnected: getProcessorType(
      LogicUtils.getDictfromDict(value, "PaypalConnected"),
    ),
    sPRoutingConfigured: getRoutingType(
      LogicUtils.getDictfromDict(value, "SPRoutingConfigured"),
    ),
    sPTestPayment: LogicUtils.getBool(value, "SPTestPayment", false),
    downloadWoocom: LogicUtils.getBool(value, "DownloadWoocom", false),
    configureWoocom: LogicUtils.getBool(value, "ConfigureWoocom", false),
    setupWoocomWebhook: LogicUtils.getBool(value, "SetupWoocomWebhook", false),
    downloadTestAPIKeyStripe: LogicUtils.getString(
      value,
      "DownloadTestAPIKeyStripe",
      "",
    ),
    installDeps: LogicUtils.getString(value, "InstallDeps", ""),
    replaceAPIKeys: LogicUtils.getString(value, "ReplaceAPIKeys", ""),
    reconfigureCheckout: LogicUtils.getString(value, "ReconfigureCheckout", ""),
    loadCheckout: LogicUtils.getString(value, "LoadCheckout", ""),
    downloadTestAPIKey: LogicUtils.getString(value, "DownloadTestAPIKey", ""),
    createPayment: LogicUtils.getString(value, "CreatePayment", ""),
    displayCheckout: LogicUtils.getString(value, "DisplayCheckout", ""),
    displayPaymentConfirmation: LogicUtils.getString(
      value,
      "DisplayPaymentConfirmation",
      "",
    ),
    configurationType: LogicUtils.getString(value, "ConfigurationType", ""),
  };
}

function variantToEnumMapper(variantValue) {
  if (typeof variantValue !== "object") {
    return "IntegrationCompleted";
  }
  switch (variantValue.TAG) {
    case "ConnectProcessor":
      switch (variantValue._0) {
        case "CONFIGURE_PRIMARY":
          return "FirstProcessorConnected";
        case "CONFIGURE_SECONDARY":
          return "SecondProcessorConnected";
        case "CONFIGURE_SMART_ROUTING":
          return "ConfiguredRouting";
        case "CHECKOUT":
        case "LANDING":
          return "TestPayment";
      }
    case "IntegrateApp":
      switch (variantValue._0) {
        case "CHOOSE_INTEGRATION":
          return "IntegrationMethod";
        case "LANDING":
        case "CUSTOM_INTEGRATION":
          return "IntegrationCompleted";
      }
    case "GoLive":
      return "IntegrationCompleted";
  }
}

function enumToVarinatMapper($$enum) {
  if ($$enum === "SecondProcessorConnected") {
    return {
      TAG: "ConnectProcessor",
      _0: "CONFIGURE_SECONDARY",
    };
  } else if ($$enum === "FirstProcessorConnected") {
    return {
      TAG: "ConnectProcessor",
      _0: "CONFIGURE_PRIMARY",
    };
  } else if ($$enum === "IntegrationMethod") {
    return {
      TAG: "IntegrateApp",
      _0: "CHOOSE_INTEGRATION",
    };
  } else if ($$enum === "TestPayment") {
    return {
      TAG: "ConnectProcessor",
      _0: "CHECKOUT",
    };
  } else if ($$enum === "IntegrationCompleted") {
    return {
      TAG: "IntegrateApp",
      _0: "CUSTOM_INTEGRATION",
    };
  } else if ($$enum === "ConfigurationType") {
    return {
      TAG: "ConnectProcessor",
      _0: "LANDING",
    };
  } else if ($$enum === "ConfiguredRouting") {
    return {
      TAG: "ConnectProcessor",
      _0: "CONFIGURE_SMART_ROUTING",
    };
  } else {
    return {
      TAG: "GoLive",
      _0: "LANDING",
    };
  }
}

function getStatusValue(comparator, enumVariant, dashboardPageState) {
  if (comparator.TAG === "String") {
    if (LogicUtils.isNonEmptyString(comparator._0)) {
      return "COMPLETED";
    } else if (dashboardPageState === enumVariant) {
      return "ONGOING";
    } else {
      return "PENDING";
    }
  } else if (comparator._0) {
    return "COMPLETED";
  } else if (dashboardPageState === enumVariant) {
    return "ONGOING";
  } else {
    return "PENDING";
  }
}

function getStatusFromString(statusString) {
  var match = statusString.toUpperCase();
  switch (match) {
    case "COMPLETED":
      return "COMPLETED";
    case "ONGOING":
      return "ONGOING";
    default:
      return "PENDING";
  }
}

function sidebarTextBasedOnVariant(choiceState) {
  if (choiceState === "WooCommercePlugin") {
    return "Woocommerce plugin";
  } else if (choiceState === "StandardIntegration") {
    return "Standard integration";
  } else {
    return "Hyperswitch For Stripe Users";
  }
}

function getSidebarOptionsForIntegrateYourApp(
  enumDetails,
  quickStartPageState,
  currentRoute,
  choiceState,
) {
  var currentPageStateEnum = variantToEnumMapper(quickStartPageState);
  var enumValue = getTypedValueFromDict(LogicUtils.safeParse(enumDetails));
  var migrateFromStripeSidebar = [
    {
      title: "Choose integration method",
      status: getStatusValue(
        {
          TAG: "String",
          _0: enumValue.integrationMethod.integration_type,
        },
        "IntegrationMethod",
        currentPageStateEnum,
      ),
      link: "/",
    },
    {
      title: sidebarTextBasedOnVariant(choiceState),
      status: getStatusValue(
        {
          TAG: "Boolean",
          _0: enumValue.integrationCompleted,
        },
        "IntegrationCompleted",
        currentPageStateEnum,
      ),
      link: "/",
      subOptions: [
        {
          title: "Download Test API Keys",
          status: getStatusFromString(enumValue.downloadTestAPIKeyStripe),
        },
        {
          title: "Install Dependencies",
          status: getStatusFromString(enumValue.installDeps),
        },
        {
          title: "Replace API keys",
          status: getStatusFromString(enumValue.replaceAPIKeys),
        },
        {
          title: "Reconfigure Checkout Form",
          status: getStatusFromString(enumValue.reconfigureCheckout),
        },
        {
          title: "Load Hyperswitch Checkout",
          status: getStatusFromString(enumValue.loadCheckout),
        },
      ],
    },
  ];
  var standardIntegrationSidebar = [
    {
      title: "Choose integration method",
      status: getStatusValue(
        {
          TAG: "String",
          _0: enumValue.integrationMethod.integration_type,
        },
        "IntegrationMethod",
        currentPageStateEnum,
      ),
      link: "/",
    },
    {
      title: sidebarTextBasedOnVariant(choiceState),
      status: getStatusValue(
        {
          TAG: "Boolean",
          _0: enumValue.integrationCompleted,
        },
        "IntegrationCompleted",
        currentPageStateEnum,
      ),
      link: "/",
      subOptions: [
        {
          title: "Download Test API Key",
          status: getStatusFromString(enumValue.downloadTestAPIKey),
        },
        {
          title: "Create a Payment",
          status: getStatusFromString(enumValue.createPayment),
        },
        {
          title: "Display Hyperswitch Checkout",
          status: getStatusFromString(enumValue.displayCheckout),
        },
        {
          title: "Display Payment Confirmation",
          status: getStatusFromString(enumValue.displayPaymentConfirmation),
        },
      ],
    },
  ];
  switch (currentRoute) {
    case "MigrateFromStripe":
      return migrateFromStripeSidebar;
    default:
      return standardIntegrationSidebar;
  }
}

function getConnectorStatus(
  enumValueToCheck,
  connectorConfigureState,
  checkValue,
  currentEnum,
) {
  var isConnectorConnected = LogicUtils.isNonEmptyString(enumValueToCheck);
  if (isConnectorConnected || connectorConfigureState === checkValue) {
    return "COMPLETED";
  } else if (Caml_obj.equal(connectorConfigureState, currentEnum)) {
    return "ONGOING";
  } else {
    return "PENDING";
  }
}

function getConnectorSubOptions(
  choiceStateForTestConnector,
  valueToCheck,
  connectorConfigureState,
) {
  if (choiceStateForTestConnector === "TestApiKeys") {
    return [];
  } else {
    return [
      {
        title: "Setup Sandbox Credentials",
        status: getConnectorStatus(
          valueToCheck.processorID,
          connectorConfigureState,
          "Setup_payment_methods",
          "Configure_keys",
        ),
      },
      {
        title: "Setup Payment Methods",
        status: getConnectorStatus(
          valueToCheck.processorID,
          connectorConfigureState,
          "Summary",
          "Setup_payment_methods",
        ),
      },
    ];
  }
}

function getSidebarOptionsForConnectProcessor(
  enumDetails,
  quickStartPageState,
  connectorConfigureState,
  choiceStateForTestConnector,
) {
  var enumValue = getTypedValueFromDict(LogicUtils.safeParse(enumDetails));
  var currentPageStateEnum = variantToEnumMapper(quickStartPageState);
  if (
    connectorChoiceStringVariantMapper(enumValue.configurationType) ===
    "MultipleProcessorWithSmartRouting"
  ) {
    return [
      {
        title: "Connect primary processor",
        status: getStatusValue(
          {
            TAG: "String",
            _0: enumValue.firstProcessorConnected.processorID,
          },
          "FirstProcessorConnected",
          currentPageStateEnum,
        ),
        link: "/quick-start",
        subOptions: getConnectorSubOptions(
          choiceStateForTestConnector,
          enumValue.firstProcessorConnected,
          connectorConfigureState,
        ),
      },
      {
        title: "Connect secondary processor",
        status: getStatusValue(
          {
            TAG: "String",
            _0: enumValue.secondProcessorConnected.processorID,
          },
          "SecondProcessorConnected",
          currentPageStateEnum,
        ),
        link: "/quick-start",
        subOptions: getConnectorSubOptions(
          choiceStateForTestConnector,
          enumValue.secondProcessorConnected,
          connectorConfigureState,
        ),
      },
      {
        title: "Configure smart routing",
        status: getStatusValue(
          {
            TAG: "String",
            _0: enumValue.configuredRouting.routing_id,
          },
          "ConfiguredRouting",
          currentPageStateEnum,
        ),
        link: "/quick-start",
      },
      {
        title: "Try hyperswitch checkout",
        status: getStatusValue(
          {
            TAG: "String",
            _0: enumValue.testPayment.payment_id,
          },
          "TestPayment",
          currentPageStateEnum,
        ),
        link: "/quick-start",
      },
    ];
  } else {
    return [
      {
        title: "Connect Primary Processor",
        status: getStatusValue(
          {
            TAG: "String",
            _0: enumValue.firstProcessorConnected.processorID,
          },
          "FirstProcessorConnected",
          currentPageStateEnum,
        ),
        link: "/quick-start",
        subOptions: getConnectorSubOptions(
          choiceStateForTestConnector,
          enumValue.firstProcessorConnected,
          connectorConfigureState,
        ),
      },
      {
        title: "Try hyperswitch checkout",
        status: getStatusValue(
          {
            TAG: "String",
            _0: enumValue.testPayment.payment_id,
          },
          "TestPayment",
          currentPageStateEnum,
        ),
        link: "/quick-start",
      },
    ];
  }
}

function textToVariantMapper(str) {
  switch (str) {
    case "StandardIntegration":
      return "StandardIntegration";
    case "WooCommercePlugin":
      return "WooCommercePlugin";
    default:
      return "MigrateFromStripe";
  }
}

function textToVariantMapperForBuildHS(str) {
  switch (str) {
    case "StandardIntegration":
      return "IntegrateFromScratch";
    case "WooCommercePlugin":
      return "WooCommercePlugin";
    default:
      return "MigrateFromStripe";
  }
}

function stringToVariantMapperForUserData(str) {
  switch (str) {
    case "ConfigurationType":
      return "ConfigurationType";
    case "ConfigureWoocom":
      return "ConfigureWoocom";
    case "ConfiguredRouting":
      return "ConfiguredRouting";
    case "DownloadWoocom":
      return "DownloadWoocom";
    case "FirstProcessorConnected":
      return "FirstProcessorConnected";
    case "IntegrationCompleted":
      return "IntegrationCompleted";
    case "IntegrationMethod":
      return "IntegrationMethod";
    case "PaypalConnected":
      return "PaypalConnected";
    case "SPRoutingConfigured":
      return "SPRoutingConfigured";
    case "SPTestPayment":
      return "SPTestPayment";
    case "SecondProcessorConnected":
      return "SecondProcessorConnected";
    case "SetupWoocomWebhook":
      return "SetupWoocomWebhook";
    case "StripeConnected":
      return "StripeConnected";
    case "TestPayment":
      return "TestPayment";
    default:
      return "ProductionAgreement";
  }
}

function generateBodyBasedOnType(parentVariant, value) {
  switch (value.TAG) {
    case "ProcesorType":
      var processorTypeVal = value._0;
      return LogicUtils.getJsonFromArrayOfJson([
        [
          parentVariant,
          LogicUtils.getJsonFromArrayOfJson([
            ["processor_id", processorTypeVal.processorID],
            ["processor_name", processorTypeVal.processorName],
          ]),
        ],
      ]);
    case "RoutingType":
      return LogicUtils.getJsonFromArrayOfJson([
        [
          parentVariant,
          LogicUtils.getJsonFromArrayOfJson([
            ["routing_id", value._0.routing_id],
          ]),
        ],
      ]);
    case "PaymentType":
      return LogicUtils.getJsonFromArrayOfJson([
        [
          parentVariant,
          LogicUtils.getJsonFromArrayOfJson([
            ["payment_id", value._0.payment_id],
          ]),
        ],
      ]);
    case "IntegrationMethod":
      return LogicUtils.getJsonFromArrayOfJson([
        [
          parentVariant,
          LogicUtils.getJsonFromArrayOfJson([
            ["integration_type", value._0.integration_type],
          ]),
        ],
      ]);
    case "Boolean":
      return parentVariant;
    case "String":
      return value._0;
    case "StringEnumType":
      return LogicUtils.getJsonFromArrayOfJson([[parentVariant, value._0]]);
  }
}

function getInitialValueForConnector(enumValue) {
  var arr = [];
  if (
    LogicUtils.isNonEmptyString(enumValue.firstProcessorConnected.processorID)
  ) {
    arr.push(enumValue.firstProcessorConnected.processorName);
  }
  if (
    LogicUtils.isNonEmptyString(enumValue.secondProcessorConnected.processorID)
  ) {
    arr.push(enumValue.secondProcessorConnected.processorName);
  }
  return arr;
}

function checkEmptyDict(dict, variant) {
  return LogicUtils.isEmptyDict(
    LogicUtils.getDictFromJsonObject(
      LogicUtils.getJsonObjectFromDict(dict, variant),
    ),
  );
}

function checkBool(dict, variant) {
  return LogicUtils.getBool(dict, variant, false);
}

function checkString(dict, variant) {
  return LogicUtils.getString(dict, variant, "");
}

function getCurrentStep(dict) {
  if (
    checkString(dict, "ConfigurationType").length === 0 &&
    checkEmptyDict(dict, "FirstProcessorConnected")
  ) {
    return "ConfigurationType";
  } else if (
    connectorChoiceStringVariantMapper(
      checkString(dict, "ConfigurationType"),
    ) === "SinglePaymentProcessor" &&
    checkEmptyDict(dict, "FirstProcessorConnected")
  ) {
    return "FirstProcessorConnected";
  } else if (
    connectorChoiceStringVariantMapper(
      checkString(dict, "ConfigurationType"),
    ) === "SinglePaymentProcessor" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    checkEmptyDict(dict, "TestPayment") === true
  ) {
    return "TestPayment";
  } else if (
    connectorChoiceStringVariantMapper(
      checkString(dict, "ConfigurationType"),
    ) === "SinglePaymentProcessor" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    checkEmptyDict(dict, "IntegrationMethod") === true
  ) {
    return "IntegrationMethod";
  } else if (
    connectorChoiceStringVariantMapper(
      checkString(dict, "ConfigurationType"),
    ) === "MultipleProcessorWithSmartRouting" &&
    checkEmptyDict(dict, "FirstProcessorConnected")
  ) {
    return "FirstProcessorConnected";
  } else if (
    connectorChoiceStringVariantMapper(
      checkString(dict, "ConfigurationType"),
    ) === "MultipleProcessorWithSmartRouting" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    checkEmptyDict(dict, "SecondProcessorConnected")
  ) {
    return "SecondProcessorConnected";
  } else if (
    connectorChoiceStringVariantMapper(
      checkString(dict, "ConfigurationType"),
    ) === "MultipleProcessorWithSmartRouting" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    !checkEmptyDict(dict, "SecondProcessorConnected") &&
    checkEmptyDict(dict, "ConfiguredRouting")
  ) {
    return "ConfiguredRouting";
  } else if (
    connectorChoiceStringVariantMapper(
      checkString(dict, "ConfigurationType"),
    ) === "MultipleProcessorWithSmartRouting" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    !checkEmptyDict(dict, "SecondProcessorConnected") &&
    !checkEmptyDict(dict, "ConfiguredRouting") &&
    checkEmptyDict(dict, "TestPayment")
  ) {
    return "TestPayment";
  } else if (
    connectorChoiceStringVariantMapper(
      checkString(dict, "ConfigurationType"),
    ) === "MultipleProcessorWithSmartRouting" &&
    !checkEmptyDict(dict, "FirstProcessorConnected") &&
    !checkEmptyDict(dict, "SecondProcessorConnected") &&
    !checkEmptyDict(dict, "ConfiguredRouting") &&
    checkEmptyDict(dict, "IntegrationMethod")
  ) {
    return "IntegrationMethod";
  } else if (
    !checkEmptyDict(dict, "IntegrationMethod") &&
    !checkBool(dict, "IntegrationCompleted")
  ) {
    return "IntegrationCompleted";
  } else {
    return "GoLive";
  }
}

export {
  getTestConnectorName,
  quickStartEnumIntialArray,
  connectorChoiceStringVariantMapper,
  connectorChoiceVariantToString,
  connectorChoiceArray,
  getTypeOfConfigurationArray,
  getSmartRoutingConfigurationText,
  integrateYourAppArray,
  getProcessorType,
  getRoutingType,
  getPaymentType,
  getIntegrationType,
  getStringFromVariant,
  getTypedValueFromDict,
  variantToEnumMapper,
  enumToVarinatMapper,
  getStatusValue,
  getStatusFromString,
  sidebarTextBasedOnVariant,
  getSidebarOptionsForIntegrateYourApp,
  getConnectorStatus,
  getConnectorSubOptions,
  getSidebarOptionsForConnectProcessor,
  textToVariantMapper,
  textToVariantMapperForBuildHS,
  stringToVariantMapperForUserData,
  generateBodyBasedOnType,
  getInitialValueForConnector,
  checkEmptyDict,
  checkBool,
  checkString,
  getCurrentStep,
};
/* LogicUtils Not a pure module */
