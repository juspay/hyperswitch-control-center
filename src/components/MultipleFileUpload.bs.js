// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Icon from "./Icon.bs.js";
import * as React from "react";
import * as LogicUtils from "../utils/LogicUtils.bs.js";
import * as ToastState from "../hooks/ToastState.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as DownloadUtils from "../utils/DownloadUtils.bs.js";
import * as ReactFinalForm from "react-final-form";

function MultipleFileUpload(props) {
  var __pointerDisable = props.pointerDisable;
  var sizeLimit = props.sizeLimit;
  var __customDownload = props.customDownload;
  var __fileOnClick = props.fileOnClick;
  var __allowMultiFileSelect = props.allowMultiFileSelect;
  var validateUploadedFile = props.validateUploadedFile;
  var rowsLimit = props.rowsLimit;
  var buttonElement = props.buttonElement;
  var __displayClass = props.displayClass;
  var __parentDisplayClass = props.parentDisplayClass;
  var __buttonHeightClass = props.buttonHeightClass;
  var __heightClass = props.heightClass;
  var __widthClass = props.widthClass;
  var __decodeParsedfile = props.decodeParsedfile;
  var __shouldEncodeBase64 = props.shouldEncodeBase64;
  var __parseFile = props.parseFile;
  var __showUploadtoast = props.showUploadtoast;
  var __shouldParse = props.shouldParse;
  var __isDisabled = props.isDisabled;
  var fileNamesInput = props.fileNamesInput;
  var __fileType = props.fileType;
  var input = props.input;
  var fileType = __fileType !== undefined ? __fileType : ".pdf";
  var isDisabled = __isDisabled !== undefined ? __isDisabled : false;
  var shouldParse = __shouldParse !== undefined ? __shouldParse : true;
  var showUploadtoast =
    __showUploadtoast !== undefined ? __showUploadtoast : true;
  var parseFile =
    __parseFile !== undefined
      ? __parseFile
      : function (str) {
          return str;
        };
  var shouldEncodeBase64 =
    __shouldEncodeBase64 !== undefined ? __shouldEncodeBase64 : false;
  var decodeParsedfile =
    __decodeParsedfile !== undefined ? __decodeParsedfile : false;
  var widthClass = __widthClass !== undefined ? __widthClass : "w-[253px]";
  var heightClass = __heightClass !== undefined ? __heightClass : "h-[74px]";
  var buttonHeightClass =
    __buttonHeightClass !== undefined ? __buttonHeightClass : "";
  var parentDisplayClass =
    __parentDisplayClass !== undefined ? __parentDisplayClass : "flex gap-5";
  var displayClass =
    __displayClass !== undefined
      ? __displayClass
      : "flex flex-col flex-wrap overflow-auto";
  var allowMultiFileSelect =
    __allowMultiFileSelect !== undefined ? __allowMultiFileSelect : false;
  var fileOnClick =
    __fileOnClick !== undefined ? __fileOnClick : function (param, param$1) {};
  var customDownload =
    __customDownload !== undefined ? __customDownload : false;
  var pointerDisable =
    __pointerDisable !== undefined ? __pointerDisable : false;
  var match = React.useState(function () {
    return 1;
  });
  var setKey = match[1];
  var formValues = ReactFinalForm.useField(input.name + "_filenames").input;
  var fileNamesInput$1 =
    fileNamesInput !== undefined ? fileNamesInput : formValues;
  var fileTypeInput = ReactFinalForm.useField(input.name + "_filemimes").input;
  var defaultFileNames = LogicUtils.getStrArryFromJson(fileNamesInput$1.value);
  var match$1 = React.useState(function () {
    return defaultFileNames;
  });
  var setFilenames = match$1[1];
  var fileNames = match$1[0];
  var match$2 = React.useState(function () {
    return defaultFileNames;
  });
  var setFileTypes = match$2[1];
  var fileTypes = match$2[0];
  var showToast = ToastState.useShowToast();
  React.useEffect(
    function () {
      fileNamesInput$1.onChange(fileNames);
      fileTypeInput.onChange(fileTypes);
    },
    [fileNames, fileTypes],
  );
  var toast = function (message, toastType) {
    showToast(
      message,
      toastType,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    );
  };
  var fileEmptyCheckUpload = function (value, files, filename, mimeType) {
    if (LogicUtils.isNonEmptyString(value)) {
      setFilenames(function (prev) {
        return prev.slice().concat(filename);
      });
      setFileTypes(function (prev) {
        return prev.slice().concat(mimeType);
      });
      files.push(value);
      if (showUploadtoast) {
        return toast("File Uploaded Successfully", "ToastSuccess");
      } else {
        return;
      }
    } else {
      return toast("Error uploading file", "ToastError");
    }
  };
  var onChange = function (evt) {
    var target = evt.target;
    var arr = [0];
    var $$break = false;
    var files = LogicUtils.getArrayFromJson(input.value, []);
    while (!$$break) {
      if (target.files.length > Core__Option.getOr(arr[0], 0)) {
        var index = Core__Option.getOr(arr[0], 0);
        var value = target.files[index];
        if (value !== undefined) {
          var value$1 = Caml_option.valFromOption(value);
          var filename = value$1.name;
          var size = value$1.size;
          var mimeType = value$1.type;
          var fileFormat = ".".concat(
            Core__Option.getOr(filename.split(".").pop(), ""),
          );
          var fileTypeArr = fileType.split(",");
          var isCorrectFileFormat =
            fileTypeArr.includes(fileFormat) || fileTypeArr.includes("*");
          var fileReader = new FileReader();
          if (filename.includes("p12")) {
            fileReader.readAsBinaryString(value$1);
          } else if (shouldEncodeBase64) {
            fileReader.readAsDataURL(value$1);
          } else {
            fileReader.readAsText(value$1);
          }
          fileReader.onload = (function (
            value$1,
            filename,
            size,
            mimeType,
            isCorrectFileFormat,
          ) {
            return function (e) {
              var target = e.target;
              var file = target.result;
              var value$2 = shouldParse ? parseFile(file) : value$1;
              var isValid =
                validateUploadedFile !== undefined
                  ? validateUploadedFile(file)
                  : true;
              if (isCorrectFileFormat) {
                if (!isValid) {
                  return toast("Invalid file", "ToastError");
                }
                if (sizeLimit === undefined) {
                  return fileEmptyCheckUpload(
                    value$2,
                    files,
                    filename,
                    mimeType,
                  );
                }
                if (size > sizeLimit) {
                  return showToast(
                    "File size too large, upload below " +
                      ((sizeLimit / 1000) | 0).toString() +
                      "kb",
                    "ToastError",
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                    undefined,
                  );
                }
                if (rowsLimit === undefined) {
                  return fileEmptyCheckUpload(
                    value$2,
                    files,
                    filename,
                    mimeType,
                  );
                }
                var rows = file.split("\n").length;
                if (
                  LogicUtils.isNonEmptyString(value$2) &&
                  ((rows - 1) | 0) < rowsLimit
                ) {
                  setFilenames(function (prev) {
                    return prev.slice().concat(filename);
                  });
                  setFileTypes(function (prev) {
                    return prev.slice().concat(mimeType);
                  });
                  files.push(value$2);
                  if (showUploadtoast) {
                    return toast("File Uploaded Successfully", "ToastSuccess");
                  } else {
                    return;
                  }
                } else if (showUploadtoast) {
                  return toast("File Size Exceeded", "ToastError");
                } else {
                  return;
                }
              }
              input.onChange("");
              toast("Invalid file format", "ToastError");
            };
          })(value$1, filename, size, mimeType, isCorrectFileFormat);
          arr[0] = (Core__Option.getOr(arr[0], 0) + 1) | 0;
        }
      } else {
        $$break = true;
      }
      input.onChange(files);
    }
  };
  var val = LogicUtils.getArrayFromJson(input.value, []);
  var cursor = isDisabled ? "cursor-not-allowed" : "cursor-pointer";
  return React.createElement(
    "div",
    {
      className: parentDisplayClass,
    },
    React.createElement(
      "label",
      undefined,
      React.createElement(
        "div",
        {
          onDragOver: function (ev) {
            ev.preventDefault();
          },
          onDrop: function (ev) {
            ev.preventDefault();
            var files = ev.dataTransfer.files;
            if (files.length <= 0) {
              return;
            }
            var file = files[0];
            var filename = file.name;
            var mimeType = file.type;
            setFilenames(function (prev) {
              return prev.concat(filename);
            });
            setFileTypes(function (prev) {
              return prev.concat(mimeType);
            });
            input.onChange(
              LogicUtils.getArrayFromJson(input.value, []).concat([file]),
            );
          },
        },
        isDisabled
          ? null
          : React.createElement("input", {
              key: match[0].toString(),
              hidden: true,
              accept: fileType,
              multiple: allowMultiFileSelect,
              type: "file",
              onChange: onChange,
            }),
        buttonElement !== undefined
          ? Caml_option.valFromOption(buttonElement)
          : React.createElement(
              "div",
              {
                className:
                  "flex items-center justify-center gap-2 " +
                  cursor +
                  " " +
                  widthClass +
                  " " +
                  heightClass +
                  " " +
                  buttonHeightClass +
                  " rounded-md border border-[#8C8E9D4D] text-[#0E111E] ",
              },
              React.createElement(Icon.make, {
                name: "cloud-upload-alt",
              }),
              React.createElement("span", undefined, "Upload files"),
            ),
      ),
    ),
    React.createElement(
      "div",
      {
        className:
          heightClass + " " + displayClass + " justify-between gap-x-5",
      },
      fileNames.map(function (fileName, indx) {
        var match = Core__Option.getOr(fileName.split(".").pop(), "");
        var tmp;
        switch (match) {
          case "csv":
            tmp = React.createElement("img", {
              alt: "csv",
              src: "/icons/paIcons/csvIcon.svg",
            });
            break;
          case "pdf":
            tmp = React.createElement("img", {
              alt: "pdf",
              src: "/icons/paIcons/pdfIcon.svg",
            });
            break;
          default:
            tmp = null;
        }
        return React.createElement(
          "div",
          {
            key: indx.toString(),
            className: "flex items-center border p-2 gap-4 rounded-lg",
          },
          React.createElement(
            "div",
            {
              className: pointerDisable
                ? "flex items-center gap-4 flex-1 pointer-events-none"
                : "flex items-center gap-4 flex-1",
            },
            tmp,
            React.createElement(
              "div",
              {
                className:
                  "flex flex-row text-sm text-jp-gray-900 dark:text-jp-gray-text_darktheme dark:text-opacity-40 text-opacity-50 font-medium",
                onClick: function (param) {
                  if (customDownload) {
                    return fileOnClick(indx, fileName);
                  } else {
                    var tmp;
                    if (decodeParsedfile) {
                      try {
                        tmp = atob(
                          LogicUtils.getStringFromJson(
                            Core__Option.getOr(val[indx], null),
                            "",
                          ),
                        );
                      } catch (exn) {
                        toast("Error : Unable to parse file", "ToastError");
                        tmp = "";
                      }
                    } else {
                      tmp = LogicUtils.getStringFromJson(
                        Core__Option.getOr(val[indx], null),
                        "",
                      );
                    }
                    return DownloadUtils.downloadOld(fileName, tmp);
                  }
                },
              },
              fileName,
            ),
          ),
          isDisabled
            ? null
            : React.createElement(Icon.make, {
                name: "times",
                size: 14,
                className: "cursor-pointer text-jp-gray-900 text-opacity-50",
                onClick: function (param) {
                  setFilenames(function (prev) {
                    return prev.filter(function (param, i) {
                      return indx !== i;
                    });
                  });
                  setFileTypes(function (prev) {
                    return prev.filter(function (param, i) {
                      return indx !== i;
                    });
                  });
                  input.onChange(
                    LogicUtils.getArrayFromJson(input.value, []).filter(
                      function (param, i) {
                        return indx !== i;
                      },
                    ),
                  );
                  setKey(function (prev) {
                    return (prev + 1) | 0;
                  });
                },
              }),
        );
      }),
    ),
  );
}

var make = MultipleFileUpload;

export { make };
/* Icon Not a pure module */
