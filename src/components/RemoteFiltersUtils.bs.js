// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__JSON from "@rescript/core/src/Core__JSON.bs.js";
import * as LogicUtils from "../utils/LogicUtils.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as UrlFetchUtils from "../utils/UrlFetchUtils.bs.js";
import * as JsonFlattenUtils from "../utils/JsonFlattenUtils.bs.js";
import * as RescriptReactRouter from "@rescript/react/src/RescriptReactRouter.bs.js";

function getFinalDict(
  filterJson,
  filtersFromUrl,
  options,
  isEulerOrderEntity,
  dropdownSearchKeyValueNames,
  searchkeysDict,
  isSearchKeyArray,
  defaultKeysAllowedOpt,
  urlKeyTypeDict,
  param,
) {
  var defaultKeysAllowed =
    defaultKeysAllowedOpt !== undefined
      ? defaultKeysAllowedOpt
      : ["offset", "order", "orderType", "merchantId"];
  var unflattenDict = JsonFlattenUtils.unflattenObject(filtersFromUrl);
  var filterDict = {};
  var dict = Core__JSON.Decode.object(filterJson);
  if (dict !== undefined) {
    var allowedDefaultKeys = Core__Option.isSome(dict["sourceObject"])
      ? Object.keys(dict)
      : defaultKeysAllowed;
    Object.entries(dict).forEach(function (entry) {
      var key = entry[0];
      if (allowedDefaultKeys.includes(key)) {
        filterDict[key] = entry[1];
        return;
      }
    });
  }
  Object.entries(unflattenDict).forEach(function (entry) {
    var val = entry[1];
    var key = entry[0];
    var selectedOption = options.find(function (option) {
      return option.urlKey === key;
    });
    var parser =
      selectedOption !== undefined
        ? selectedOption.parser
        : function (x) {
            return x;
          };
    filterDict[key] = parser(val);
    var match = Object.entries(urlKeyTypeDict).find(function (param) {
      return key === param[0];
    });
    var val$1;
    if (match !== undefined) {
      var value = match[1];
      var getExpectedType = function (ele) {
        switch (value) {
          case "Boolean":
            return LogicUtils.getBoolFromString(ele, false);
          case "Float":
            return LogicUtils.getFloatFromString(ele, 0);
          case "Int":
            return LogicUtils.getIntFromString(ele, 0);
        }
      };
      var stringValueArr = Core__JSON.Classify.classify(val);
      if (typeof stringValueArr !== "object") {
        val$1 = val;
      } else {
        switch (stringValueArr.TAG) {
          case "String":
            val$1 = getExpectedType(stringValueArr._0);
            break;
          case "Array":
            val$1 = stringValueArr._0.map(function (ele) {
              return getExpectedType(
                Core__Option.getOr(Core__JSON.Decode.string(ele), ""),
              );
            });
            break;
          default:
            val$1 = val;
        }
      }
    } else {
      val$1 = val;
    }
    filterDict[key] = val$1;
  });
  if (Object.keys(filterDict).length === 0) {
    return filterJson;
  }
  if (dropdownSearchKeyValueNames.length === 2) {
    if (isSearchKeyArray) {
      var key = LogicUtils.getArrayFromDict(
        filterDict,
        Core__Option.getOr(dropdownSearchKeyValueNames[0], ""),
        [],
      ).map(function (item) {
        return LogicUtils.toCamelCase(LogicUtils.getStringFromJson(item, ""));
      });
      var value = LogicUtils.getString(
        filterDict,
        Core__Option.getOr(dropdownSearchKeyValueNames[1], ""),
        "",
      ).split(", ");
      value.forEach(function (value, indx) {
        var key$1 = key.length > indx ? Core__Option.getOr(key[indx], "") : "";
        if (
          !(
            LogicUtils.isNonEmptyString(value) &&
            LogicUtils.isNonEmptyString(key$1)
          )
        ) {
          return;
        }
        var isformat = searchkeysDict !== {};
        var value$1;
        if (isformat) {
          var intSearchKeys = LogicUtils.getArrayFromDict(
            searchkeysDict,
            "intSearchKeys",
            [],
          );
          var arrSearchKeys = LogicUtils.getArrayFromDict(
            searchkeysDict,
            "arrSearchKeys",
            [],
          );
          value$1 = intSearchKeys.includes(key$1)
            ? LogicUtils.getFloatFromString(value, 0.0)
            : arrSearchKeys.includes(key$1)
              ? value.split(",").map(function (str) {
                  return str;
                })
              : value;
        } else {
          value$1 = value;
        }
        filterDict[key$1] = value$1;
      });
    } else {
      var key$1 = LogicUtils.toCamelCase(
        LogicUtils.getString(
          filterDict,
          Core__Option.getOr(dropdownSearchKeyValueNames[0], ""),
          "",
        ),
      );
      var value$1 = LogicUtils.getString(
        filterDict,
        Core__Option.getOr(dropdownSearchKeyValueNames[1], ""),
        "",
      );
      if (LogicUtils.isNonEmptyString(value$1)) {
        var isformat = searchkeysDict !== {};
        var value$2;
        if (isformat) {
          var intSearchKeys = LogicUtils.getArrayFromDict(
            searchkeysDict,
            "intSearchKeys",
            [],
          );
          var arrSearchKeys = LogicUtils.getArrayFromDict(
            searchkeysDict,
            "arrSearchKeys",
            [],
          );
          value$2 = intSearchKeys.includes(key$1)
            ? LogicUtils.getFloatFromString(value$1, 0.0)
            : arrSearchKeys.includes(key$1)
              ? value$1.split(",").map(function (str) {
                  return str;
                })
              : value$1;
        } else {
          value$2 = value$1;
        }
        filterDict[key$1] = value$2;
      }
    }
  }
  if (isEulerOrderEntity) {
    var arr = Core__Option.isSome(filterDict["customerId"])
      ? [LogicUtils.getJsonFromArrayOfString(["date_created", "DESC"])]
      : [];
    filterDict["order"] = arr;
  }
  return filterDict;
}

function getStrFromJson(key, val) {
  var str = Core__JSON.Classify.classify(val);
  if (typeof str !== "object") {
    return "";
  }
  switch (str.TAG) {
    case "String":
      return str._0;
    case "Number":
      if (key === "offset") {
        return "0";
      } else {
        return (str._0 | 0).toString();
      }
    case "Array":
      var array = str._0;
      if (array.length > 0) {
        return "[" + array.join(",") + "]";
      } else {
        return "";
      }
    default:
      return "";
  }
}

function getInitialValuesFromUrl(
  searchParams,
  initialFilters,
  optionsOpt,
  mandatoryRemoteKeysOpt,
  param,
) {
  var options = optionsOpt !== undefined ? optionsOpt : [];
  var mandatoryRemoteKeys =
    mandatoryRemoteKeysOpt !== undefined ? mandatoryRemoteKeysOpt : [];
  var initialFilters$1 = initialFilters.map(function (item) {
    return item.field;
  });
  var dict = {};
  var searchParams$1 = LogicUtils.stringReplaceAll(searchParams, "%20", " ");
  if (searchParams$1.length > 0) {
    var splitUrlArray = searchParams$1.split("&");
    var entriesList = [];
    var keyList = [];
    var valueList = [];
    splitUrlArray.forEach(function (filterKeyVal) {
      var splitArray = filterKeyVal.split("=");
      var keyStartIndex =
        (Core__Option.getOr(splitArray[0], "").lastIndexOf("-") + 1) | 0;
      var key = Core__Option.getOr(splitArray[0], "").slice(keyStartIndex);
      keyList.push(key);
      splitArray.shift();
      var value = splitArray.join("=");
      valueList.push(value);
      entriesList.push([key, value]);
    });
    entriesList.forEach(function (entry) {
      var value = entry[1];
      var key = entry[0];
      initialFilters$1.forEach(function (filter) {
        filter.inputNames.forEach(function (name) {
          if (name === key) {
            dict[key] = UrlFetchUtils.getFilterValue(value);
            return;
          }
        });
      });
      options.forEach(function (option) {
        var fieldName = option.urlKey;
        if (fieldName === key) {
          dict[key] = UrlFetchUtils.getFilterValue(value);
          return;
        }
      });
      mandatoryRemoteKeys.forEach(function (searchKey) {
        if (searchKey === key) {
          dict[key] = UrlFetchUtils.getFilterValue(value);
          return;
        }
      });
    });
  }
  return dict;
}

function getLocalFiltersData(
  resArr,
  searchParams,
  initialFilters,
  dateRangeFilterDict,
  options,
  param,
) {
  var res = {
    contents: resArr,
  };
  if (searchParams.length > 0) {
    var splitUrlArray = searchParams.split("&");
    var keyList = [];
    var valueList = [];
    splitUrlArray.forEach(function (filterKeyVal) {
      var splitArray = filterKeyVal.split("=");
      var keyStartIndex =
        (Core__Option.getOr(splitArray[0], "").lastIndexOf("-") + 1) | 0;
      var key = Core__Option.getOr(splitArray[0], "").slice(keyStartIndex);
      keyList.push(key);
      valueList.push(Core__Option.getOr(splitArray[1], ""));
    });
    var dateRange = LogicUtils.getArrayFromDict(
      dateRangeFilterDict,
      "dateRange",
      [],
    );
    var startKey = LogicUtils.getStringFromJson(
      Core__Option.getOr(dateRange[0], ""),
      "",
    );
    var endKey = LogicUtils.getStringFromJson(
      Core__Option.getOr(dateRange[1], ""),
      "",
    );
    var match;
    if (
      Caml_obj.notequal(dateRangeFilterDict, {}) &&
      LogicUtils.isNonEmptyString(startKey) &&
      LogicUtils.isNonEmptyString(endKey) &&
      keyList.includes(startKey) &&
      keyList.includes(endKey)
    ) {
      var start_Date = Core__Option.getOr(
        valueList[keyList.indexOf(startKey)],
        "",
      );
      var end_Date = Core__Option.getOr(valueList[keyList.indexOf(endKey)], "");
      var keyList$1 = keyList.filter(function (item) {
        if (item !== startKey) {
          return item !== endKey;
        } else {
          return false;
        }
      });
      var valueList$1 = valueList.filter(function (item) {
        if (item !== start_Date) {
          return item !== end_Date;
        } else {
          return false;
        }
      });
      keyList$1.push(startKey);
      valueList$1.push(start_Date + "&" + end_Date);
      match = [keyList$1, valueList$1];
    } else {
      match = [keyList, valueList];
    }
    var valueList$2 = match[1];
    match[0].forEach(function (key, idx) {
      initialFilters.forEach(function (filter) {
        var field = filter.field;
        var localFilter = filter.localFilter;
        field.inputNames.forEach(function (name) {
          if (name !== key) {
            return;
          }
          var value = Core__Option.getOr(valueList$2[idx], "");
          if (!value.includes("[")) {
            res.contents =
              localFilter !== undefined
                ? localFilter(res.contents, value)
                : res.contents;
            return;
          }
          var str = value.slice(1, (value.length - 1) | 0);
          var splitArray = str.split(",");
          var jsonarr = splitArray.map(function (val) {
            return val;
          });
          res.contents =
            localFilter !== undefined
              ? localFilter(res.contents, jsonarr)
              : res.contents;
        });
      });
      options.forEach(function (option) {
        var fieldName = option.urlKey;
        var localFilter = option.localFilter;
        if (fieldName === key) {
          res.contents =
            localFilter !== undefined
              ? localFilter(
                  res.contents,
                  Core__Option.getOr(valueList$2[idx], ""),
                )
              : res.contents;
          return;
        }
      });
    });
  }
  return res.contents;
}

function generateUrlFromDict(dict, options, tableName) {
  return Belt_Array.keepMap(Object.entries(dict), function (entry) {
    var val = entry[1];
    var key = entry[0];
    var strValue = getStrFromJson(key, val);
    if (!LogicUtils.isNonEmptyString(strValue)) {
      return;
    }
    var requiredOption = options.find(function (option) {
      return option.urlKey === key;
    });
    if (requiredOption !== undefined) {
      var finalVal = requiredOption.parser(val);
      dict[key] = finalVal;
    } else {
      dict[key] = val;
    }
    var finalKey = tableName !== undefined ? tableName.concat("-" + key) : key;
    return finalKey + "=" + strValue;
  }).join("&");
}

function applyFilters(
  currentFilterDict,
  defaultFilters,
  setOffset,
  path,
  existingFilterDict,
  options,
  ignoreUrlUpdateOpt,
  setLocalSearchFilters,
  tableName,
  updateUrlWith,
  param,
) {
  var ignoreUrlUpdate =
    ignoreUrlUpdateOpt !== undefined ? ignoreUrlUpdateOpt : false;
  var dict = {};
  var currentFilterUrl = generateUrlFromDict(
    currentFilterDict,
    options,
    tableName,
  );
  var existingFilterUrl = generateUrlFromDict(
    existingFilterDict,
    options,
    tableName,
  );
  var originalDict = Core__JSON.Decode.object(defaultFilters);
  if (originalDict !== undefined) {
    Object.entries(originalDict).forEach(function (entry) {
      dict[entry[0]] = entry[1];
    });
  }
  if (setOffset !== undefined) {
    setOffset(function (param) {
      return 0;
    });
  }
  var match =
    LogicUtils.isNonEmptyString(existingFilterUrl) &&
    LogicUtils.isNonEmptyString(currentFilterUrl)
      ? [
          existingFilterUrl + "&" + currentFilterUrl,
          Object.fromEntries(
            Object.entries(existingFilterDict).concat(
              Object.entries(currentFilterDict),
            ),
          ),
        ]
      : LogicUtils.isNonEmptyString(existingFilterUrl)
        ? [existingFilterUrl, existingFilterDict]
        : LogicUtils.isNonEmptyString(currentFilterUrl)
          ? [currentFilterUrl, currentFilterDict]
          : ["", {}];
  var localSearchUrl = match[0];
  if (ignoreUrlUpdate) {
    if (setLocalSearchFilters !== undefined) {
      return setLocalSearchFilters(function (param) {
        return localSearchUrl;
      });
    } else {
      return;
    }
  }
  var finalCompleteUrl = LogicUtils.isNonEmptyString(localSearchUrl)
    ? path + "?" + localSearchUrl
    : path;
  if (updateUrlWith !== undefined) {
    return updateUrlWith(
      Object.fromEntries(
        Object.entries(match[1]).map(function (item) {
          var key = item[0];
          return [key, getStrFromJson(key, item[1])];
        }),
      ),
    );
  } else {
    return RescriptReactRouter.push(finalCompleteUrl);
  }
}

export {
  getFinalDict,
  getStrFromJson,
  getInitialValuesFromUrl,
  getLocalFiltersData,
  generateUrlFromDict,
  applyFilters,
};
/* LogicUtils Not a pure module */
