// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.js";
import * as Core__Float from "@rescript/core/src/Core__Float.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as DateTimeUtils from "../../utils/DateTimeUtils.bs.js";
import * as AnalyticsUtils from "../../screens/Analytics/AnalyticsUtils.bs.js";

var defaultColor = "#7cb5ec";

var legendColor = [
  defaultColor,
  "#90ed7d",
  "#f7a35c",
  "#8085e9",
  "#f15c80",
  "#e4d354",
  "#2b908f",
  "#f45b5b",
  "#91e8e1",
];

function defaultLegendColorGradients(topGradient, bottomGradient) {
  return {
    linearGradient: [0, 0, 0, 300],
    color: "#7cb5ec",
    stops: [
      [0, "rgba(124,181,236, " + topGradient + ")"],
      [1, "rgba(124,170,236, " + bottomGradient + ")"],
    ],
  };
}

function legendColorGradients(topGradient, bottomGradient) {
  return [
    defaultLegendColorGradients(topGradient, bottomGradient),
    {
      linearGradient: [0, 0, 0, 300],
      color: "#434348",
      stops: [
        [0, "rgba(141, 103, 203, " + topGradient + ")"],
        [1, "rgba(141, 93, 203, " + bottomGradient + ")"],
      ],
    },
    {
      linearGradient: [0, 0, 0, 300],
      color: "#90ed7d",
      stops: [
        [0, "rgba(144, 237, 125, " + topGradient + ")"],
        [1, "rgba(144, 227, 125, " + bottomGradient + ")"],
      ],
    },
    {
      linearGradient: [0, 0, 0, 300],
      color: "#f7a35c",
      stops: [
        [0, "rgba(247,163,92, " + topGradient + ")"],
        [1, "rgba(247,153,92, " + bottomGradient + ")"],
      ],
    },
    {
      linearGradient: [0, 0, 0, 300],
      color: "#8085e9",
      stops: [
        [0, "rgba(128, 133, 233, " + topGradient + ")"],
        [1, "rgba(128, 123, 233, " + bottomGradient + ")"],
      ],
    },
    {
      linearGradient: [0, 0, 0, 300],
      color: "#f15c80",
      stops: [
        [0, "rgba(241, 92, 128, " + topGradient + ")"],
        [1, "rgba(241, 82, 128, " + bottomGradient + ")"],
      ],
    },
    {
      linearGradient: [0, 0, 0, 300],
      color: "#e4d354",
      stops: [
        [0, "rgba(228, 211, 84, " + topGradient + ")"],
        [1, "rgba(228, 201, 84, " + bottomGradient + ")"],
      ],
    },
    {
      linearGradient: [0, 0, 0, 300],
      color: "#2b908f",
      stops: [
        [0, "rgba(43, 144, 143, " + topGradient + ")"],
        [1, "rgba(43, 134, 143, " + bottomGradient + ")"],
      ],
    },
    {
      linearGradient: [0, 0, 0, 300],
      color: "#f45b5b",
      stops: [
        [0, "rgba(244, 91, 91, " + topGradient + ")"],
        [1, "rgba(244, 81, 91, " + bottomGradient + ")"],
      ],
    },
    {
      linearGradient: [0, 0, 0, 300],
      color: "#91e8e1",
      stops: [
        [0, "rgba(145, 232, 225, " + topGradient + ")"],
        [1, "rgba(145, 222, 225, " + bottomGradient + ")"],
      ],
    },
  ];
}

function reduceOpacity(str) {
  var match = str.match(/rgba\(\d+,\s*\d+,\s*\d+,\s*([\d.]+)\)/);
  if (match === null) {
    return "0";
  }
  var opacity = Core__Option.getOr(
    Core__Option.flatMap(match[1], function (a) {
      return a;
    }),
    "0",
  );
  var newOpacity =
    Core__Option.getOr(Core__Float.fromString(opacity), 0.0) / 10.0;
  return str.replace(opacity, newOpacity.toString());
}

function removeDuplicates(arr) {
  var uniqueItemsMap = {};
  arr.forEach(function (item) {
    var value = item.name;
    if (Core__Option.isNone(uniqueItemsMap[value])) {
      uniqueItemsMap[value] = item;
      return;
    }
  });
  return Object.values(uniqueItemsMap);
}

function calculateOpacity(length, originalOpacity) {
  var reducedOpacity = originalOpacity * Math.pow(0.4, length / 13.0);
  return Math.max(reducedOpacity, 0.0).toString();
}

function legendTypeBasedOnMetric(metric_type) {
  switch (metric_type) {
    case "Volume":
      return ["Overall", "Average"];
    case "Amount":
      return ["Average", "Overall"];
    default:
      return ["Current", "Average"];
  }
}

function appendToDictValue(dict, key, value) {
  var val = dict[key];
  var updatedValue = val !== undefined ? val.concat([value]) : [value];
  dict[key] = updatedValue;
}

function addToDictValueFloat(dict, key, value) {
  var val = dict[key];
  var updatedValue = val !== undefined ? val + value : value;
  dict[key] = updatedValue;
}

function chartDataSortBasedOnTime(a, b) {
  var timeb = b[0];
  var time = a[0];
  if (time < timeb) {
    return -1;
  } else if (time > timeb) {
    return 1;
  } else {
    return 0;
  }
}

function sortBasedOnTimeLegend(a, b) {
  var timeb = b[0];
  var time = a[0];
  if (time < timeb) {
    return -1;
  } else if (time > timeb) {
    return 1;
  } else {
    return 0;
  }
}

function sortBasedOnArr(arr) {
  return function (a, b) {
    if (arr.indexOf(a.groupByName) < arr.indexOf(b.groupByName)) {
      return -1;
    } else if (arr.indexOf(a.groupByName) > arr.indexOf(b.groupByName)) {
      return 1;
    } else {
      return 0;
    }
  };
}

function legendIndexFunc(name) {
  if (name === "Others") {
    return 30;
  } else {
    return 0;
  }
}

function timeSeriesDataMaker(
  data,
  groupKey,
  xAxis,
  metricsConfig,
  commonColors,
  selectedTab,
  param,
) {
  var colors = commonColors !== undefined ? commonColors : [];
  var yAxis = metricsConfig.metric_name_db;
  var metrixType = metricsConfig.metric_type;
  var secondryMetrics = metricsConfig.secondryMetrics;
  var timeSeriesDict = {};
  var groupedByTime = {};
  data.map(function (item) {
    var dict = LogicUtils.getDictFromJsonObject(item);
    var groupByName =
      selectedTab !== undefined
        ? selectedTab
            .map(function (key) {
              return LogicUtils.getString(
                dict,
                key,
                JSON.stringify(Core__Option.getOr(dict[key], "")),
              );
            })
            .map(LogicUtils.snakeToTitle)
            .join(" : ")
        : LogicUtils.getString(
            dict,
            groupKey,
            JSON.stringify(Core__Option.getOr(dict[groupKey], "")),
          );
    var xAxisDataPoint =
      LogicUtils.getString(dict, xAxis, "").split(" ").join("T") + "Z";
    var yAxisDataPoint = LogicUtils.getFloat(dict, yAxis, 0);
    var secondryAxisPoint =
      secondryMetrics !== undefined
        ? LogicUtils.getFloat(dict, secondryMetrics.metric_name_db, 0)
        : undefined;
    if (LogicUtils.isNonEmptyString(LogicUtils.getString(dict, xAxis, ""))) {
      appendToDictValue(timeSeriesDict, groupByName, [
        DateTimeUtils.parseAsFloat(xAxisDataPoint),
        yAxisDataPoint,
        secondryAxisPoint,
      ]);
      return addToDictValueFloat(
        groupedByTime,
        DateTimeUtils.parseAsFloat(xAxisDataPoint).toString(),
        yAxisDataPoint,
      );
    }
  });
  var timeSeriesArr = Object.entries(timeSeriesDict);
  var chartOverlapping = timeSeriesArr.length;
  var topGradient = calculateOpacity(chartOverlapping, 0.5);
  var bottomGradient = calculateOpacity(chartOverlapping, 0.05);
  return timeSeriesArr.map(function (item, index) {
    var value = item[1];
    var key = item[0];
    var sortedValBasedOnTime;
    sortedValBasedOnTime =
      metrixType === "Traffic"
        ? value
            .map(function (item) {
              var key = item[0];
              var trafficValue =
                (item[1] * 100) /
                Core__Option.getOr(groupedByTime[key.toString()], 1);
              return [key, trafficValue, item[2]];
            })
            .toSorted(chartDataSortBasedOnTime)
        : value.toSorted(chartDataSortBasedOnTime);
    var val = colors.find(function (item) {
      return item.name === key;
    });
    var color =
      val !== undefined
        ? val.color
        : Core__Option.getOr(
            legendColor[Caml_int32.mod_(index, legendColor.length)],
            defaultColor,
          );
    var val$1 = legendColorGradients(topGradient, bottomGradient).find(
      function (item) {
        return Core__Option.getOr(item.color, "#000000") === color;
      },
    );
    var fillColor =
      val$1 !== undefined
        ? val$1
        : Core__Option.getOr(
            legendColorGradients(topGradient, bottomGradient)[
              Caml_int32.mod_(index, legendColor.length)
            ],
            defaultLegendColorGradients(topGradient, bottomGradient),
          );
    return {
      color: color,
      name: key,
      data: sortedValBasedOnTime,
      legendIndex: legendIndexFunc(key),
      fillColor: fillColor,
    };
  });
}

function getLegendDataForCurrentMetrix(
  yAxis,
  timeSeriesData,
  groupedData,
  activeTab,
  xAxis,
  metrixType,
) {
  var currentAvgDict = {};
  var orderedDims = groupedData.map(function (item) {
    var dict = LogicUtils.getDictFromJsonObject(item);
    return LogicUtils.getString(
      dict,
      activeTab,
      JSON.stringify(Core__Option.getOr(dict[activeTab], "")),
    );
  });
  timeSeriesData.forEach(function (item) {
    var dict = LogicUtils.getDictFromJsonObject(item);
    var time_overall_statsAtTime_0 = LogicUtils.getString(dict, xAxis, "");
    var time_overall_statsAtTime_1 = LogicUtils.getFloat(dict, yAxis, 0);
    var time_overall_statsAtTime = [
      time_overall_statsAtTime_0,
      time_overall_statsAtTime_1,
    ];
    appendToDictValue(
      currentAvgDict,
      LogicUtils.getString(
        dict,
        activeTab,
        JSON.stringify(Core__Option.getOr(dict[activeTab], "")),
      ),
      time_overall_statsAtTime,
    );
  });
  var currentAvgSortedDict = Object.entries(currentAvgDict).map(
    function (item) {
      return [item[0], item[1].toSorted(sortBasedOnTimeLegend)];
    },
  );
  var currentValueOverallSum = AnalyticsUtils.sumOfArrFloat(
    currentAvgSortedDict.map(function (item) {
      var value = item[1];
      return Core__Option.getOr(value[(value.length - 1) | 0], ["", 0])[1];
    }),
  );
  var currentAvgDict$1;
  if (groupedData.length === 0) {
    currentAvgDict$1 = Object.entries(currentAvgDict).map(function (item) {
      var sortedValueBasedOnTime = item[1].toSorted(sortBasedOnTimeLegend);
      var arrLen = sortedValueBasedOnTime.length;
      var match = Core__Option.getOr(sortedValueBasedOnTime[(arrLen - 1) | 0], [
        "",
        1.0,
      ]);
      var overall = Core__Array.reduce(
        sortedValueBasedOnTime.map(function (item) {
          return item[1];
        }),
        0,
        function (acc, value) {
          return acc + value;
        },
      );
      return {
        groupByName: item[0],
        overall: overall,
        average: overall / arrLen,
        current: match[1],
      };
    });
  } else {
    var currentOverall = {};
    groupedData.forEach(function (item) {
      var dict = LogicUtils.getDictFromJsonObject(item);
      currentOverall[LogicUtils.getString(dict, activeTab, "")] =
        LogicUtils.getFloat(dict, yAxis, 0);
    });
    var totalOverall = AnalyticsUtils.sumOfArrFloat(
      Object.entries(currentOverall).map(function (item) {
        return item[1];
      }),
    );
    currentAvgDict$1 = Object.entries(currentAvgDict).map(function (item) {
      var metricsName = item[0];
      var sortedValueBasedOnTime = item[1].toSorted(sortBasedOnTimeLegend);
      var arrLen = sortedValueBasedOnTime.length;
      var match = Core__Option.getOr(sortedValueBasedOnTime[(arrLen - 1) | 0], [
        "",
        0,
      ]);
      var currentVal = match[1];
      var overall =
        metrixType === "Traffic"
          ? Core__Option.getOr(
              Core__Float.fromString(
                LogicUtils.removeTrailingZero(
                  (
                    (Core__Option.getOr(currentOverall[metricsName], 0) * 100) /
                    Math.max(totalOverall, 1)
                  ).toFixed(2),
                ),
              ),
              0,
            )
          : Core__Option.getOr(currentOverall[metricsName], 0);
      var currentVal$1 =
        metrixType === "Traffic"
          ? (currentVal * 100) / currentValueOverallSum
          : currentVal;
      return {
        groupByName: metricsName,
        overall: overall,
        average: overall / arrLen,
        current: currentVal$1,
      };
    });
  }
  var sortBasedOnArr$1 = sortBasedOnArr(orderedDims);
  return currentAvgDict$1
    .toSorted(sortBasedOnArr$1)
    .map(function (item, index) {
      var newrecord = Caml_obj.obj_dup(item);
      newrecord.index = index;
      return newrecord;
    });
}

function barChartDataMaker(yAxis, rawData, activeTab) {
  var value = Belt_Array.keepMap(rawData, function (item) {
    var dict = LogicUtils.getDictFromJsonObject(item);
    var selectedSegmentVal = LogicUtils.getString(dict, activeTab, "");
    var stats = LogicUtils.getFloat(dict, yAxis, 0);
    if (LogicUtils.isNonEmptyString(selectedSegmentVal)) {
      return [selectedSegmentVal, stats];
    }
  });
  var val_color = "#4C8CFB";
  var val_data = value.map(function (item) {
    return item[1];
  });
  var val = {
    color: val_color,
    data: val_data,
  };
  return [
    value.map(function (item) {
      return item[0];
    }),
    [val],
  ];
}

function chartLegendTypeToStr(chartLegendType) {
  switch (chartLegendType) {
    case "Overall":
      return "Overall";
    case "Average":
      return "Average";
    case "Current":
      return "Current";
    default:
      return "";
  }
}

function legendClickItem(s, e, setState) {
  e.preventDefault();
  s.chart.series.forEach(function (x) {
    if (x === s) {
      return setState(function (prev) {
        var value = prev.includes(x)
          ? prev.filter(function (item) {
              return item !== x;
            })
          : prev.concat([x]);
        if (value.length === 0) {
          s.chart.series.forEach(function (y) {
            y.show();
          });
        } else {
          s.chart.series.forEach(function (y) {
            if (value.includes(y)) {
              y.show();
            } else {
              y.hide();
            }
          });
        }
        return value;
      });
    }
  });
}

function formatStatsAccToMetrix(metric, value) {
  var exit = 0;
  switch (metric) {
    case "Latency":
      return LogicUtils.latencyShortNum(value, undefined, undefined);
    case "Volume":
    case "Amount":
      exit = 1;
      break;
    case "Rate":
    case "Traffic":
      exit = 2;
      break;
  }
  switch (exit) {
    case 1:
      return LogicUtils.shortNum(
        value,
        LogicUtils.getDefaultNumberFormat(),
        undefined,
        undefined,
      );
    case 2:
      return LogicUtils.removeTrailingZero(value.toFixed(2)) + "%";
  }
}

function formatLabels(metric, value) {
  var formattedValue = formatStatsAccToMetrix(metric.metric_type, value);
  var val = metric.thresholdVal;
  if (val !== undefined && val === value) {
    return (
      '<span style="font-size: 11px; color: white; cursor: default;  background-color: #EE6E73;padding: 2px 10px;border-radius: 10px; display: flex">\n    ' +
      formattedValue +
      "\n   </span>"
    );
  } else {
    return formattedValue;
  }
}

function getTooltipHTML(metrics, data, onCursorName, index, length) {
  var metric_type = metrics.metric_type;
  var name = data[0];
  var secondryMetrics = metrics.secondryMetrics;
  var secondry_metrix_val =
    secondryMetrics !== undefined
      ? formatStatsAccToMetrix(
          secondryMetrics.metric_type,
          Core__Option.getOr(data[3], 0),
        )
      : "";
  var spacing =
    index !== ((length - 1) | 0) ? "<tr style='height: 10px;'></tr>" : "";
  var highlight =
    onCursorName === name ? "font-weight:900;font-size:13px;" : "opacity:60%;";
  return (
    "<tr>\n      <td><span style='height:10px; width:10px;margin-top:5px;display:inline-block; background-color:" +
    data[1] +
    ";border-radius:3px;margin-right:3px;fontFamily:\"Inter\"'/></td>\n      <td><span style='" +
    highlight +
    ";padding-right: 10px;'>" +
    LogicUtils.snakeToTitle(name) +
    "</span></td>\n      <td><span style=" +
    highlight +
    ">" +
    formatStatsAccToMetrix(metric_type, data[2]) +
    "</span></td>\n      <td><span style=" +
    highlight +
    ">" +
    secondry_metrix_val +
    "</span></td>\n  </tr>\n  " +
    spacing
  );
}

function tooltipFormatter(metrics, xAxisMapInfo, groupKey) {
  return function () {
    var points = this;
    var points$1 = LogicUtils.getDictFromJsonObject(points);
    var series = LogicUtils.getDictFromJsonObject(
      LogicUtils.getJsonObjectFromDict(points$1, "series"),
    );
    var dataArr;
    if (["run_date", "run_month", "run_week"].includes(groupKey)) {
      var x = LogicUtils.getString(points$1, "name", "");
      dataArr = Core__Option.getOr(xAxisMapInfo[x], []);
    } else {
      var x$1 = LogicUtils.getFloat(points$1, "x", 0);
      dataArr = Core__Option.getOr(xAxisMapInfo[x$1.toString()], []);
    }
    var onCursorName = LogicUtils.getString(series, "name", "");
    var htmlStr = dataArr
      .map(function (data, i) {
        return getTooltipHTML(metrics, data, onCursorName, i, dataArr.length);
      })
      .join("");
    return "<table>" + htmlStr + "</table>";
  };
}

function legendItemStyle(theme, legendFontSizeClass) {
  if (theme === "Light") {
    return {
      color: "rgba(53, 64, 82, 0.8)",
      cursor: "pointer",
      fontSize: legendFontSizeClass,
      fontWeight: "500",
      fontFamily: "Inter",
      fontStyle: "normal",
    };
  } else {
    return {
      color: "#c7cad0",
      cursor: "pointer",
      fontSize: legendFontSizeClass,
      fontWeight: "500",
      fontFamily: "Inter",
      fontStyle: "normal",
    };
  }
}

function legendHiddenStyle(theme) {
  return function (legendFontFamilyClass, legendFontSizeClass) {
    if (theme === "Light") {
      return {
        color: "rgba(53, 64, 82, 0.2)",
        cursor: "pointer",
        fontSize: legendFontSizeClass,
        fontWeight: "500",
        fontFamily: legendFontFamilyClass,
        fontStyle: "normal",
      };
    } else {
      return {
        color: "#c7cad020",
        cursor: "pointer",
        fontSize: legendFontSizeClass,
        fontWeight: "500",
        fontFamily: legendFontFamilyClass,
        fontStyle: "normal",
      };
    }
  };
}

function chartTitleStyle(theme) {
  if (theme === "Light") {
    return {
      color: "#474D59",
      fontSize: "16px",
      fontWeight: "500",
      fontStyle: "normal",
    };
  } else {
    return {
      color: "#f6f8f9",
      fontSize: "13px",
      fontWeight: "500",
      fontStyle: "normal",
    };
  }
}

function getGranularityNew(startTime, endTime) {
  var diff =
    (DateTimeUtils.parseAsFloat(endTime) -
      DateTimeUtils.parseAsFloat(startTime)) /
    (1000 * 60);
  if (diff < 60 * 6) {
    return [
      [15, "minute"],
      [5, "minute"],
    ];
  } else if (diff < 60 * 24) {
    return [
      [1, "hour"],
      [30, "minute"],
      [15, "minute"],
    ];
  } else if (diff < 60 * 24 * 7) {
    return [
      [1, "day"],
      [3, "hour"],
    ];
  } else if (diff <= 60 * 24 * 62) {
    return [
      [1, "week"],
      [1, "day"],
    ];
  } else {
    return [[1, "week"]];
  }
}

function getGranularityNewStr(startTime, endTime) {
  return getGranularityNew(startTime, endTime).map(function (item) {
    var unit = item[1];
    var val = item[0];
    if (val === 1) {
      if (unit === "day") {
        return "Daily";
      } else if (unit === "week") {
        return "Weekly";
      } else if (unit === "hour") {
        return "Hourly";
      } else {
        return unit;
      }
    } else {
      return val.toString() + " " + unit;
    }
  });
}

function chartDataMaker(filterNullOpt, rawData, groupKey, metric) {
  var filterNull = filterNullOpt !== undefined ? filterNullOpt : false;
  var sortDescending = function (obj1, obj2) {
    var val2 = obj2[1];
    var val1 = obj1[1];
    if (Caml_obj.greaterthan(val1, val2)) {
      return -1;
    } else if (val1 === val2) {
      return 0;
    } else {
      return 1;
    }
  };
  return rawData
    .filter(function (dataPoint) {
      if (!filterNull) {
        return true;
      }
      var dataPointDict = LogicUtils.getDictFromJsonObject(dataPoint);
      return LogicUtils.getString(dataPointDict, groupKey, "") !== "NA";
    })
    .map(function (dataPoint) {
      var dataPointDict = LogicUtils.getDictFromJsonObject(dataPoint);
      return [
        LogicUtils.snakeToTitle(
          LogicUtils.getString(dataPointDict, groupKey, "").toLowerCase(),
        ),
        Number(LogicUtils.getString(dataPointDict, metric, "")),
      ];
    })
    .toSorted(sortDescending);
}

export {
  defaultColor,
  legendColor,
  defaultLegendColorGradients,
  legendColorGradients,
  reduceOpacity,
  removeDuplicates,
  calculateOpacity,
  legendTypeBasedOnMetric,
  appendToDictValue,
  addToDictValueFloat,
  chartDataSortBasedOnTime,
  sortBasedOnTimeLegend,
  sortBasedOnArr,
  legendIndexFunc,
  timeSeriesDataMaker,
  getLegendDataForCurrentMetrix,
  barChartDataMaker,
  chartLegendTypeToStr,
  legendClickItem,
  formatStatsAccToMetrix,
  formatLabels,
  getTooltipHTML,
  tooltipFormatter,
  legendItemStyle,
  legendHiddenStyle,
  chartTitleStyle,
  getGranularityNew,
  getGranularityNewStr,
  chartDataMaker,
};
/* LogicUtils Not a pure module */
