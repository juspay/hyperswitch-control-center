// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Icon from "../Icon.bs.js";
import * as React from "react";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as RenderIf from "../../utils/RenderIf.bs.js";
import * as LogicUtils from "../../utils/LogicUtils.bs.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as ThemeProvider from "../../context/ThemeProvider.bs.js";
import * as AddDataAttributes from "../AddDataAttributes.bs.js";
import * as JsxPPXReactSupportU from "rescript/lib/es6/jsxPPXReactSupportU.js";

function ToolTip$TooltipMainWrapper(props) {
  var setIsToolTipVisible = props.setIsToolTipVisible;
  var hoverOnToolTip = props.hoverOnToolTip;
  var visibleOnClick = props.visibleOnClick;
  var relativeClass = props.isRelative ? "relative" : "";
  var flexCss = hoverOnToolTip ? "inline-flex" : "flex";
  var alignClass;
  switch (props.contentAlign) {
    case "Left":
      alignClass = "items-start";
      break;
    case "Right":
      alignClass = "items-end";
      break;
    case "Middle":
      alignClass = "items-center";
      break;
    case "Default":
      alignClass = "";
      break;
  }
  var timeoutRef = React.useRef(undefined);
  var handleMouseOver = function (_evt) {
    if (visibleOnClick) {
      return;
    }
    var timerId = timeoutRef.current;
    if (timerId !== undefined) {
      clearTimeout(Caml_option.valFromOption(timerId));
    }
    setIsToolTipVisible(function (param) {
      return true;
    });
  };
  var handleClick = function (_evt) {
    if (!visibleOnClick) {
      return;
    }
    var timerId = timeoutRef.current;
    if (timerId !== undefined) {
      clearTimeout(Caml_option.valFromOption(timerId));
    }
    setIsToolTipVisible(function (param) {
      return true;
    });
  };
  var handleMouseOut = function (_evt) {
    if (hoverOnToolTip) {
      timeoutRef.current = Caml_option.some(
        setTimeout(function () {
          setIsToolTipVisible(function (param) {
            return false;
          });
        }, 200),
      );
      return;
    } else {
      return setIsToolTipVisible(function (param) {
        return false;
      });
    }
  };
  return React.createElement(AddDataAttributes.make, {
    attributes: [["data-tooltip", "tooltip"]],
    children: React.createElement(
      "div",
      {
        className:
          relativeClass +
          " " +
          flexCss +
          " " +
          props.flexClass +
          " " +
          props.height +
          " " +
          alignClass +
          " " +
          props.justifyClass,
        onClick: handleClick,
        onMouseOut: handleMouseOut,
        onMouseOver: handleMouseOver,
      },
      props.children,
    ),
  });
}

function getToolTipFixedStyling(
  hoverOnToolTip,
  positionX,
  positionY,
  tooltipWidth,
  tooltipHeight,
  tooltipArrowSize,
  componentWidth,
  componentHeight,
  position,
) {
  var toolTipTopPosition;
  var exit = 0;
  switch (position) {
    case "Top":
      toolTipTopPosition = hoverOnToolTip
        ? (((((((positionY - tooltipHeight) | 0) - 4) | 0) -
            ((tooltipArrowSize - 5) | 0)) |
            0) -
            4) |
          0
        : (((((positionY - tooltipHeight) | 0) - 4) | 0) - 4) | 0;
      break;
    case "Bottom":
      toolTipTopPosition = hoverOnToolTip
        ? (((((((positionY + componentHeight) | 0) + 4) | 0) +
            ((tooltipArrowSize - 5) | 0)) |
            0) +
            4) |
          0
        : (((((positionY + componentHeight) | 0) + 4) | 0) + 4) | 0;
      break;
    case "Left":
    case "Right":
      exit = 1;
      break;
    case "TopRight":
    case "TopLeft":
      exit = 3;
      break;
    case "BottomLeft":
    case "BottomRight":
      exit = 2;
      break;
  }
  switch (exit) {
    case 1:
      toolTipTopPosition =
        (((positionY - ((tooltipHeight / 2) | 0)) | 0) +
          ((componentHeight / 2) | 0)) |
        0;
      break;
    case 2:
      toolTipTopPosition =
        (((((positionY + componentHeight) | 0) + 4) | 0) + 4) | 0;
      break;
    case 3:
      toolTipTopPosition =
        (((((positionY - tooltipHeight) | 0) - 4) | 0) - 4) | 0;
      break;
  }
  var toolTipLeftPosition;
  var exit$1 = 0;
  switch (position) {
    case "Top":
    case "Bottom":
      exit$1 = 1;
      break;
    case "Left":
      toolTipLeftPosition = hoverOnToolTip
        ? (((((((((positionX - tooltipWidth) | 0) - 4) | 0) + 2) | 0) -
            ((tooltipArrowSize - 5) | 0)) |
            0) -
            4) |
          0
        : (((((((positionX - tooltipWidth) | 0) - 4) | 0) + 2) | 0) - 4) | 0;
      break;
    case "Right":
      toolTipLeftPosition = hoverOnToolTip
        ? (((((((positionX + componentWidth) | 0) + 4) | 0) +
            ((tooltipArrowSize - 5) | 0)) |
            0) +
            4) |
          0
        : (((((positionX + componentWidth) | 0) + 4) | 0) + 4) | 0;
      break;
    case "TopLeft":
    case "BottomLeft":
      exit$1 = 2;
      break;
    case "TopRight":
    case "BottomRight":
      exit$1 = 3;
      break;
  }
  switch (exit$1) {
    case 1:
      toolTipLeftPosition =
        (((positionX - ((tooltipWidth / 2) | 0)) | 0) +
          ((componentWidth / 2) | 0)) |
        0;
      break;
    case 2:
      toolTipLeftPosition =
        (((((positionX + ((componentWidth / 2) | 0)) | 0) - tooltipWidth) | 0) +
          9) |
        0;
      break;
    case 3:
      toolTipLeftPosition =
        (((positionX + ((componentWidth / 2) | 0)) | 0) - 9) | 0;
      break;
  }
  return {
    left: toolTipLeftPosition.toString() + "px",
    top: toolTipTopPosition.toString() + "px",
  };
}

function getToolTipAbsoluteStyling(
  tooltipArrowHeight,
  tooltipHeightFloat,
  tooltipArrowWidth,
  tooltipWidth,
  componentWidth,
  componentHeight,
  position,
) {
  var toolTipTopPosition;
  var exit = 0;
  switch (position) {
    case "Left":
    case "Right":
      exit = 2;
      break;
    case "Bottom":
    case "BottomLeft":
    case "BottomRight":
      exit = 1;
      break;
    default:
      toolTipTopPosition =
        (tooltipArrowHeight / componentHeight) * -100.0 +
        (tooltipHeightFloat / componentHeight) * -100.0;
  }
  switch (exit) {
    case 1:
      toolTipTopPosition =
        100.0 + (tooltipArrowHeight / componentHeight) * 100.0;
      break;
    case 2:
      toolTipTopPosition = 50.0 - (tooltipHeightFloat / componentHeight) * 50.0;
      break;
  }
  var toolTipLeftPosition;
  var exit$1 = 0;
  switch (position) {
    case "Top":
    case "Bottom":
      exit$1 = 1;
      break;
    case "Left":
      toolTipLeftPosition =
        (tooltipArrowWidth / componentWidth) * -100.0 +
        (tooltipWidth / componentWidth) * -100.0;
      break;
    case "Right":
      toolTipLeftPosition =
        100.0 + (tooltipArrowWidth / componentWidth) * 100.0;
      break;
    case "TopLeft":
    case "BottomLeft":
      toolTipLeftPosition = (tooltipWidth / componentWidth) * -50.0;
      break;
    case "TopRight":
    case "BottomRight":
      exit$1 = 2;
      break;
  }
  switch (exit$1) {
    case 1:
      toolTipLeftPosition = 50.0 - (tooltipWidth / componentWidth) * 50.0;
      break;
    case 2:
      toolTipLeftPosition = 100.0 + (tooltipWidth / componentWidth) * -60.0;
      break;
  }
  return {
    left: toolTipLeftPosition.toString() + "%",
    top: toolTipTopPosition.toString() + "%",
  };
}

function ToolTip$TooltipWrapper(props) {
  var defaultPosition = props.defaultPosition;
  var toolTipPosition = props.toolTipPosition;
  var componentHeight = props.componentHeight;
  var componentWidth = props.componentWidth;
  var tooltipWidth = props.tooltipWidth;
  var tooltipPositioning = props.tooltipPositioning;
  var hoverOnToolTip = props.hoverOnToolTip;
  var isToolTipVisible = props.isToolTipVisible;
  var descriptionExists =
    LogicUtils.isNonEmptyString(props.description) ||
    Caml_obj.notequal(props.descriptionComponent, null);
  var tooltipOpacity =
    isToolTipVisible && descriptionExists ? "opacity-100" : "opacity-0";
  var pointerEvents =
    isToolTipVisible && hoverOnToolTip ? "" : " pointer-events-none";
  var toolTipPositionString =
    tooltipPositioning === "fixed"
      ? "fixed"
      : tooltipPositioning === "static"
        ? "static"
        : "absolute";
  var tooltipPositionStyle =
    tooltipPositioning === "fixed"
      ? getToolTipFixedStyling(
          hoverOnToolTip,
          props.positionX,
          props.positionY,
          tooltipWidth,
          props.tooltipHeight,
          props.tooltipArrowSize,
          componentWidth,
          componentHeight,
          Core__Option.getOr(toolTipPosition, defaultPosition),
        )
      : getToolTipAbsoluteStyling(
          props.tooltipArrowHeight,
          props.tooltipHeightFloat,
          props.tooltipArrowWidth,
          tooltipWidth,
          componentWidth,
          componentHeight,
          Core__Option.getOr(toolTipPosition, defaultPosition),
        );
  return React.createElement(
    "div",
    {
      className: tooltipOpacity + " " + pointerEvents,
    },
    React.createElement(
      "div",
      {
        ref: Caml_option.some(props.toolTipRef),
        className:
          toolTipPositionString +
          " " +
          props.tooltipWidthClass +
          " z-50 h-auto break-words",
        style: Object.assign({}, tooltipPositionStyle, {
          hyphens: "auto",
        }),
      },
      React.createElement(
        "div",
        {
          className:
            "relative whitespace-pre-line max-w-xs text-left p-3 " +
            props.textStyle +
            " font-semibold rounded " +
            props.bgColor +
            " " +
            props.customStyle,
        },
        props.children,
      ),
    ),
  );
}

function ToolTip$DescriptionSection(props) {
  var setIsToolTipVisible = props.setIsToolTipVisible;
  return React.createElement(
    "div",
    {
      className: props.textStyleGap,
    },
    props.description
      .split("\n")
      .filter(function (str) {
        return LogicUtils.isNonEmptyString(str);
      })
      .map(function (item, i) {
        return JsxPPXReactSupportU.createElementWithKey(
          i.toString(),
          AddDataAttributes.make,
          {
            attributes: [["data-text", item]],
            children: React.createElement(
              "div",
              {
                key: item,
                className: "flex flex-col gap-1",
              },
              item,
            ),
          },
        );
      }),
    React.createElement(
      "div",
      {
        className: props.descriptionComponentClass,
      },
      React.createElement(RenderIf.make, {
        condition: props.dismissable,
        children: React.createElement(Icon.make, {
          name: "popUpClose",
          size: 20,
          className: "stroke-jp-2-dark-gray-2000 cursor-pointer",
          onClick: function (param) {
            setIsToolTipVisible(function (prev) {
              return !prev;
            });
          },
          parentClass: "mt-5 mr-4",
        }),
      }),
      props.descriptionComponent,
    ),
  );
}

function ToolTip$TooltipFor(props) {
  var toolTipFor = props.toolTipFor;
  return React.createElement(
    "div",
    {
      ref: Caml_option.some(props.componentRef),
      className: "inline h-min desktop:flex " + props.tooltipForWidthClass,
    },
    toolTipFor !== undefined
      ? Caml_option.valFromOption(toolTipFor)
      : React.createElement(Icon.make, {
          name: "tooltip_info",
          size: 16,
          className:
            "opacity-50 hover:opacity-100 dark:brightness-50 dark:opacity-35 dark:invert dark:hover:opacity-70 ",
        }),
  );
}

function getArrowFixedPosition(
  hoverOnToolTip,
  positionX,
  positionY,
  tooltipArrowSize,
  componentWidth,
  componentHeight,
  arrowColor,
  position,
) {
  var arrowTopPosition;
  var exit = 0;
  switch (position) {
    case "Top":
      arrowTopPosition = hoverOnToolTip
        ? (((((positionY - 4) | 0) - ((tooltipArrowSize - 5) | 0)) | 0) - 5) | 0
        : (((positionY - 4) | 0) - 5) | 0;
      break;
    case "Left":
    case "Right":
      exit = 1;
      break;
    case "TopRight":
    case "TopLeft":
      arrowTopPosition = (((positionY - 4) | 0) - 4) | 0;
      break;
    default:
      arrowTopPosition = (((positionY + componentHeight) | 0) + 4) | 0;
  }
  if (exit === 1) {
    arrowTopPosition =
      (((positionY + ((componentHeight / 2) | 0)) | 0) - 4) | 0;
  }
  var arrowLeftPosition;
  switch (position) {
    case "Left":
      arrowLeftPosition = hoverOnToolTip
        ? (((((positionX - 4) | 0) - ((tooltipArrowSize - 5) | 0)) | 0) - 4) | 0
        : (((positionX - 4) | 0) - 4) | 0;
      break;
    case "Right":
      arrowLeftPosition = (((positionX + componentWidth) | 0) + 4) | 0;
      break;
    default:
      arrowLeftPosition =
        (((positionX + ((componentWidth / 2) | 0)) | 0) - 5) | 0;
  }
  var tooltipArrowpixel = tooltipArrowSize.toString() + "px";
  var borderWidth;
  switch (position) {
    case "Left":
      borderWidth =
        tooltipArrowpixel + " 0 " + tooltipArrowpixel + " " + tooltipArrowpixel;
      break;
    case "Right":
      borderWidth =
        tooltipArrowpixel +
        " " +
        tooltipArrowpixel +
        " " +
        tooltipArrowpixel +
        " 0";
      break;
    case "Top":
    case "TopRight":
    case "TopLeft":
      borderWidth = tooltipArrowpixel + " " + tooltipArrowpixel + " 0";
      break;
    case "Bottom":
    case "BottomLeft":
    case "BottomRight":
      borderWidth = "0 " + tooltipArrowpixel + " " + tooltipArrowpixel;
      break;
  }
  var borderTopColor =
    position === "Top" || position === "TopLeft" || position === "TopRight"
      ? arrowColor
      : "transparent";
  var borderRightColor = position === "Right" ? arrowColor : "transparent";
  var borderBottomColor =
    position === "Bottom" ||
    position === "BottomLeft" ||
    position === "BottomRight"
      ? arrowColor
      : "transparent";
  var borderLeftColor = position === "Left" ? arrowColor : "transparent";
  return {
    borderTopColor: borderTopColor,
    borderRightColor: borderRightColor,
    borderBottomColor: borderBottomColor,
    borderLeftColor: borderLeftColor,
    borderWidth: borderWidth,
    height: "0",
    left: arrowLeftPosition.toString() + "px",
    top: arrowTopPosition.toString() + "px",
    width: "0",
  };
}

function getArrowAbsolutePosition(
  tooltipArrowWidth,
  tooltipArrowHeight,
  tooltipHeightFloat,
  tooltipWidth,
  arrowColor,
  position,
) {
  var arrowTopPosition;
  var exit = 0;
  switch (position) {
    case "Left":
    case "Right":
      exit = 2;
      break;
    case "Top":
    case "TopRight":
    case "TopLeft":
      exit = 1;
      break;
    default:
      arrowTopPosition = (tooltipArrowHeight / tooltipHeightFloat) * -100.0;
  }
  switch (exit) {
    case 1:
      arrowTopPosition =
        100.0 - (tooltipArrowHeight / tooltipHeightFloat) * -10.0;
      break;
    case 2:
      arrowTopPosition =
        50.0 - (tooltipArrowHeight / tooltipHeightFloat) * 50.0;
      break;
  }
  var arrowLeftPosition;
  switch (position) {
    case "Left":
      arrowLeftPosition = 100.0 + tooltipArrowWidth / tooltipWidth;
      break;
    case "Right":
      arrowLeftPosition = (tooltipArrowWidth / tooltipWidth) * -100.0;
      break;
    default:
      arrowLeftPosition = 50.0 - (tooltipArrowWidth / tooltipWidth) * 50.0;
  }
  var borderWidth;
  switch (position) {
    case "Left":
      borderWidth = "5px 0 5px 5px";
      break;
    case "Right":
      borderWidth = "5px 5px 5px 0";
      break;
    case "Top":
    case "TopRight":
    case "TopLeft":
      borderWidth = "5px 5px 0";
      break;
    case "Bottom":
    case "BottomLeft":
    case "BottomRight":
      borderWidth = "0 5px 5px";
      break;
  }
  var borderTopColor =
    position === "Top" || position === "TopLeft" || position === "TopRight"
      ? arrowColor
      : "transparent";
  var borderRightColor = position === "Right" ? arrowColor : "transparent";
  var borderBottomColor =
    position === "Bottom" ||
    position === "BottomLeft" ||
    position === "BottomRight"
      ? arrowColor
      : "transparent";
  var borderLeftColor = position === "Left" ? arrowColor : "transparent";
  return {
    borderTopColor: borderTopColor,
    borderRightColor: borderRightColor,
    borderBottomColor: borderBottomColor,
    borderLeftColor: borderLeftColor,
    borderWidth: borderWidth,
    height: "0",
    left: arrowLeftPosition.toString() + "%",
    top: arrowTopPosition.toString() + "%",
    width: "0",
  };
}

function ToolTip$Arrow(props) {
  var arrowBgClass = props.arrowBgClass;
  var componentHeight = props.componentHeight;
  var componentWidth = props.componentWidth;
  var tooltipArrowSize = props.tooltipArrowSize;
  var positionY = props.positionY;
  var positionX = props.positionX;
  var hoverOnToolTip = props.hoverOnToolTip;
  var toolTipPosition = props.toolTipPosition;
  var tooltipPositioning = props.tooltipPositioning;
  var theme = ThemeProvider.useTheme();
  var arrowBackGroundClass;
  arrowBackGroundClass = theme === "Light" ? "#000" : "#fff";
  var arrowColor =
    LogicUtils.isNonEmptyString(arrowBgClass) &&
    LogicUtils.isNonEmptyString(props.bgColor)
      ? arrowBgClass
      : arrowBackGroundClass;
  var tooltipArrowPosition =
    toolTipPosition !== undefined
      ? tooltipPositioning === "fixed"
        ? getArrowFixedPosition(
            hoverOnToolTip,
            positionX,
            positionY,
            tooltipArrowSize,
            componentWidth,
            componentHeight,
            arrowColor,
            toolTipPosition,
          )
        : getArrowAbsolutePosition(
            props.tooltipArrowWidth,
            props.tooltipArrowHeight,
            props.tooltipHeightFloat,
            props.tooltipWidth,
            arrowColor,
            toolTipPosition,
          )
      : getArrowFixedPosition(
          hoverOnToolTip,
          positionX,
          positionY,
          tooltipArrowSize,
          componentWidth,
          componentHeight,
          arrowColor,
          props.defaultPosition,
        );
  var toolTipPositionString =
    tooltipPositioning === "fixed"
      ? "fixed"
      : tooltipPositioning === "static"
        ? "static"
        : "absolute";
  return React.createElement("div", {
    ref: Caml_option.some(props.toolTipArrowRef),
    className:
      props.arrowCustomStyle +
      " " +
      toolTipPositionString +
      " border-solid z-50 w-auto",
    style: tooltipArrowPosition,
  });
}

function getDefaultPosition(
  positionX,
  positionY,
  componentWidth,
  componentHeight,
  tooltipWidth,
  tooltipHeight,
) {
  var tBoundingMidHeight = (((componentHeight + tooltipHeight) | 0) / 2) | 0;
  var tBoundingMidWidth = (((componentWidth + tooltipWidth) | 0) / 2) | 0;
  if (((window.innerWidth / 2) | 0) > positionX) {
    if (window.innerHeight < ((tBoundingMidHeight + positionY) | 0)) {
      if (positionX < tBoundingMidWidth) {
        return "TopRight";
      } else {
        return "Top";
      }
    } else if (0 < ((tBoundingMidHeight - positionY) | 0)) {
      if (positionX < tBoundingMidWidth) {
        return "BottomRight";
      } else {
        return "Bottom";
      }
    } else {
      return "Right";
    }
  } else if (window.innerHeight < ((tBoundingMidHeight + positionY) | 0)) {
    if (window.innerWidth < ((positionX + tBoundingMidWidth) | 0)) {
      return "TopLeft";
    } else {
      return "Top";
    }
  } else if (0 < ((tBoundingMidHeight - positionY) | 0)) {
    if (window.innerWidth < ((positionX + tBoundingMidWidth) | 0)) {
      return "BottomLeft";
    } else {
      return "Bottom";
    }
  } else {
    return "Left";
  }
}

function ToolTip(props) {
  var __newDesign = props.newDesign;
  var __dismissable = props.dismissable;
  var __isRelative = props.isRelative;
  var __descriptionComponentClass = props.descriptionComponentClass;
  var __visibleOnClick = props.visibleOnClick;
  var __tooltipArrowSize = props.tooltipArrowSize;
  var __hoverOnToolTip = props.hoverOnToolTip;
  var __textStyle = props.textStyle;
  var __height = props.height;
  var __flexClass = props.flexClass;
  var __justifyClass = props.justifyClass;
  var __contentAlign = props.contentAlign;
  var __bgColor = props.bgColor;
  var __arrowBgClass = props.arrowBgClass;
  var __textStyleGap = props.textStyleGap;
  var __arrowCustomStyle = props.arrowCustomStyle;
  var __customStyle = props.customStyle;
  var toolTipPosition = props.toolTipPosition;
  var __tooltipForWidthClass = props.tooltipForWidthClass;
  var __tooltipWidthClass = props.tooltipWidthClass;
  var __tooltipPositioning = props.tooltipPositioning;
  var __descriptionComponent = props.descriptionComponent;
  var __description = props.description;
  var description = __description !== undefined ? __description : "";
  var descriptionComponent =
    __descriptionComponent !== undefined
      ? Caml_option.valFromOption(__descriptionComponent)
      : null;
  var tooltipPositioning =
    __tooltipPositioning !== undefined ? __tooltipPositioning : "fixed";
  var tooltipWidthClass =
    __tooltipWidthClass !== undefined ? __tooltipWidthClass : "w-fit";
  var tooltipForWidthClass =
    __tooltipForWidthClass !== undefined ? __tooltipForWidthClass : "";
  var customStyle = __customStyle !== undefined ? __customStyle : "";
  var arrowCustomStyle =
    __arrowCustomStyle !== undefined ? __arrowCustomStyle : "";
  var textStyleGap = __textStyleGap !== undefined ? __textStyleGap : "";
  var arrowBgClass = __arrowBgClass !== undefined ? __arrowBgClass : "";
  var bgColor = __bgColor !== undefined ? __bgColor : "";
  var contentAlign = __contentAlign !== undefined ? __contentAlign : "Middle";
  var justifyClass =
    __justifyClass !== undefined ? __justifyClass : "justify-center";
  var flexClass = __flexClass !== undefined ? __flexClass : "flex-col";
  var height = __height !== undefined ? __height : "h-full";
  var textStyle = __textStyle !== undefined ? __textStyle : "text-xs leading-5";
  var hoverOnToolTip =
    __hoverOnToolTip !== undefined ? __hoverOnToolTip : false;
  var tooltipArrowSize =
    __tooltipArrowSize !== undefined ? __tooltipArrowSize : 5;
  var visibleOnClick =
    __visibleOnClick !== undefined ? __visibleOnClick : false;
  var descriptionComponentClass =
    __descriptionComponentClass !== undefined
      ? __descriptionComponentClass
      : "flex flex-row-reverse";
  var isRelative = __isRelative !== undefined ? __isRelative : true;
  var dismissable = __dismissable !== undefined ? __dismissable : false;
  var newDesign = __newDesign !== undefined ? __newDesign : false;
  var match = React.useState(function () {
    return false;
  });
  var setIsToolTipVisible = match[1];
  var isToolTipVisible = match[0];
  var toolTipRef = React.useRef(null);
  var componentRef = React.useRef(null);
  var toolTipArrowRef = React.useRef(null);
  React.useEffect(
    function () {
      if (!isToolTipVisible) {
        return;
      }
      var handleScroll = function (_e) {
        setIsToolTipVisible(function (param) {
          return false;
        });
      };
      window.addEventListener("scroll", handleScroll, true);
      return function () {
        window.removeEventListener("scroll", handleScroll);
      };
    },
    [isToolTipVisible],
  );
  var getBoundingRectInfo = function (ref, getter) {
    return Core__Option.mapOr(
      Core__Option.map(
        Caml_option.nullable_to_opt(ref.current),
        function (prim) {
          return prim.getBoundingClientRect();
        },
      ),
      0,
      getter,
    );
  };
  var tooltipWidth = getBoundingRectInfo(toolTipRef, function (val) {
    return val.width;
  });
  var tooltipHeight = getBoundingRectInfo(toolTipRef, function (val) {
    return val.height;
  });
  var tooltipArrowWidth = getBoundingRectInfo(toolTipArrowRef, function (val) {
    return val.width;
  });
  var tooltipArrowHeight = getBoundingRectInfo(toolTipArrowRef, function (val) {
    return val.height;
  });
  var positionX = getBoundingRectInfo(componentRef, function (val) {
    return val.x;
  });
  var positionY = getBoundingRectInfo(componentRef, function (val) {
    return val.y;
  });
  var componentWidth = getBoundingRectInfo(componentRef, function (val) {
    return val.width;
  });
  var componentHeight = getBoundingRectInfo(componentRef, function (val) {
    return val.height;
  });
  var tooltipBgClass = newDesign
    ? "bg-white rounded-lg shadow-lg ring-1 ring-black ring-opacity-5 text-jp-gray-800"
    : "dark:bg-jp-gray-tooltip_bg_dark bg-jp-gray-tooltip_bg_light dark:text-jp-gray-lightgray_background dark:text-opacity-75 text-jp-gray-text_darktheme text-opacity-75";
  var bgColor$1 = LogicUtils.isEmptyString(bgColor) ? tooltipBgClass : bgColor;
  var defaultPosition = getDefaultPosition(
    positionX,
    positionY,
    componentWidth,
    componentHeight,
    tooltipWidth,
    tooltipHeight,
  );
  return React.createElement(
    ToolTip$TooltipMainWrapper,
    {
      children: null,
      visibleOnClick: visibleOnClick,
      hoverOnToolTip: hoverOnToolTip,
      setIsToolTipVisible: setIsToolTipVisible,
      isRelative: isRelative,
      flexClass: flexClass,
      height: height,
      contentAlign: contentAlign,
      justifyClass: justifyClass,
    },
    React.createElement(ToolTip$TooltipFor, {
      toolTipFor: props.toolTipFor,
      tooltipForWidthClass: tooltipForWidthClass,
      componentRef: componentRef,
    }),
    React.createElement(
      ToolTip$TooltipWrapper,
      {
        isToolTipVisible: isToolTipVisible,
        descriptionComponent: descriptionComponent,
        description: description,
        hoverOnToolTip: hoverOnToolTip,
        tooltipPositioning: tooltipPositioning,
        tooltipWidthClass: tooltipWidthClass,
        toolTipRef: toolTipRef,
        textStyle: textStyle,
        bgColor: bgColor$1,
        customStyle: customStyle,
        positionX: positionX,
        positionY: positionY,
        tooltipArrowHeight: tooltipArrowHeight,
        tooltipHeightFloat: tooltipHeight,
        tooltipArrowWidth: tooltipArrowWidth,
        tooltipWidth: tooltipWidth,
        tooltipHeight: tooltipHeight,
        tooltipArrowSize: tooltipArrowSize,
        componentWidth: componentWidth,
        componentHeight: componentHeight,
        toolTipPosition: toolTipPosition,
        defaultPosition: defaultPosition,
        children: null,
      },
      React.createElement(ToolTip$DescriptionSection, {
        description: description,
        descriptionComponent: descriptionComponent,
        textStyleGap: textStyleGap,
        descriptionComponentClass: descriptionComponentClass,
        setIsToolTipVisible: setIsToolTipVisible,
        dismissable: dismissable,
      }),
      React.createElement(ToolTip$Arrow, {
        toolTipArrowRef: toolTipArrowRef,
        arrowCustomStyle: arrowCustomStyle,
        tooltipPositioning: tooltipPositioning,
        toolTipPosition: toolTipPosition,
        hoverOnToolTip: hoverOnToolTip,
        positionX: positionX,
        positionY: positionY,
        tooltipArrowWidth: tooltipArrowWidth,
        tooltipArrowHeight: tooltipArrowHeight,
        tooltipHeightFloat: tooltipHeight,
        tooltipArrowSize: tooltipArrowSize,
        tooltipWidth: tooltipWidth,
        componentWidth: componentWidth,
        componentHeight: componentHeight,
        bgColor: bgColor$1,
        arrowBgClass: arrowBgClass,
        defaultPosition: defaultPosition,
      }),
    ),
  );
}

var make = ToolTip;

export { make };
/* Icon Not a pure module */
